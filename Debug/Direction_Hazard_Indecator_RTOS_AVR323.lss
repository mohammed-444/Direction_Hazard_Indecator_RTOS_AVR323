
Direction_Hazard_Indecator_RTOS_AVR323.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005db4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e4  00800060  00005db4  00005e48  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000035b  00800144  00800144  00005f2c  2**0
                  ALLOC
  3 .stab         000093e4  00000000  00000000  00005f2c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006043  00000000  00000000  0000f310  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
       4:	0c 94 25 08 	jmp	0x104a	; 0x104a <__vector_1>
       8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      1c:	0c 94 05 0c 	jmp	0x180a	; 0x180a <__vector_7>
      20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      28:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      2c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      34:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      38:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>

00000050 <__ctors_end>:
      50:	11 24       	eor	r1, r1
      52:	1f be       	out	0x3f, r1	; 63
      54:	cf e5       	ldi	r28, 0x5F	; 95
      56:	d8 e0       	ldi	r29, 0x08	; 8
      58:	de bf       	out	0x3e, r29	; 62
      5a:	cd bf       	out	0x3d, r28	; 61

0000005c <__do_copy_data>:
      5c:	11 e0       	ldi	r17, 0x01	; 1
      5e:	a0 e6       	ldi	r26, 0x60	; 96
      60:	b0 e0       	ldi	r27, 0x00	; 0
      62:	e4 eb       	ldi	r30, 0xB4	; 180
      64:	fd e5       	ldi	r31, 0x5D	; 93
      66:	02 c0       	rjmp	.+4      	; 0x6c <.do_copy_data_start>

00000068 <.do_copy_data_loop>:
      68:	05 90       	lpm	r0, Z+
      6a:	0d 92       	st	X+, r0

0000006c <.do_copy_data_start>:
      6c:	a4 34       	cpi	r26, 0x44	; 68
      6e:	b1 07       	cpc	r27, r17
      70:	d9 f7       	brne	.-10     	; 0x68 <.do_copy_data_loop>

00000072 <__do_clear_bss>:
      72:	14 e0       	ldi	r17, 0x04	; 4
      74:	a4 e4       	ldi	r26, 0x44	; 68
      76:	b1 e0       	ldi	r27, 0x01	; 1
      78:	01 c0       	rjmp	.+2      	; 0x7c <.do_clear_bss_start>

0000007a <.do_clear_bss_loop>:
      7a:	1d 92       	st	X+, r1

0000007c <.do_clear_bss_start>:
      7c:	af 39       	cpi	r26, 0x9F	; 159
      7e:	b1 07       	cpc	r27, r17
      80:	e1 f7       	brne	.-8      	; 0x7a <.do_clear_bss_loop>
      82:	0e 94 41 08 	call	0x1082	; 0x1082 <main>
      86:	0c 94 d8 2e 	jmp	0x5db0	; 0x5db0 <_exit>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <PWM_Timer0_Start>:
      8e:	df 93       	push	r29
      90:	cf 93       	push	r28
      92:	cd b7       	in	r28, 0x3d	; 61
      94:	de b7       	in	r29, 0x3e	; 62
      96:	e3 e5       	ldi	r30, 0x53	; 83
      98:	f0 e0       	ldi	r31, 0x00	; 0
      9a:	88 e6       	ldi	r24, 0x68	; 104
      9c:	80 83       	st	Z, r24
      9e:	a3 e5       	ldi	r26, 0x53	; 83
      a0:	b0 e0       	ldi	r27, 0x00	; 0
      a2:	e3 e5       	ldi	r30, 0x53	; 83
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	88 7f       	andi	r24, 0xF8	; 248
      aa:	8c 93       	st	X, r24
      ac:	a3 e5       	ldi	r26, 0x53	; 83
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	e3 e5       	ldi	r30, 0x53	; 83
      b2:	f0 e0       	ldi	r31, 0x00	; 0
      b4:	80 81       	ld	r24, Z
      b6:	81 60       	ori	r24, 0x01	; 1
      b8:	8c 93       	st	X, r24
      ba:	ec e5       	ldi	r30, 0x5C	; 92
      bc:	f0 e0       	ldi	r31, 0x00	; 0
      be:	8f ef       	ldi	r24, 0xFF	; 255
      c0:	80 83       	st	Z, r24
      c2:	cf 91       	pop	r28
      c4:	df 91       	pop	r29
      c6:	08 95       	ret

000000c8 <PWM_Timer2_Start>:
* Parameters (input): None
* Parameters (out): None
* Return value: None
* Description: Function to Initialize the PWM for timer2 Driver module.
************************************************************************************/
void PWM_Timer2_Start(){
      c8:	df 93       	push	r29
      ca:	cf 93       	push	r28
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
	/*
	 * FOC0=0 PWM MODE
	 * PWM2 & CTC2 =1 FAST PWM
	 * COM21 =1 NON INVERTING MODE
	 * */
	TCCR2 = (1<<PWM2)|(1<<CTC2)|(1<<COM21);
      d0:	e5 e4       	ldi	r30, 0x45	; 69
      d2:	f0 e0       	ldi	r31, 0x00	; 0
      d4:	88 e6       	ldi	r24, 0x68	; 104
      d6:	80 83       	st	Z, r24
	/*mask the first 3 bit and make them 0*/
	TCCR2 = TCCR2 & (0xFF<<PRESCALER_INTERVAL_SIZE);
      d8:	a5 e4       	ldi	r26, 0x45	; 69
      da:	b0 e0       	ldi	r27, 0x00	; 0
      dc:	e5 e4       	ldi	r30, 0x45	; 69
      de:	f0 e0       	ldi	r31, 0x00	; 0
      e0:	80 81       	ld	r24, Z
      e2:	88 7f       	andi	r24, 0xF8	; 248
      e4:	8c 93       	st	X, r24
	/*putting  the new value for the first 3 bits*/
	TCCR2 = TCCR2 |(TIMER_2_PRESCALER_VALUE);
      e6:	a5 e4       	ldi	r26, 0x45	; 69
      e8:	b0 e0       	ldi	r27, 0x00	; 0
      ea:	e5 e4       	ldi	r30, 0x45	; 69
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	80 81       	ld	r24, Z
      f0:	81 60       	ori	r24, 0x01	; 1
      f2:	8c 93       	st	X, r24


	/*write the compare value to decide the duty cycle*/
	OCR2 = (uint8) (((float32) TIMER_2_DUTY_CYCLE * 255) / (float32)100);
      f4:	e3 e4       	ldi	r30, 0x43	; 67
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	8f ef       	ldi	r24, 0xFF	; 255
      fa:	80 83       	st	Z, r24

}
      fc:	cf 91       	pop	r28
      fe:	df 91       	pop	r29
     100:	08 95       	ret

00000102 <PWM_Timer0_Stop>:
* Parameters (out): None
* Return value: None
* Description: Function to stop the PWM for timer0 Driver module.
************************************************************************************/
void PWM_Timer0_Stop()
{
     102:	df 93       	push	r29
     104:	cf 93       	push	r28
     106:	cd b7       	in	r28, 0x3d	; 61
     108:	de b7       	in	r29, 0x3e	; 62
	/*mask the first 3 bit and make them 0 which mean no clock*/
	TCCR0 = 0;
     10a:	e3 e5       	ldi	r30, 0x53	; 83
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	10 82       	st	Z, r1
}
     110:	cf 91       	pop	r28
     112:	df 91       	pop	r29
     114:	08 95       	ret

00000116 <PWM_Timer2_Stop>:
* Parameters (out): None
* Return value: None
* Description: Function to stop the PWM for timer2 Driver module.
************************************************************************************/
void PWM_Timer2_Stop()
{
     116:	df 93       	push	r29
     118:	cf 93       	push	r28
     11a:	cd b7       	in	r28, 0x3d	; 61
     11c:	de b7       	in	r29, 0x3e	; 62
	/*mask the first 3 bit and make them 0 which mean no clock*/
	TCCR2 = 0;
     11e:	e5 e4       	ldi	r30, 0x45	; 69
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	10 82       	st	Z, r1
}
     124:	cf 91       	pop	r28
     126:	df 91       	pop	r29
     128:	08 95       	ret

0000012a <GPIO_Init>:
 * Description :
 * configure every pin in the gpio.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(void)
{
     12a:	df 93       	push	r29
     12c:	cf 93       	push	r28
     12e:	0f 92       	push	r0
     130:	cd b7       	in	r28, 0x3d	; 61
     132:	de b7       	in	r29, 0x3e	; 62
    uint8 i = 0;
     134:	19 82       	std	Y+1, r1	; 0x01
     136:	b4 c0       	rjmp	.+360    	; 0x2a0 <GPIO_Init+0x176>
    for (; i < TOTAL_PINS_NUM; ++i)
    {
	if(((GPIO_ConfigPin[i].pin_num) >= NUM_OF_PINS_PER_PORT) || ((GPIO_ConfigPin[i].port_num )>= NUM_OF_PORTS) )
     138:	89 81       	ldd	r24, Y+1	; 0x01
     13a:	28 2f       	mov	r18, r24
     13c:	30 e0       	ldi	r19, 0x00	; 0
     13e:	c9 01       	movw	r24, r18
     140:	88 0f       	add	r24, r24
     142:	99 1f       	adc	r25, r25
     144:	88 0f       	add	r24, r24
     146:	99 1f       	adc	r25, r25
     148:	82 0f       	add	r24, r18
     14a:	93 1f       	adc	r25, r19
     14c:	fc 01       	movw	r30, r24
     14e:	e4 56       	subi	r30, 0x64	; 100
     150:	ff 4f       	sbci	r31, 0xFF	; 255
     152:	80 81       	ld	r24, Z
     154:	88 30       	cpi	r24, 0x08	; 8
     156:	08 f0       	brcs	.+2      	; 0x15a <GPIO_Init+0x30>
     158:	a0 c0       	rjmp	.+320    	; 0x29a <GPIO_Init+0x170>
     15a:	89 81       	ldd	r24, Y+1	; 0x01
     15c:	28 2f       	mov	r18, r24
     15e:	30 e0       	ldi	r19, 0x00	; 0
     160:	c9 01       	movw	r24, r18
     162:	88 0f       	add	r24, r24
     164:	99 1f       	adc	r25, r25
     166:	88 0f       	add	r24, r24
     168:	99 1f       	adc	r25, r25
     16a:	82 0f       	add	r24, r18
     16c:	93 1f       	adc	r25, r19
     16e:	fc 01       	movw	r30, r24
     170:	e5 56       	subi	r30, 0x65	; 101
     172:	ff 4f       	sbci	r31, 0xFF	; 255
     174:	80 81       	ld	r24, Z
     176:	84 30       	cpi	r24, 0x04	; 4
     178:	08 f0       	brcs	.+2      	; 0x17c <GPIO_Init+0x52>
     17a:	8f c0       	rjmp	.+286    	; 0x29a <GPIO_Init+0x170>
		/* Do Nothing */
	}
	else
	{

		GPIO_setupPinDirection(GPIO_ConfigPin[i].port_num, GPIO_ConfigPin[i].pin_num, GPIO_ConfigPin[i].direction);
     17c:	89 81       	ldd	r24, Y+1	; 0x01
     17e:	28 2f       	mov	r18, r24
     180:	30 e0       	ldi	r19, 0x00	; 0
     182:	c9 01       	movw	r24, r18
     184:	88 0f       	add	r24, r24
     186:	99 1f       	adc	r25, r25
     188:	88 0f       	add	r24, r24
     18a:	99 1f       	adc	r25, r25
     18c:	82 0f       	add	r24, r18
     18e:	93 1f       	adc	r25, r19
     190:	fc 01       	movw	r30, r24
     192:	e5 56       	subi	r30, 0x65	; 101
     194:	ff 4f       	sbci	r31, 0xFF	; 255
     196:	50 81       	ld	r21, Z
     198:	89 81       	ldd	r24, Y+1	; 0x01
     19a:	28 2f       	mov	r18, r24
     19c:	30 e0       	ldi	r19, 0x00	; 0
     19e:	c9 01       	movw	r24, r18
     1a0:	88 0f       	add	r24, r24
     1a2:	99 1f       	adc	r25, r25
     1a4:	88 0f       	add	r24, r24
     1a6:	99 1f       	adc	r25, r25
     1a8:	82 0f       	add	r24, r18
     1aa:	93 1f       	adc	r25, r19
     1ac:	fc 01       	movw	r30, r24
     1ae:	e4 56       	subi	r30, 0x64	; 100
     1b0:	ff 4f       	sbci	r31, 0xFF	; 255
     1b2:	40 81       	ld	r20, Z
     1b4:	89 81       	ldd	r24, Y+1	; 0x01
     1b6:	28 2f       	mov	r18, r24
     1b8:	30 e0       	ldi	r19, 0x00	; 0
     1ba:	c9 01       	movw	r24, r18
     1bc:	88 0f       	add	r24, r24
     1be:	99 1f       	adc	r25, r25
     1c0:	88 0f       	add	r24, r24
     1c2:	99 1f       	adc	r25, r25
     1c4:	82 0f       	add	r24, r18
     1c6:	93 1f       	adc	r25, r19
     1c8:	fc 01       	movw	r30, r24
     1ca:	e3 56       	subi	r30, 0x63	; 99
     1cc:	ff 4f       	sbci	r31, 0xFF	; 255
     1ce:	90 81       	ld	r25, Z
     1d0:	85 2f       	mov	r24, r21
     1d2:	64 2f       	mov	r22, r20
     1d4:	49 2f       	mov	r20, r25
     1d6:	0e 94 49 02 	call	0x492	; 0x492 <GPIO_setupPinDirection>

		GPIO_writePin(GPIO_ConfigPin[i].port_num, GPIO_ConfigPin[i].pin_num, GPIO_ConfigPin[i].initial_value);
     1da:	89 81       	ldd	r24, Y+1	; 0x01
     1dc:	28 2f       	mov	r18, r24
     1de:	30 e0       	ldi	r19, 0x00	; 0
     1e0:	c9 01       	movw	r24, r18
     1e2:	88 0f       	add	r24, r24
     1e4:	99 1f       	adc	r25, r25
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	82 0f       	add	r24, r18
     1ec:	93 1f       	adc	r25, r19
     1ee:	fc 01       	movw	r30, r24
     1f0:	e5 56       	subi	r30, 0x65	; 101
     1f2:	ff 4f       	sbci	r31, 0xFF	; 255
     1f4:	50 81       	ld	r21, Z
     1f6:	89 81       	ldd	r24, Y+1	; 0x01
     1f8:	28 2f       	mov	r18, r24
     1fa:	30 e0       	ldi	r19, 0x00	; 0
     1fc:	c9 01       	movw	r24, r18
     1fe:	88 0f       	add	r24, r24
     200:	99 1f       	adc	r25, r25
     202:	88 0f       	add	r24, r24
     204:	99 1f       	adc	r25, r25
     206:	82 0f       	add	r24, r18
     208:	93 1f       	adc	r25, r19
     20a:	fc 01       	movw	r30, r24
     20c:	e4 56       	subi	r30, 0x64	; 100
     20e:	ff 4f       	sbci	r31, 0xFF	; 255
     210:	40 81       	ld	r20, Z
     212:	89 81       	ldd	r24, Y+1	; 0x01
     214:	28 2f       	mov	r18, r24
     216:	30 e0       	ldi	r19, 0x00	; 0
     218:	c9 01       	movw	r24, r18
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	82 0f       	add	r24, r18
     224:	93 1f       	adc	r25, r19
     226:	fc 01       	movw	r30, r24
     228:	e1 56       	subi	r30, 0x61	; 97
     22a:	ff 4f       	sbci	r31, 0xFF	; 255
     22c:	90 81       	ld	r25, Z
     22e:	85 2f       	mov	r24, r21
     230:	64 2f       	mov	r22, r20
     232:	49 2f       	mov	r20, r25
     234:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>


		if(GPIO_ConfigPin[i].resistor == GPIO_PULL_UP)
     238:	89 81       	ldd	r24, Y+1	; 0x01
     23a:	28 2f       	mov	r18, r24
     23c:	30 e0       	ldi	r19, 0x00	; 0
     23e:	c9 01       	movw	r24, r18
     240:	88 0f       	add	r24, r24
     242:	99 1f       	adc	r25, r25
     244:	88 0f       	add	r24, r24
     246:	99 1f       	adc	r25, r25
     248:	82 0f       	add	r24, r18
     24a:	93 1f       	adc	r25, r19
     24c:	fc 01       	movw	r30, r24
     24e:	e2 56       	subi	r30, 0x62	; 98
     250:	ff 4f       	sbci	r31, 0xFF	; 255
     252:	80 81       	ld	r24, Z
     254:	81 30       	cpi	r24, 0x01	; 1
     256:	09 f5       	brne	.+66     	; 0x29a <GPIO_Init+0x170>
		{
			GPIO_writePin(GPIO_ConfigPin[i].port_num, GPIO_ConfigPin[i].pin_num,LOGIC_HIGH);
     258:	89 81       	ldd	r24, Y+1	; 0x01
     25a:	28 2f       	mov	r18, r24
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	c9 01       	movw	r24, r18
     260:	88 0f       	add	r24, r24
     262:	99 1f       	adc	r25, r25
     264:	88 0f       	add	r24, r24
     266:	99 1f       	adc	r25, r25
     268:	82 0f       	add	r24, r18
     26a:	93 1f       	adc	r25, r19
     26c:	fc 01       	movw	r30, r24
     26e:	e5 56       	subi	r30, 0x65	; 101
     270:	ff 4f       	sbci	r31, 0xFF	; 255
     272:	40 81       	ld	r20, Z
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	28 2f       	mov	r18, r24
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	c9 01       	movw	r24, r18
     27c:	88 0f       	add	r24, r24
     27e:	99 1f       	adc	r25, r25
     280:	88 0f       	add	r24, r24
     282:	99 1f       	adc	r25, r25
     284:	82 0f       	add	r24, r18
     286:	93 1f       	adc	r25, r19
     288:	fc 01       	movw	r30, r24
     28a:	e4 56       	subi	r30, 0x64	; 100
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	90 81       	ld	r25, Z
     290:	84 2f       	mov	r24, r20
     292:	69 2f       	mov	r22, r25
     294:	41 e0       	ldi	r20, 0x01	; 1
     296:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_Init(void)
{
    uint8 i = 0;
    for (; i < TOTAL_PINS_NUM; ++i)
     29a:	89 81       	ldd	r24, Y+1	; 0x01
     29c:	8f 5f       	subi	r24, 0xFF	; 255
     29e:	89 83       	std	Y+1, r24	; 0x01
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	80 32       	cpi	r24, 0x20	; 32
     2a4:	08 f4       	brcc	.+2      	; 0x2a8 <GPIO_Init+0x17e>
     2a6:	48 cf       	rjmp	.-368    	; 0x138 <GPIO_Init+0xe>
		{

		}
	}
}
}
     2a8:	0f 90       	pop	r0
     2aa:	cf 91       	pop	r28
     2ac:	df 91       	pop	r29
     2ae:	08 95       	ret

000002b0 <GPIO_ChannelGroupWrite>:
/*
 *  Description :
 *  write in a group of of pin
 */
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
     2b0:	df 93       	push	r29
     2b2:	cf 93       	push	r28
     2b4:	cd b7       	in	r28, 0x3d	; 61
     2b6:	de b7       	in	r29, 0x3e	; 62
     2b8:	28 97       	sbiw	r28, 0x08	; 8
     2ba:	0f b6       	in	r0, 0x3f	; 63
     2bc:	f8 94       	cli
     2be:	de bf       	out	0x3e, r29	; 62
     2c0:	0f be       	out	0x3f, r0	; 63
     2c2:	cd bf       	out	0x3d, r28	; 61
     2c4:	9e 83       	std	Y+6, r25	; 0x06
     2c6:	8d 83       	std	Y+5, r24	; 0x05
     2c8:	78 87       	std	Y+8, r23	; 0x08
     2ca:	6f 83       	std	Y+7, r22	; 0x07
    uint8 i = 0;
     2cc:	1c 82       	std	Y+4, r1	; 0x04
    uint8 id=0;
     2ce:	1b 82       	std	Y+3, r1	; 0x03
    uint8 port_num=0;
     2d0:	1a 82       	std	Y+2, r1	; 0x02
    uint8 pin_num=0;
     2d2:	19 82       	std	Y+1, r1	; 0x01
     2d4:	40 c0       	rjmp	.+128    	; 0x356 <GPIO_ChannelGroupWrite+0xa6>
	for(; i < ChannelID->no_of_channels; ++i)
	{
	    id= ChannelID->group_ids[i];
     2d6:	8c 81       	ldd	r24, Y+4	; 0x04
     2d8:	28 2f       	mov	r18, r24
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	8d 81       	ldd	r24, Y+5	; 0x05
     2de:	9e 81       	ldd	r25, Y+6	; 0x06
     2e0:	82 0f       	add	r24, r18
     2e2:	93 1f       	adc	r25, r19
     2e4:	fc 01       	movw	r30, r24
     2e6:	31 96       	adiw	r30, 0x01	; 1
     2e8:	80 81       	ld	r24, Z
     2ea:	8b 83       	std	Y+3, r24	; 0x03
	    port_num = GPIO_ConfigPin[id].port_num;
     2ec:	8b 81       	ldd	r24, Y+3	; 0x03
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	c9 01       	movw	r24, r18
     2f4:	88 0f       	add	r24, r24
     2f6:	99 1f       	adc	r25, r25
     2f8:	88 0f       	add	r24, r24
     2fa:	99 1f       	adc	r25, r25
     2fc:	82 0f       	add	r24, r18
     2fe:	93 1f       	adc	r25, r19
     300:	fc 01       	movw	r30, r24
     302:	e5 56       	subi	r30, 0x65	; 101
     304:	ff 4f       	sbci	r31, 0xFF	; 255
     306:	80 81       	ld	r24, Z
     308:	8a 83       	std	Y+2, r24	; 0x02
	    pin_num=GPIO_ConfigPin[id].pin_num;
     30a:	8b 81       	ldd	r24, Y+3	; 0x03
     30c:	28 2f       	mov	r18, r24
     30e:	30 e0       	ldi	r19, 0x00	; 0
     310:	c9 01       	movw	r24, r18
     312:	88 0f       	add	r24, r24
     314:	99 1f       	adc	r25, r25
     316:	88 0f       	add	r24, r24
     318:	99 1f       	adc	r25, r25
     31a:	82 0f       	add	r24, r18
     31c:	93 1f       	adc	r25, r19
     31e:	fc 01       	movw	r30, r24
     320:	e4 56       	subi	r30, 0x64	; 100
     322:	ff 4f       	sbci	r31, 0xFF	; 255
     324:	80 81       	ld	r24, Z
     326:	89 83       	std	Y+1, r24	; 0x01

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
     328:	89 81       	ldd	r24, Y+1	; 0x01
     32a:	88 30       	cpi	r24, 0x08	; 8
     32c:	88 f4       	brcc	.+34     	; 0x350 <GPIO_ChannelGroupWrite+0xa0>
     32e:	8a 81       	ldd	r24, Y+2	; 0x02
     330:	84 30       	cpi	r24, 0x04	; 4
     332:	70 f4       	brcc	.+28     	; 0x350 <GPIO_ChannelGroupWrite+0xa0>
		}
		else
		{


			GPIO_writePin(port_num, pin_num,dataPtr[i]);
     334:	8c 81       	ldd	r24, Y+4	; 0x04
     336:	28 2f       	mov	r18, r24
     338:	30 e0       	ldi	r19, 0x00	; 0
     33a:	8f 81       	ldd	r24, Y+7	; 0x07
     33c:	98 85       	ldd	r25, Y+8	; 0x08
     33e:	fc 01       	movw	r30, r24
     340:	e2 0f       	add	r30, r18
     342:	f3 1f       	adc	r31, r19
     344:	90 81       	ld	r25, Z
     346:	8a 81       	ldd	r24, Y+2	; 0x02
     348:	69 81       	ldd	r22, Y+1	; 0x01
     34a:	49 2f       	mov	r20, r25
     34c:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
void GPIO_ChannelGroupWrite(ChannelGroupType* ChannelID ,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
     350:	8c 81       	ldd	r24, Y+4	; 0x04
     352:	8f 5f       	subi	r24, 0xFF	; 255
     354:	8c 83       	std	Y+4, r24	; 0x04
     356:	ed 81       	ldd	r30, Y+5	; 0x05
     358:	fe 81       	ldd	r31, Y+6	; 0x06
     35a:	90 81       	ld	r25, Z
     35c:	8c 81       	ldd	r24, Y+4	; 0x04
     35e:	89 17       	cp	r24, r25
     360:	08 f4       	brcc	.+2      	; 0x364 <GPIO_ChannelGroupWrite+0xb4>
     362:	b9 cf       	rjmp	.-142    	; 0x2d6 <GPIO_ChannelGroupWrite+0x26>

			GPIO_writePin(port_num, pin_num,dataPtr[i]);

		}
	}
}
     364:	28 96       	adiw	r28, 0x08	; 8
     366:	0f b6       	in	r0, 0x3f	; 63
     368:	f8 94       	cli
     36a:	de bf       	out	0x3e, r29	; 62
     36c:	0f be       	out	0x3f, r0	; 63
     36e:	cd bf       	out	0x3d, r28	; 61
     370:	cf 91       	pop	r28
     372:	df 91       	pop	r29
     374:	08 95       	ret

00000376 <GPIO_ChannelGroupRead>:
/*
 *  Description :
 *  read in a group of of pin
 */
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
     376:	0f 93       	push	r16
     378:	1f 93       	push	r17
     37a:	df 93       	push	r29
     37c:	cf 93       	push	r28
     37e:	cd b7       	in	r28, 0x3d	; 61
     380:	de b7       	in	r29, 0x3e	; 62
     382:	28 97       	sbiw	r28, 0x08	; 8
     384:	0f b6       	in	r0, 0x3f	; 63
     386:	f8 94       	cli
     388:	de bf       	out	0x3e, r29	; 62
     38a:	0f be       	out	0x3f, r0	; 63
     38c:	cd bf       	out	0x3d, r28	; 61
     38e:	9e 83       	std	Y+6, r25	; 0x06
     390:	8d 83       	std	Y+5, r24	; 0x05
     392:	78 87       	std	Y+8, r23	; 0x08
     394:	6f 83       	std	Y+7, r22	; 0x07
    uint8 i = 0;
     396:	1c 82       	std	Y+4, r1	; 0x04
    uint8 id=0;
     398:	1b 82       	std	Y+3, r1	; 0x03
    uint8 port_num=0;
     39a:	1a 82       	std	Y+2, r1	; 0x02
    uint8 pin_num=0;
     39c:	19 82       	std	Y+1, r1	; 0x01
     39e:	67 c0       	rjmp	.+206    	; 0x46e <GPIO_ChannelGroupRead+0xf8>
	for(; i < ChannelID->no_of_channels; ++i)
	{
		id= ChannelID->group_ids[i];
     3a0:	8c 81       	ldd	r24, Y+4	; 0x04
     3a2:	28 2f       	mov	r18, r24
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	8d 81       	ldd	r24, Y+5	; 0x05
     3a8:	9e 81       	ldd	r25, Y+6	; 0x06
     3aa:	82 0f       	add	r24, r18
     3ac:	93 1f       	adc	r25, r19
     3ae:	fc 01       	movw	r30, r24
     3b0:	31 96       	adiw	r30, 0x01	; 1
     3b2:	80 81       	ld	r24, Z
     3b4:	8b 83       	std	Y+3, r24	; 0x03
		port_num = GPIO_ConfigPin[id].port_num;
     3b6:	8b 81       	ldd	r24, Y+3	; 0x03
     3b8:	28 2f       	mov	r18, r24
     3ba:	30 e0       	ldi	r19, 0x00	; 0
     3bc:	c9 01       	movw	r24, r18
     3be:	88 0f       	add	r24, r24
     3c0:	99 1f       	adc	r25, r25
     3c2:	88 0f       	add	r24, r24
     3c4:	99 1f       	adc	r25, r25
     3c6:	82 0f       	add	r24, r18
     3c8:	93 1f       	adc	r25, r19
     3ca:	fc 01       	movw	r30, r24
     3cc:	e5 56       	subi	r30, 0x65	; 101
     3ce:	ff 4f       	sbci	r31, 0xFF	; 255
     3d0:	80 81       	ld	r24, Z
     3d2:	8a 83       	std	Y+2, r24	; 0x02
		pin_num=GPIO_ConfigPin[id].pin_num;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	28 2f       	mov	r18, r24
     3d8:	30 e0       	ldi	r19, 0x00	; 0
     3da:	c9 01       	movw	r24, r18
     3dc:	88 0f       	add	r24, r24
     3de:	99 1f       	adc	r25, r25
     3e0:	88 0f       	add	r24, r24
     3e2:	99 1f       	adc	r25, r25
     3e4:	82 0f       	add	r24, r18
     3e6:	93 1f       	adc	r25, r19
     3e8:	fc 01       	movw	r30, r24
     3ea:	e4 56       	subi	r30, 0x64	; 100
     3ec:	ff 4f       	sbci	r31, 0xFF	; 255
     3ee:	80 81       	ld	r24, Z
     3f0:	89 83       	std	Y+1, r24	; 0x01

		if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS) )
     3f2:	89 81       	ldd	r24, Y+1	; 0x01
     3f4:	88 30       	cpi	r24, 0x08	; 8
     3f6:	c0 f5       	brcc	.+112    	; 0x468 <GPIO_ChannelGroupRead+0xf2>
     3f8:	8a 81       	ldd	r24, Y+2	; 0x02
     3fa:	84 30       	cpi	r24, 0x04	; 4
     3fc:	a8 f5       	brcc	.+106    	; 0x468 <GPIO_ChannelGroupRead+0xf2>
			/* Do Nothing */
		}
		else
		{

			if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
     3fe:	8a 81       	ldd	r24, Y+2	; 0x02
     400:	69 81       	ldd	r22, Y+1	; 0x01
     402:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     406:	81 30       	cpi	r24, 0x01	; 1
     408:	a9 f4       	brne	.+42     	; 0x434 <GPIO_ChannelGroupRead+0xbe>
			{
/*				_delay_ms((double)30);*/
				if(GPIO_readPin(port_num, pin_num) == LOGIC_HIGH)
     40a:	8a 81       	ldd	r24, Y+2	; 0x02
     40c:	69 81       	ldd	r22, Y+1	; 0x01
     40e:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     412:	81 30       	cpi	r24, 0x01	; 1
     414:	49 f5       	brne	.+82     	; 0x468 <GPIO_ChannelGroupRead+0xf2>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
     416:	8c 81       	ldd	r24, Y+4	; 0x04
     418:	28 2f       	mov	r18, r24
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	8f 81       	ldd	r24, Y+7	; 0x07
     41e:	98 85       	ldd	r25, Y+8	; 0x08
     420:	8c 01       	movw	r16, r24
     422:	02 0f       	add	r16, r18
     424:	13 1f       	adc	r17, r19
     426:	8a 81       	ldd	r24, Y+2	; 0x02
     428:	69 81       	ldd	r22, Y+1	; 0x01
     42a:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     42e:	f8 01       	movw	r30, r16
     430:	80 83       	st	Z, r24
     432:	1a c0       	rjmp	.+52     	; 0x468 <GPIO_ChannelGroupRead+0xf2>
				}
			}
			else if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
     434:	8a 81       	ldd	r24, Y+2	; 0x02
     436:	69 81       	ldd	r22, Y+1	; 0x01
     438:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     43c:	88 23       	and	r24, r24
     43e:	a1 f4       	brne	.+40     	; 0x468 <GPIO_ChannelGroupRead+0xf2>
			{
/*				_delay_ms((double)30);*/
				if(GPIO_readPin(port_num, pin_num) == LOGIC_LOW)
     440:	8a 81       	ldd	r24, Y+2	; 0x02
     442:	69 81       	ldd	r22, Y+1	; 0x01
     444:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     448:	88 23       	and	r24, r24
     44a:	71 f4       	brne	.+28     	; 0x468 <GPIO_ChannelGroupRead+0xf2>
				{
				dataPtr[i] = GPIO_readPin(port_num, pin_num);
     44c:	8c 81       	ldd	r24, Y+4	; 0x04
     44e:	28 2f       	mov	r18, r24
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	8f 81       	ldd	r24, Y+7	; 0x07
     454:	98 85       	ldd	r25, Y+8	; 0x08
     456:	8c 01       	movw	r16, r24
     458:	02 0f       	add	r16, r18
     45a:	13 1f       	adc	r17, r19
     45c:	8a 81       	ldd	r24, Y+2	; 0x02
     45e:	69 81       	ldd	r22, Y+1	; 0x01
     460:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     464:	f8 01       	movw	r30, r16
     466:	80 83       	st	Z, r24
void GPIO_ChannelGroupRead(ChannelGroupType* ChannelID,uint8 dataPtr[]){
    uint8 i = 0;
    uint8 id=0;
    uint8 port_num=0;
    uint8 pin_num=0;
	for(; i < ChannelID->no_of_channels; ++i)
     468:	8c 81       	ldd	r24, Y+4	; 0x04
     46a:	8f 5f       	subi	r24, 0xFF	; 255
     46c:	8c 83       	std	Y+4, r24	; 0x04
     46e:	ed 81       	ldd	r30, Y+5	; 0x05
     470:	fe 81       	ldd	r31, Y+6	; 0x06
     472:	90 81       	ld	r25, Z
     474:	8c 81       	ldd	r24, Y+4	; 0x04
     476:	89 17       	cp	r24, r25
     478:	08 f4       	brcc	.+2      	; 0x47c <GPIO_ChannelGroupRead+0x106>
     47a:	92 cf       	rjmp	.-220    	; 0x3a0 <GPIO_ChannelGroupRead+0x2a>

			}

		}
	}
}
     47c:	28 96       	adiw	r28, 0x08	; 8
     47e:	0f b6       	in	r0, 0x3f	; 63
     480:	f8 94       	cli
     482:	de bf       	out	0x3e, r29	; 62
     484:	0f be       	out	0x3f, r0	; 63
     486:	cd bf       	out	0x3d, r28	; 61
     488:	cf 91       	pop	r28
     48a:	df 91       	pop	r29
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	08 95       	ret

00000492 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
     492:	df 93       	push	r29
     494:	cf 93       	push	r28
     496:	00 d0       	rcall	.+0      	; 0x498 <GPIO_setupPinDirection+0x6>
     498:	00 d0       	rcall	.+0      	; 0x49a <GPIO_setupPinDirection+0x8>
     49a:	0f 92       	push	r0
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
     4a0:	89 83       	std	Y+1, r24	; 0x01
     4a2:	6a 83       	std	Y+2, r22	; 0x02
     4a4:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
     4a6:	8a 81       	ldd	r24, Y+2	; 0x02
     4a8:	88 30       	cpi	r24, 0x08	; 8
     4aa:	08 f0       	brcs	.+2      	; 0x4ae <GPIO_setupPinDirection+0x1c>
     4ac:	d5 c0       	rjmp	.+426    	; 0x658 <GPIO_setupPinDirection+0x1c6>
     4ae:	89 81       	ldd	r24, Y+1	; 0x01
     4b0:	84 30       	cpi	r24, 0x04	; 4
     4b2:	08 f0       	brcs	.+2      	; 0x4b6 <GPIO_setupPinDirection+0x24>
     4b4:	d1 c0       	rjmp	.+418    	; 0x658 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
     4b6:	89 81       	ldd	r24, Y+1	; 0x01
     4b8:	28 2f       	mov	r18, r24
     4ba:	30 e0       	ldi	r19, 0x00	; 0
     4bc:	3d 83       	std	Y+5, r19	; 0x05
     4be:	2c 83       	std	Y+4, r18	; 0x04
     4c0:	8c 81       	ldd	r24, Y+4	; 0x04
     4c2:	9d 81       	ldd	r25, Y+5	; 0x05
     4c4:	81 30       	cpi	r24, 0x01	; 1
     4c6:	91 05       	cpc	r25, r1
     4c8:	09 f4       	brne	.+2      	; 0x4cc <GPIO_setupPinDirection+0x3a>
     4ca:	43 c0       	rjmp	.+134    	; 0x552 <GPIO_setupPinDirection+0xc0>
     4cc:	2c 81       	ldd	r18, Y+4	; 0x04
     4ce:	3d 81       	ldd	r19, Y+5	; 0x05
     4d0:	22 30       	cpi	r18, 0x02	; 2
     4d2:	31 05       	cpc	r19, r1
     4d4:	2c f4       	brge	.+10     	; 0x4e0 <GPIO_setupPinDirection+0x4e>
     4d6:	8c 81       	ldd	r24, Y+4	; 0x04
     4d8:	9d 81       	ldd	r25, Y+5	; 0x05
     4da:	00 97       	sbiw	r24, 0x00	; 0
     4dc:	71 f0       	breq	.+28     	; 0x4fa <GPIO_setupPinDirection+0x68>
     4de:	bc c0       	rjmp	.+376    	; 0x658 <GPIO_setupPinDirection+0x1c6>
     4e0:	2c 81       	ldd	r18, Y+4	; 0x04
     4e2:	3d 81       	ldd	r19, Y+5	; 0x05
     4e4:	22 30       	cpi	r18, 0x02	; 2
     4e6:	31 05       	cpc	r19, r1
     4e8:	09 f4       	brne	.+2      	; 0x4ec <GPIO_setupPinDirection+0x5a>
     4ea:	5f c0       	rjmp	.+190    	; 0x5aa <GPIO_setupPinDirection+0x118>
     4ec:	8c 81       	ldd	r24, Y+4	; 0x04
     4ee:	9d 81       	ldd	r25, Y+5	; 0x05
     4f0:	83 30       	cpi	r24, 0x03	; 3
     4f2:	91 05       	cpc	r25, r1
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <GPIO_setupPinDirection+0x66>
     4f6:	85 c0       	rjmp	.+266    	; 0x602 <GPIO_setupPinDirection+0x170>
     4f8:	af c0       	rjmp	.+350    	; 0x658 <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
     4fa:	8b 81       	ldd	r24, Y+3	; 0x03
     4fc:	81 30       	cpi	r24, 0x01	; 1
     4fe:	a1 f4       	brne	.+40     	; 0x528 <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
     500:	aa e3       	ldi	r26, 0x3A	; 58
     502:	b0 e0       	ldi	r27, 0x00	; 0
     504:	ea e3       	ldi	r30, 0x3A	; 58
     506:	f0 e0       	ldi	r31, 0x00	; 0
     508:	80 81       	ld	r24, Z
     50a:	48 2f       	mov	r20, r24
     50c:	8a 81       	ldd	r24, Y+2	; 0x02
     50e:	28 2f       	mov	r18, r24
     510:	30 e0       	ldi	r19, 0x00	; 0
     512:	81 e0       	ldi	r24, 0x01	; 1
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	02 2e       	mov	r0, r18
     518:	02 c0       	rjmp	.+4      	; 0x51e <GPIO_setupPinDirection+0x8c>
     51a:	88 0f       	add	r24, r24
     51c:	99 1f       	adc	r25, r25
     51e:	0a 94       	dec	r0
     520:	e2 f7       	brpl	.-8      	; 0x51a <GPIO_setupPinDirection+0x88>
     522:	84 2b       	or	r24, r20
     524:	8c 93       	st	X, r24
     526:	98 c0       	rjmp	.+304    	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
     528:	aa e3       	ldi	r26, 0x3A	; 58
     52a:	b0 e0       	ldi	r27, 0x00	; 0
     52c:	ea e3       	ldi	r30, 0x3A	; 58
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	80 81       	ld	r24, Z
     532:	48 2f       	mov	r20, r24
     534:	8a 81       	ldd	r24, Y+2	; 0x02
     536:	28 2f       	mov	r18, r24
     538:	30 e0       	ldi	r19, 0x00	; 0
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	02 2e       	mov	r0, r18
     540:	02 c0       	rjmp	.+4      	; 0x546 <GPIO_setupPinDirection+0xb4>
     542:	88 0f       	add	r24, r24
     544:	99 1f       	adc	r25, r25
     546:	0a 94       	dec	r0
     548:	e2 f7       	brpl	.-8      	; 0x542 <GPIO_setupPinDirection+0xb0>
     54a:	80 95       	com	r24
     54c:	84 23       	and	r24, r20
     54e:	8c 93       	st	X, r24
     550:	83 c0       	rjmp	.+262    	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
     552:	8b 81       	ldd	r24, Y+3	; 0x03
     554:	81 30       	cpi	r24, 0x01	; 1
     556:	a1 f4       	brne	.+40     	; 0x580 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
     558:	a7 e3       	ldi	r26, 0x37	; 55
     55a:	b0 e0       	ldi	r27, 0x00	; 0
     55c:	e7 e3       	ldi	r30, 0x37	; 55
     55e:	f0 e0       	ldi	r31, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	48 2f       	mov	r20, r24
     564:	8a 81       	ldd	r24, Y+2	; 0x02
     566:	28 2f       	mov	r18, r24
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	81 e0       	ldi	r24, 0x01	; 1
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	02 2e       	mov	r0, r18
     570:	02 c0       	rjmp	.+4      	; 0x576 <GPIO_setupPinDirection+0xe4>
     572:	88 0f       	add	r24, r24
     574:	99 1f       	adc	r25, r25
     576:	0a 94       	dec	r0
     578:	e2 f7       	brpl	.-8      	; 0x572 <GPIO_setupPinDirection+0xe0>
     57a:	84 2b       	or	r24, r20
     57c:	8c 93       	st	X, r24
     57e:	6c c0       	rjmp	.+216    	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
     580:	a7 e3       	ldi	r26, 0x37	; 55
     582:	b0 e0       	ldi	r27, 0x00	; 0
     584:	e7 e3       	ldi	r30, 0x37	; 55
     586:	f0 e0       	ldi	r31, 0x00	; 0
     588:	80 81       	ld	r24, Z
     58a:	48 2f       	mov	r20, r24
     58c:	8a 81       	ldd	r24, Y+2	; 0x02
     58e:	28 2f       	mov	r18, r24
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	02 2e       	mov	r0, r18
     598:	02 c0       	rjmp	.+4      	; 0x59e <GPIO_setupPinDirection+0x10c>
     59a:	88 0f       	add	r24, r24
     59c:	99 1f       	adc	r25, r25
     59e:	0a 94       	dec	r0
     5a0:	e2 f7       	brpl	.-8      	; 0x59a <GPIO_setupPinDirection+0x108>
     5a2:	80 95       	com	r24
     5a4:	84 23       	and	r24, r20
     5a6:	8c 93       	st	X, r24
     5a8:	57 c0       	rjmp	.+174    	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
     5aa:	8b 81       	ldd	r24, Y+3	; 0x03
     5ac:	81 30       	cpi	r24, 0x01	; 1
     5ae:	a1 f4       	brne	.+40     	; 0x5d8 <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
     5b0:	a4 e3       	ldi	r26, 0x34	; 52
     5b2:	b0 e0       	ldi	r27, 0x00	; 0
     5b4:	e4 e3       	ldi	r30, 0x34	; 52
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
     5b8:	80 81       	ld	r24, Z
     5ba:	48 2f       	mov	r20, r24
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	28 2f       	mov	r18, r24
     5c0:	30 e0       	ldi	r19, 0x00	; 0
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	02 2e       	mov	r0, r18
     5c8:	02 c0       	rjmp	.+4      	; 0x5ce <GPIO_setupPinDirection+0x13c>
     5ca:	88 0f       	add	r24, r24
     5cc:	99 1f       	adc	r25, r25
     5ce:	0a 94       	dec	r0
     5d0:	e2 f7       	brpl	.-8      	; 0x5ca <GPIO_setupPinDirection+0x138>
     5d2:	84 2b       	or	r24, r20
     5d4:	8c 93       	st	X, r24
     5d6:	40 c0       	rjmp	.+128    	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
     5d8:	a4 e3       	ldi	r26, 0x34	; 52
     5da:	b0 e0       	ldi	r27, 0x00	; 0
     5dc:	e4 e3       	ldi	r30, 0x34	; 52
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	80 81       	ld	r24, Z
     5e2:	48 2f       	mov	r20, r24
     5e4:	8a 81       	ldd	r24, Y+2	; 0x02
     5e6:	28 2f       	mov	r18, r24
     5e8:	30 e0       	ldi	r19, 0x00	; 0
     5ea:	81 e0       	ldi	r24, 0x01	; 1
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	02 2e       	mov	r0, r18
     5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <GPIO_setupPinDirection+0x164>
     5f2:	88 0f       	add	r24, r24
     5f4:	99 1f       	adc	r25, r25
     5f6:	0a 94       	dec	r0
     5f8:	e2 f7       	brpl	.-8      	; 0x5f2 <GPIO_setupPinDirection+0x160>
     5fa:	80 95       	com	r24
     5fc:	84 23       	and	r24, r20
     5fe:	8c 93       	st	X, r24
     600:	2b c0       	rjmp	.+86     	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
     602:	8b 81       	ldd	r24, Y+3	; 0x03
     604:	81 30       	cpi	r24, 0x01	; 1
     606:	a1 f4       	brne	.+40     	; 0x630 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
     608:	a1 e3       	ldi	r26, 0x31	; 49
     60a:	b0 e0       	ldi	r27, 0x00	; 0
     60c:	e1 e3       	ldi	r30, 0x31	; 49
     60e:	f0 e0       	ldi	r31, 0x00	; 0
     610:	80 81       	ld	r24, Z
     612:	48 2f       	mov	r20, r24
     614:	8a 81       	ldd	r24, Y+2	; 0x02
     616:	28 2f       	mov	r18, r24
     618:	30 e0       	ldi	r19, 0x00	; 0
     61a:	81 e0       	ldi	r24, 0x01	; 1
     61c:	90 e0       	ldi	r25, 0x00	; 0
     61e:	02 2e       	mov	r0, r18
     620:	02 c0       	rjmp	.+4      	; 0x626 <GPIO_setupPinDirection+0x194>
     622:	88 0f       	add	r24, r24
     624:	99 1f       	adc	r25, r25
     626:	0a 94       	dec	r0
     628:	e2 f7       	brpl	.-8      	; 0x622 <GPIO_setupPinDirection+0x190>
     62a:	84 2b       	or	r24, r20
     62c:	8c 93       	st	X, r24
     62e:	14 c0       	rjmp	.+40     	; 0x658 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
     630:	a1 e3       	ldi	r26, 0x31	; 49
     632:	b0 e0       	ldi	r27, 0x00	; 0
     634:	e1 e3       	ldi	r30, 0x31	; 49
     636:	f0 e0       	ldi	r31, 0x00	; 0
     638:	80 81       	ld	r24, Z
     63a:	48 2f       	mov	r20, r24
     63c:	8a 81       	ldd	r24, Y+2	; 0x02
     63e:	28 2f       	mov	r18, r24
     640:	30 e0       	ldi	r19, 0x00	; 0
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	02 2e       	mov	r0, r18
     648:	02 c0       	rjmp	.+4      	; 0x64e <GPIO_setupPinDirection+0x1bc>
     64a:	88 0f       	add	r24, r24
     64c:	99 1f       	adc	r25, r25
     64e:	0a 94       	dec	r0
     650:	e2 f7       	brpl	.-8      	; 0x64a <GPIO_setupPinDirection+0x1b8>
     652:	80 95       	com	r24
     654:	84 23       	and	r24, r20
     656:	8c 93       	st	X, r24
			break;
		default:
		    break;
		}
	}
}
     658:	0f 90       	pop	r0
     65a:	0f 90       	pop	r0
     65c:	0f 90       	pop	r0
     65e:	0f 90       	pop	r0
     660:	0f 90       	pop	r0
     662:	cf 91       	pop	r28
     664:	df 91       	pop	r29
     666:	08 95       	ret

00000668 <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
     668:	df 93       	push	r29
     66a:	cf 93       	push	r28
     66c:	00 d0       	rcall	.+0      	; 0x66e <GPIO_writePin+0x6>
     66e:	00 d0       	rcall	.+0      	; 0x670 <GPIO_writePin+0x8>
     670:	0f 92       	push	r0
     672:	cd b7       	in	r28, 0x3d	; 61
     674:	de b7       	in	r29, 0x3e	; 62
     676:	89 83       	std	Y+1, r24	; 0x01
     678:	6a 83       	std	Y+2, r22	; 0x02
     67a:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
     67c:	8a 81       	ldd	r24, Y+2	; 0x02
     67e:	88 30       	cpi	r24, 0x08	; 8
     680:	08 f0       	brcs	.+2      	; 0x684 <GPIO_writePin+0x1c>
     682:	d5 c0       	rjmp	.+426    	; 0x82e <GPIO_writePin+0x1c6>
     684:	89 81       	ldd	r24, Y+1	; 0x01
     686:	84 30       	cpi	r24, 0x04	; 4
     688:	08 f0       	brcs	.+2      	; 0x68c <GPIO_writePin+0x24>
     68a:	d1 c0       	rjmp	.+418    	; 0x82e <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
     68c:	89 81       	ldd	r24, Y+1	; 0x01
     68e:	28 2f       	mov	r18, r24
     690:	30 e0       	ldi	r19, 0x00	; 0
     692:	3d 83       	std	Y+5, r19	; 0x05
     694:	2c 83       	std	Y+4, r18	; 0x04
     696:	8c 81       	ldd	r24, Y+4	; 0x04
     698:	9d 81       	ldd	r25, Y+5	; 0x05
     69a:	81 30       	cpi	r24, 0x01	; 1
     69c:	91 05       	cpc	r25, r1
     69e:	09 f4       	brne	.+2      	; 0x6a2 <GPIO_writePin+0x3a>
     6a0:	43 c0       	rjmp	.+134    	; 0x728 <GPIO_writePin+0xc0>
     6a2:	2c 81       	ldd	r18, Y+4	; 0x04
     6a4:	3d 81       	ldd	r19, Y+5	; 0x05
     6a6:	22 30       	cpi	r18, 0x02	; 2
     6a8:	31 05       	cpc	r19, r1
     6aa:	2c f4       	brge	.+10     	; 0x6b6 <GPIO_writePin+0x4e>
     6ac:	8c 81       	ldd	r24, Y+4	; 0x04
     6ae:	9d 81       	ldd	r25, Y+5	; 0x05
     6b0:	00 97       	sbiw	r24, 0x00	; 0
     6b2:	71 f0       	breq	.+28     	; 0x6d0 <GPIO_writePin+0x68>
     6b4:	bc c0       	rjmp	.+376    	; 0x82e <GPIO_writePin+0x1c6>
     6b6:	2c 81       	ldd	r18, Y+4	; 0x04
     6b8:	3d 81       	ldd	r19, Y+5	; 0x05
     6ba:	22 30       	cpi	r18, 0x02	; 2
     6bc:	31 05       	cpc	r19, r1
     6be:	09 f4       	brne	.+2      	; 0x6c2 <GPIO_writePin+0x5a>
     6c0:	5f c0       	rjmp	.+190    	; 0x780 <GPIO_writePin+0x118>
     6c2:	8c 81       	ldd	r24, Y+4	; 0x04
     6c4:	9d 81       	ldd	r25, Y+5	; 0x05
     6c6:	83 30       	cpi	r24, 0x03	; 3
     6c8:	91 05       	cpc	r25, r1
     6ca:	09 f4       	brne	.+2      	; 0x6ce <GPIO_writePin+0x66>
     6cc:	85 c0       	rjmp	.+266    	; 0x7d8 <GPIO_writePin+0x170>
     6ce:	af c0       	rjmp	.+350    	; 0x82e <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	81 30       	cpi	r24, 0x01	; 1
     6d4:	a1 f4       	brne	.+40     	; 0x6fe <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
     6d6:	ab e3       	ldi	r26, 0x3B	; 59
     6d8:	b0 e0       	ldi	r27, 0x00	; 0
     6da:	eb e3       	ldi	r30, 0x3B	; 59
     6dc:	f0 e0       	ldi	r31, 0x00	; 0
     6de:	80 81       	ld	r24, Z
     6e0:	48 2f       	mov	r20, r24
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	28 2f       	mov	r18, r24
     6e6:	30 e0       	ldi	r19, 0x00	; 0
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	90 e0       	ldi	r25, 0x00	; 0
     6ec:	02 2e       	mov	r0, r18
     6ee:	02 c0       	rjmp	.+4      	; 0x6f4 <GPIO_writePin+0x8c>
     6f0:	88 0f       	add	r24, r24
     6f2:	99 1f       	adc	r25, r25
     6f4:	0a 94       	dec	r0
     6f6:	e2 f7       	brpl	.-8      	; 0x6f0 <GPIO_writePin+0x88>
     6f8:	84 2b       	or	r24, r20
     6fa:	8c 93       	st	X, r24
     6fc:	98 c0       	rjmp	.+304    	; 0x82e <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
     6fe:	ab e3       	ldi	r26, 0x3B	; 59
     700:	b0 e0       	ldi	r27, 0x00	; 0
     702:	eb e3       	ldi	r30, 0x3B	; 59
     704:	f0 e0       	ldi	r31, 0x00	; 0
     706:	80 81       	ld	r24, Z
     708:	48 2f       	mov	r20, r24
     70a:	8a 81       	ldd	r24, Y+2	; 0x02
     70c:	28 2f       	mov	r18, r24
     70e:	30 e0       	ldi	r19, 0x00	; 0
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	02 2e       	mov	r0, r18
     716:	02 c0       	rjmp	.+4      	; 0x71c <GPIO_writePin+0xb4>
     718:	88 0f       	add	r24, r24
     71a:	99 1f       	adc	r25, r25
     71c:	0a 94       	dec	r0
     71e:	e2 f7       	brpl	.-8      	; 0x718 <GPIO_writePin+0xb0>
     720:	80 95       	com	r24
     722:	84 23       	and	r24, r20
     724:	8c 93       	st	X, r24
     726:	83 c0       	rjmp	.+262    	; 0x82e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
     728:	8b 81       	ldd	r24, Y+3	; 0x03
     72a:	81 30       	cpi	r24, 0x01	; 1
     72c:	a1 f4       	brne	.+40     	; 0x756 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
     72e:	a8 e3       	ldi	r26, 0x38	; 56
     730:	b0 e0       	ldi	r27, 0x00	; 0
     732:	e8 e3       	ldi	r30, 0x38	; 56
     734:	f0 e0       	ldi	r31, 0x00	; 0
     736:	80 81       	ld	r24, Z
     738:	48 2f       	mov	r20, r24
     73a:	8a 81       	ldd	r24, Y+2	; 0x02
     73c:	28 2f       	mov	r18, r24
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	02 2e       	mov	r0, r18
     746:	02 c0       	rjmp	.+4      	; 0x74c <GPIO_writePin+0xe4>
     748:	88 0f       	add	r24, r24
     74a:	99 1f       	adc	r25, r25
     74c:	0a 94       	dec	r0
     74e:	e2 f7       	brpl	.-8      	; 0x748 <GPIO_writePin+0xe0>
     750:	84 2b       	or	r24, r20
     752:	8c 93       	st	X, r24
     754:	6c c0       	rjmp	.+216    	; 0x82e <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
     756:	a8 e3       	ldi	r26, 0x38	; 56
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	e8 e3       	ldi	r30, 0x38	; 56
     75c:	f0 e0       	ldi	r31, 0x00	; 0
     75e:	80 81       	ld	r24, Z
     760:	48 2f       	mov	r20, r24
     762:	8a 81       	ldd	r24, Y+2	; 0x02
     764:	28 2f       	mov	r18, r24
     766:	30 e0       	ldi	r19, 0x00	; 0
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	90 e0       	ldi	r25, 0x00	; 0
     76c:	02 2e       	mov	r0, r18
     76e:	02 c0       	rjmp	.+4      	; 0x774 <GPIO_writePin+0x10c>
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	0a 94       	dec	r0
     776:	e2 f7       	brpl	.-8      	; 0x770 <GPIO_writePin+0x108>
     778:	80 95       	com	r24
     77a:	84 23       	and	r24, r20
     77c:	8c 93       	st	X, r24
     77e:	57 c0       	rjmp	.+174    	; 0x82e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
     780:	8b 81       	ldd	r24, Y+3	; 0x03
     782:	81 30       	cpi	r24, 0x01	; 1
     784:	a1 f4       	brne	.+40     	; 0x7ae <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
     786:	a5 e3       	ldi	r26, 0x35	; 53
     788:	b0 e0       	ldi	r27, 0x00	; 0
     78a:	e5 e3       	ldi	r30, 0x35	; 53
     78c:	f0 e0       	ldi	r31, 0x00	; 0
     78e:	80 81       	ld	r24, Z
     790:	48 2f       	mov	r20, r24
     792:	8a 81       	ldd	r24, Y+2	; 0x02
     794:	28 2f       	mov	r18, r24
     796:	30 e0       	ldi	r19, 0x00	; 0
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	02 2e       	mov	r0, r18
     79e:	02 c0       	rjmp	.+4      	; 0x7a4 <GPIO_writePin+0x13c>
     7a0:	88 0f       	add	r24, r24
     7a2:	99 1f       	adc	r25, r25
     7a4:	0a 94       	dec	r0
     7a6:	e2 f7       	brpl	.-8      	; 0x7a0 <GPIO_writePin+0x138>
     7a8:	84 2b       	or	r24, r20
     7aa:	8c 93       	st	X, r24
     7ac:	40 c0       	rjmp	.+128    	; 0x82e <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
     7ae:	a5 e3       	ldi	r26, 0x35	; 53
     7b0:	b0 e0       	ldi	r27, 0x00	; 0
     7b2:	e5 e3       	ldi	r30, 0x35	; 53
     7b4:	f0 e0       	ldi	r31, 0x00	; 0
     7b6:	80 81       	ld	r24, Z
     7b8:	48 2f       	mov	r20, r24
     7ba:	8a 81       	ldd	r24, Y+2	; 0x02
     7bc:	28 2f       	mov	r18, r24
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	02 2e       	mov	r0, r18
     7c6:	02 c0       	rjmp	.+4      	; 0x7cc <GPIO_writePin+0x164>
     7c8:	88 0f       	add	r24, r24
     7ca:	99 1f       	adc	r25, r25
     7cc:	0a 94       	dec	r0
     7ce:	e2 f7       	brpl	.-8      	; 0x7c8 <GPIO_writePin+0x160>
     7d0:	80 95       	com	r24
     7d2:	84 23       	and	r24, r20
     7d4:	8c 93       	st	X, r24
     7d6:	2b c0       	rjmp	.+86     	; 0x82e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
     7d8:	8b 81       	ldd	r24, Y+3	; 0x03
     7da:	81 30       	cpi	r24, 0x01	; 1
     7dc:	a1 f4       	brne	.+40     	; 0x806 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
     7de:	a2 e3       	ldi	r26, 0x32	; 50
     7e0:	b0 e0       	ldi	r27, 0x00	; 0
     7e2:	e2 e3       	ldi	r30, 0x32	; 50
     7e4:	f0 e0       	ldi	r31, 0x00	; 0
     7e6:	80 81       	ld	r24, Z
     7e8:	48 2f       	mov	r20, r24
     7ea:	8a 81       	ldd	r24, Y+2	; 0x02
     7ec:	28 2f       	mov	r18, r24
     7ee:	30 e0       	ldi	r19, 0x00	; 0
     7f0:	81 e0       	ldi	r24, 0x01	; 1
     7f2:	90 e0       	ldi	r25, 0x00	; 0
     7f4:	02 2e       	mov	r0, r18
     7f6:	02 c0       	rjmp	.+4      	; 0x7fc <GPIO_writePin+0x194>
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	0a 94       	dec	r0
     7fe:	e2 f7       	brpl	.-8      	; 0x7f8 <GPIO_writePin+0x190>
     800:	84 2b       	or	r24, r20
     802:	8c 93       	st	X, r24
     804:	14 c0       	rjmp	.+40     	; 0x82e <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
     806:	a2 e3       	ldi	r26, 0x32	; 50
     808:	b0 e0       	ldi	r27, 0x00	; 0
     80a:	e2 e3       	ldi	r30, 0x32	; 50
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	48 2f       	mov	r20, r24
     812:	8a 81       	ldd	r24, Y+2	; 0x02
     814:	28 2f       	mov	r18, r24
     816:	30 e0       	ldi	r19, 0x00	; 0
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	02 2e       	mov	r0, r18
     81e:	02 c0       	rjmp	.+4      	; 0x824 <GPIO_writePin+0x1bc>
     820:	88 0f       	add	r24, r24
     822:	99 1f       	adc	r25, r25
     824:	0a 94       	dec	r0
     826:	e2 f7       	brpl	.-8      	; 0x820 <GPIO_writePin+0x1b8>
     828:	80 95       	com	r24
     82a:	84 23       	and	r24, r20
     82c:	8c 93       	st	X, r24
			break;
		default:
		            break;
		}
	}
}
     82e:	0f 90       	pop	r0
     830:	0f 90       	pop	r0
     832:	0f 90       	pop	r0
     834:	0f 90       	pop	r0
     836:	0f 90       	pop	r0
     838:	cf 91       	pop	r28
     83a:	df 91       	pop	r29
     83c:	08 95       	ret

0000083e <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
     83e:	df 93       	push	r29
     840:	cf 93       	push	r28
     842:	00 d0       	rcall	.+0      	; 0x844 <GPIO_readPin+0x6>
     844:	00 d0       	rcall	.+0      	; 0x846 <GPIO_readPin+0x8>
     846:	0f 92       	push	r0
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
     84c:	8a 83       	std	Y+2, r24	; 0x02
     84e:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
     850:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
     852:	8b 81       	ldd	r24, Y+3	; 0x03
     854:	88 30       	cpi	r24, 0x08	; 8
     856:	08 f0       	brcs	.+2      	; 0x85a <GPIO_readPin+0x1c>
     858:	84 c0       	rjmp	.+264    	; 0x962 <__stack+0x103>
     85a:	8a 81       	ldd	r24, Y+2	; 0x02
     85c:	84 30       	cpi	r24, 0x04	; 4
     85e:	08 f0       	brcs	.+2      	; 0x862 <__stack+0x3>
     860:	80 c0       	rjmp	.+256    	; 0x962 <__stack+0x103>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
     862:	8a 81       	ldd	r24, Y+2	; 0x02
     864:	28 2f       	mov	r18, r24
     866:	30 e0       	ldi	r19, 0x00	; 0
     868:	3d 83       	std	Y+5, r19	; 0x05
     86a:	2c 83       	std	Y+4, r18	; 0x04
     86c:	4c 81       	ldd	r20, Y+4	; 0x04
     86e:	5d 81       	ldd	r21, Y+5	; 0x05
     870:	41 30       	cpi	r20, 0x01	; 1
     872:	51 05       	cpc	r21, r1
     874:	79 f1       	breq	.+94     	; 0x8d4 <__stack+0x75>
     876:	8c 81       	ldd	r24, Y+4	; 0x04
     878:	9d 81       	ldd	r25, Y+5	; 0x05
     87a:	82 30       	cpi	r24, 0x02	; 2
     87c:	91 05       	cpc	r25, r1
     87e:	34 f4       	brge	.+12     	; 0x88c <__stack+0x2d>
     880:	2c 81       	ldd	r18, Y+4	; 0x04
     882:	3d 81       	ldd	r19, Y+5	; 0x05
     884:	21 15       	cp	r18, r1
     886:	31 05       	cpc	r19, r1
     888:	69 f0       	breq	.+26     	; 0x8a4 <__stack+0x45>
     88a:	6b c0       	rjmp	.+214    	; 0x962 <__stack+0x103>
     88c:	4c 81       	ldd	r20, Y+4	; 0x04
     88e:	5d 81       	ldd	r21, Y+5	; 0x05
     890:	42 30       	cpi	r20, 0x02	; 2
     892:	51 05       	cpc	r21, r1
     894:	b9 f1       	breq	.+110    	; 0x904 <__stack+0xa5>
     896:	8c 81       	ldd	r24, Y+4	; 0x04
     898:	9d 81       	ldd	r25, Y+5	; 0x05
     89a:	83 30       	cpi	r24, 0x03	; 3
     89c:	91 05       	cpc	r25, r1
     89e:	09 f4       	brne	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	49 c0       	rjmp	.+146    	; 0x934 <__stack+0xd5>
     8a2:	5f c0       	rjmp	.+190    	; 0x962 <__stack+0x103>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
     8a4:	e9 e3       	ldi	r30, 0x39	; 57
     8a6:	f0 e0       	ldi	r31, 0x00	; 0
     8a8:	80 81       	ld	r24, Z
     8aa:	28 2f       	mov	r18, r24
     8ac:	30 e0       	ldi	r19, 0x00	; 0
     8ae:	8b 81       	ldd	r24, Y+3	; 0x03
     8b0:	88 2f       	mov	r24, r24
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a9 01       	movw	r20, r18
     8b6:	02 c0       	rjmp	.+4      	; 0x8bc <__stack+0x5d>
     8b8:	55 95       	asr	r21
     8ba:	47 95       	ror	r20
     8bc:	8a 95       	dec	r24
     8be:	e2 f7       	brpl	.-8      	; 0x8b8 <__stack+0x59>
     8c0:	ca 01       	movw	r24, r20
     8c2:	81 70       	andi	r24, 0x01	; 1
     8c4:	90 70       	andi	r25, 0x00	; 0
     8c6:	88 23       	and	r24, r24
     8c8:	19 f0       	breq	.+6      	; 0x8d0 <__stack+0x71>
			{
				pin_value = LOGIC_HIGH;
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	89 83       	std	Y+1, r24	; 0x01
     8ce:	49 c0       	rjmp	.+146    	; 0x962 <__stack+0x103>
			}
			else
			{
				pin_value = LOGIC_LOW;
     8d0:	19 82       	std	Y+1, r1	; 0x01
     8d2:	47 c0       	rjmp	.+142    	; 0x962 <__stack+0x103>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
     8d4:	e6 e3       	ldi	r30, 0x36	; 54
     8d6:	f0 e0       	ldi	r31, 0x00	; 0
     8d8:	80 81       	ld	r24, Z
     8da:	28 2f       	mov	r18, r24
     8dc:	30 e0       	ldi	r19, 0x00	; 0
     8de:	8b 81       	ldd	r24, Y+3	; 0x03
     8e0:	88 2f       	mov	r24, r24
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	a9 01       	movw	r20, r18
     8e6:	02 c0       	rjmp	.+4      	; 0x8ec <__stack+0x8d>
     8e8:	55 95       	asr	r21
     8ea:	47 95       	ror	r20
     8ec:	8a 95       	dec	r24
     8ee:	e2 f7       	brpl	.-8      	; 0x8e8 <__stack+0x89>
     8f0:	ca 01       	movw	r24, r20
     8f2:	81 70       	andi	r24, 0x01	; 1
     8f4:	90 70       	andi	r25, 0x00	; 0
     8f6:	88 23       	and	r24, r24
     8f8:	19 f0       	breq	.+6      	; 0x900 <__stack+0xa1>
			{
				pin_value = LOGIC_HIGH;
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	89 83       	std	Y+1, r24	; 0x01
     8fe:	31 c0       	rjmp	.+98     	; 0x962 <__stack+0x103>
			}
			else
			{
				pin_value = LOGIC_LOW;
     900:	19 82       	std	Y+1, r1	; 0x01
     902:	2f c0       	rjmp	.+94     	; 0x962 <__stack+0x103>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
     904:	e3 e3       	ldi	r30, 0x33	; 51
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	80 81       	ld	r24, Z
     90a:	28 2f       	mov	r18, r24
     90c:	30 e0       	ldi	r19, 0x00	; 0
     90e:	8b 81       	ldd	r24, Y+3	; 0x03
     910:	88 2f       	mov	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	a9 01       	movw	r20, r18
     916:	02 c0       	rjmp	.+4      	; 0x91c <__stack+0xbd>
     918:	55 95       	asr	r21
     91a:	47 95       	ror	r20
     91c:	8a 95       	dec	r24
     91e:	e2 f7       	brpl	.-8      	; 0x918 <__stack+0xb9>
     920:	ca 01       	movw	r24, r20
     922:	81 70       	andi	r24, 0x01	; 1
     924:	90 70       	andi	r25, 0x00	; 0
     926:	88 23       	and	r24, r24
     928:	19 f0       	breq	.+6      	; 0x930 <__stack+0xd1>
			{
				pin_value = LOGIC_HIGH;
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	89 83       	std	Y+1, r24	; 0x01
     92e:	19 c0       	rjmp	.+50     	; 0x962 <__stack+0x103>
			}
			else
			{
				pin_value = LOGIC_LOW;
     930:	19 82       	std	Y+1, r1	; 0x01
     932:	17 c0       	rjmp	.+46     	; 0x962 <__stack+0x103>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
     934:	e0 e3       	ldi	r30, 0x30	; 48
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	80 81       	ld	r24, Z
     93a:	28 2f       	mov	r18, r24
     93c:	30 e0       	ldi	r19, 0x00	; 0
     93e:	8b 81       	ldd	r24, Y+3	; 0x03
     940:	88 2f       	mov	r24, r24
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	a9 01       	movw	r20, r18
     946:	02 c0       	rjmp	.+4      	; 0x94c <__stack+0xed>
     948:	55 95       	asr	r21
     94a:	47 95       	ror	r20
     94c:	8a 95       	dec	r24
     94e:	e2 f7       	brpl	.-8      	; 0x948 <__stack+0xe9>
     950:	ca 01       	movw	r24, r20
     952:	81 70       	andi	r24, 0x01	; 1
     954:	90 70       	andi	r25, 0x00	; 0
     956:	88 23       	and	r24, r24
     958:	19 f0       	breq	.+6      	; 0x960 <__stack+0x101>
			{
				pin_value = LOGIC_HIGH;
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	89 83       	std	Y+1, r24	; 0x01
     95e:	01 c0       	rjmp	.+2      	; 0x962 <__stack+0x103>
			}
			else
			{
				pin_value = LOGIC_LOW;
     960:	19 82       	std	Y+1, r1	; 0x01
		default:
		            break;
		}
	}

	return pin_value;
     962:	89 81       	ldd	r24, Y+1	; 0x01
}
     964:	0f 90       	pop	r0
     966:	0f 90       	pop	r0
     968:	0f 90       	pop	r0
     96a:	0f 90       	pop	r0
     96c:	0f 90       	pop	r0
     96e:	cf 91       	pop	r28
     970:	df 91       	pop	r29
     972:	08 95       	ret

00000974 <GPIO_togglePin>:
 * Description :
 * Read and return the value for the required pin, then toggle the value of the pin
.
 */
void GPIO_togglePin(uint8 port_num, uint8 pin_num)
{
     974:	df 93       	push	r29
     976:	cf 93       	push	r28
     978:	00 d0       	rcall	.+0      	; 0x97a <GPIO_togglePin+0x6>
     97a:	0f 92       	push	r0
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	8a 83       	std	Y+2, r24	; 0x02
     982:	6b 83       	std	Y+3, r22	; 0x03
	uint8 read_value = GPIO_readPin(port_num, pin_num);
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	6b 81       	ldd	r22, Y+3	; 0x03
     988:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     98c:	89 83       	std	Y+1, r24	; 0x01

	if(read_value == LOGIC_HIGH)
     98e:	89 81       	ldd	r24, Y+1	; 0x01
     990:	81 30       	cpi	r24, 0x01	; 1
     992:	31 f4       	brne	.+12     	; 0x9a0 <GPIO_togglePin+0x2c>
	{
		GPIO_writePin(port_num, pin_num,LOGIC_LOW);
     994:	8a 81       	ldd	r24, Y+2	; 0x02
     996:	6b 81       	ldd	r22, Y+3	; 0x03
     998:	40 e0       	ldi	r20, 0x00	; 0
     99a:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
     99e:	05 c0       	rjmp	.+10     	; 0x9aa <GPIO_togglePin+0x36>
	}
	else
	{
		GPIO_writePin(port_num, pin_num,LOGIC_HIGH);
     9a0:	8a 81       	ldd	r24, Y+2	; 0x02
     9a2:	6b 81       	ldd	r22, Y+3	; 0x03
     9a4:	41 e0       	ldi	r20, 0x01	; 1
     9a6:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
	}
}
     9aa:	0f 90       	pop	r0
     9ac:	0f 90       	pop	r0
     9ae:	0f 90       	pop	r0
     9b0:	cf 91       	pop	r28
     9b2:	df 91       	pop	r29
     9b4:	08 95       	ret

000009b6 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
     9b6:	df 93       	push	r29
     9b8:	cf 93       	push	r28
     9ba:	00 d0       	rcall	.+0      	; 0x9bc <GPIO_setupPortDirection+0x6>
     9bc:	00 d0       	rcall	.+0      	; 0x9be <GPIO_setupPortDirection+0x8>
     9be:	cd b7       	in	r28, 0x3d	; 61
     9c0:	de b7       	in	r29, 0x3e	; 62
     9c2:	89 83       	std	Y+1, r24	; 0x01
     9c4:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
     9c6:	89 81       	ldd	r24, Y+1	; 0x01
     9c8:	84 30       	cpi	r24, 0x04	; 4
     9ca:	90 f5       	brcc	.+100    	; 0xa30 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
     9cc:	89 81       	ldd	r24, Y+1	; 0x01
     9ce:	28 2f       	mov	r18, r24
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	3c 83       	std	Y+4, r19	; 0x04
     9d4:	2b 83       	std	Y+3, r18	; 0x03
     9d6:	8b 81       	ldd	r24, Y+3	; 0x03
     9d8:	9c 81       	ldd	r25, Y+4	; 0x04
     9da:	81 30       	cpi	r24, 0x01	; 1
     9dc:	91 05       	cpc	r25, r1
     9de:	d1 f0       	breq	.+52     	; 0xa14 <GPIO_setupPortDirection+0x5e>
     9e0:	2b 81       	ldd	r18, Y+3	; 0x03
     9e2:	3c 81       	ldd	r19, Y+4	; 0x04
     9e4:	22 30       	cpi	r18, 0x02	; 2
     9e6:	31 05       	cpc	r19, r1
     9e8:	2c f4       	brge	.+10     	; 0x9f4 <GPIO_setupPortDirection+0x3e>
     9ea:	8b 81       	ldd	r24, Y+3	; 0x03
     9ec:	9c 81       	ldd	r25, Y+4	; 0x04
     9ee:	00 97       	sbiw	r24, 0x00	; 0
     9f0:	61 f0       	breq	.+24     	; 0xa0a <GPIO_setupPortDirection+0x54>
     9f2:	1e c0       	rjmp	.+60     	; 0xa30 <GPIO_setupPortDirection+0x7a>
     9f4:	2b 81       	ldd	r18, Y+3	; 0x03
     9f6:	3c 81       	ldd	r19, Y+4	; 0x04
     9f8:	22 30       	cpi	r18, 0x02	; 2
     9fa:	31 05       	cpc	r19, r1
     9fc:	81 f0       	breq	.+32     	; 0xa1e <GPIO_setupPortDirection+0x68>
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	9c 81       	ldd	r25, Y+4	; 0x04
     a02:	83 30       	cpi	r24, 0x03	; 3
     a04:	91 05       	cpc	r25, r1
     a06:	81 f0       	breq	.+32     	; 0xa28 <GPIO_setupPortDirection+0x72>
     a08:	13 c0       	rjmp	.+38     	; 0xa30 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
     a0a:	ea e3       	ldi	r30, 0x3A	; 58
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	8a 81       	ldd	r24, Y+2	; 0x02
     a10:	80 83       	st	Z, r24
     a12:	0e c0       	rjmp	.+28     	; 0xa30 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
     a14:	e7 e3       	ldi	r30, 0x37	; 55
     a16:	f0 e0       	ldi	r31, 0x00	; 0
     a18:	8a 81       	ldd	r24, Y+2	; 0x02
     a1a:	80 83       	st	Z, r24
     a1c:	09 c0       	rjmp	.+18     	; 0xa30 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
     a1e:	e4 e3       	ldi	r30, 0x34	; 52
     a20:	f0 e0       	ldi	r31, 0x00	; 0
     a22:	8a 81       	ldd	r24, Y+2	; 0x02
     a24:	80 83       	st	Z, r24
     a26:	04 c0       	rjmp	.+8      	; 0xa30 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
     a28:	e1 e3       	ldi	r30, 0x31	; 49
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	8a 81       	ldd	r24, Y+2	; 0x02
     a2e:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	cf 91       	pop	r28
     a3a:	df 91       	pop	r29
     a3c:	08 95       	ret

00000a3e <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
     a3e:	df 93       	push	r29
     a40:	cf 93       	push	r28
     a42:	00 d0       	rcall	.+0      	; 0xa44 <GPIO_writePort+0x6>
     a44:	00 d0       	rcall	.+0      	; 0xa46 <GPIO_writePort+0x8>
     a46:	cd b7       	in	r28, 0x3d	; 61
     a48:	de b7       	in	r29, 0x3e	; 62
     a4a:	89 83       	std	Y+1, r24	; 0x01
     a4c:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
     a4e:	89 81       	ldd	r24, Y+1	; 0x01
     a50:	84 30       	cpi	r24, 0x04	; 4
     a52:	90 f5       	brcc	.+100    	; 0xab8 <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
     a54:	89 81       	ldd	r24, Y+1	; 0x01
     a56:	28 2f       	mov	r18, r24
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	3c 83       	std	Y+4, r19	; 0x04
     a5c:	2b 83       	std	Y+3, r18	; 0x03
     a5e:	8b 81       	ldd	r24, Y+3	; 0x03
     a60:	9c 81       	ldd	r25, Y+4	; 0x04
     a62:	81 30       	cpi	r24, 0x01	; 1
     a64:	91 05       	cpc	r25, r1
     a66:	d1 f0       	breq	.+52     	; 0xa9c <GPIO_writePort+0x5e>
     a68:	2b 81       	ldd	r18, Y+3	; 0x03
     a6a:	3c 81       	ldd	r19, Y+4	; 0x04
     a6c:	22 30       	cpi	r18, 0x02	; 2
     a6e:	31 05       	cpc	r19, r1
     a70:	2c f4       	brge	.+10     	; 0xa7c <GPIO_writePort+0x3e>
     a72:	8b 81       	ldd	r24, Y+3	; 0x03
     a74:	9c 81       	ldd	r25, Y+4	; 0x04
     a76:	00 97       	sbiw	r24, 0x00	; 0
     a78:	61 f0       	breq	.+24     	; 0xa92 <GPIO_writePort+0x54>
     a7a:	1e c0       	rjmp	.+60     	; 0xab8 <GPIO_writePort+0x7a>
     a7c:	2b 81       	ldd	r18, Y+3	; 0x03
     a7e:	3c 81       	ldd	r19, Y+4	; 0x04
     a80:	22 30       	cpi	r18, 0x02	; 2
     a82:	31 05       	cpc	r19, r1
     a84:	81 f0       	breq	.+32     	; 0xaa6 <GPIO_writePort+0x68>
     a86:	8b 81       	ldd	r24, Y+3	; 0x03
     a88:	9c 81       	ldd	r25, Y+4	; 0x04
     a8a:	83 30       	cpi	r24, 0x03	; 3
     a8c:	91 05       	cpc	r25, r1
     a8e:	81 f0       	breq	.+32     	; 0xab0 <GPIO_writePort+0x72>
     a90:	13 c0       	rjmp	.+38     	; 0xab8 <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
     a92:	eb e3       	ldi	r30, 0x3B	; 59
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	8a 81       	ldd	r24, Y+2	; 0x02
     a98:	80 83       	st	Z, r24
     a9a:	0e c0       	rjmp	.+28     	; 0xab8 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
     a9c:	e8 e3       	ldi	r30, 0x38	; 56
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
     aa0:	8a 81       	ldd	r24, Y+2	; 0x02
     aa2:	80 83       	st	Z, r24
     aa4:	09 c0       	rjmp	.+18     	; 0xab8 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
     aa6:	e5 e3       	ldi	r30, 0x35	; 53
     aa8:	f0 e0       	ldi	r31, 0x00	; 0
     aaa:	8a 81       	ldd	r24, Y+2	; 0x02
     aac:	80 83       	st	Z, r24
     aae:	04 c0       	rjmp	.+8      	; 0xab8 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
     ab0:	e2 e3       	ldi	r30, 0x32	; 50
     ab2:	f0 e0       	ldi	r31, 0x00	; 0
     ab4:	8a 81       	ldd	r24, Y+2	; 0x02
     ab6:	80 83       	st	Z, r24
			break;
		default:
		            break;
		}
	}
}
     ab8:	0f 90       	pop	r0
     aba:	0f 90       	pop	r0
     abc:	0f 90       	pop	r0
     abe:	0f 90       	pop	r0
     ac0:	cf 91       	pop	r28
     ac2:	df 91       	pop	r29
     ac4:	08 95       	ret

00000ac6 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
     ac6:	df 93       	push	r29
     ac8:	cf 93       	push	r28
     aca:	00 d0       	rcall	.+0      	; 0xacc <GPIO_readPort+0x6>
     acc:	00 d0       	rcall	.+0      	; 0xace <GPIO_readPort+0x8>
     ace:	cd b7       	in	r28, 0x3d	; 61
     ad0:	de b7       	in	r29, 0x3e	; 62
     ad2:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
     ad4:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
     ad6:	8a 81       	ldd	r24, Y+2	; 0x02
     ad8:	84 30       	cpi	r24, 0x04	; 4
     ada:	90 f5       	brcc	.+100    	; 0xb40 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
     adc:	8a 81       	ldd	r24, Y+2	; 0x02
     ade:	28 2f       	mov	r18, r24
     ae0:	30 e0       	ldi	r19, 0x00	; 0
     ae2:	3c 83       	std	Y+4, r19	; 0x04
     ae4:	2b 83       	std	Y+3, r18	; 0x03
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	81 30       	cpi	r24, 0x01	; 1
     aec:	91 05       	cpc	r25, r1
     aee:	d1 f0       	breq	.+52     	; 0xb24 <GPIO_readPort+0x5e>
     af0:	2b 81       	ldd	r18, Y+3	; 0x03
     af2:	3c 81       	ldd	r19, Y+4	; 0x04
     af4:	22 30       	cpi	r18, 0x02	; 2
     af6:	31 05       	cpc	r19, r1
     af8:	2c f4       	brge	.+10     	; 0xb04 <GPIO_readPort+0x3e>
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	00 97       	sbiw	r24, 0x00	; 0
     b00:	61 f0       	breq	.+24     	; 0xb1a <GPIO_readPort+0x54>
     b02:	1e c0       	rjmp	.+60     	; 0xb40 <GPIO_readPort+0x7a>
     b04:	2b 81       	ldd	r18, Y+3	; 0x03
     b06:	3c 81       	ldd	r19, Y+4	; 0x04
     b08:	22 30       	cpi	r18, 0x02	; 2
     b0a:	31 05       	cpc	r19, r1
     b0c:	81 f0       	breq	.+32     	; 0xb2e <GPIO_readPort+0x68>
     b0e:	8b 81       	ldd	r24, Y+3	; 0x03
     b10:	9c 81       	ldd	r25, Y+4	; 0x04
     b12:	83 30       	cpi	r24, 0x03	; 3
     b14:	91 05       	cpc	r25, r1
     b16:	81 f0       	breq	.+32     	; 0xb38 <GPIO_readPort+0x72>
     b18:	13 c0       	rjmp	.+38     	; 0xb40 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
     b1a:	e9 e3       	ldi	r30, 0x39	; 57
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	80 81       	ld	r24, Z
     b20:	89 83       	std	Y+1, r24	; 0x01
     b22:	0e c0       	rjmp	.+28     	; 0xb40 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
     b24:	e6 e3       	ldi	r30, 0x36	; 54
     b26:	f0 e0       	ldi	r31, 0x00	; 0
     b28:	80 81       	ld	r24, Z
     b2a:	89 83       	std	Y+1, r24	; 0x01
     b2c:	09 c0       	rjmp	.+18     	; 0xb40 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
     b2e:	e3 e3       	ldi	r30, 0x33	; 51
     b30:	f0 e0       	ldi	r31, 0x00	; 0
     b32:	80 81       	ld	r24, Z
     b34:	89 83       	std	Y+1, r24	; 0x01
     b36:	04 c0       	rjmp	.+8      	; 0xb40 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
     b38:	e0 e3       	ldi	r30, 0x30	; 48
     b3a:	f0 e0       	ldi	r31, 0x00	; 0
     b3c:	80 81       	ld	r24, Z
     b3e:	89 83       	std	Y+1, r24	; 0x01
		default:
		            break;
		}
	}

	return value;
     b40:	89 81       	ldd	r24, Y+1	; 0x01
}
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	0f 90       	pop	r0
     b4a:	cf 91       	pop	r28
     b4c:	df 91       	pop	r29
     b4e:	08 95       	ret

00000b50 <GLOBAL_INTERRUPT_ENABLE>:
#include "EXT_INTTERUPT.h"
#include "avr/io.h"


void GLOBAL_INTERRUPT_ENABLE(void)
{
     b50:	df 93       	push	r29
     b52:	cf 93       	push	r28
     b54:	cd b7       	in	r28, 0x3d	; 61
     b56:	de b7       	in	r29, 0x3e	; 62
	sei();
     b58:	78 94       	sei
}
     b5a:	cf 91       	pop	r28
     b5c:	df 91       	pop	r29
     b5e:	08 95       	ret

00000b60 <GLOBAL_INTERRUPT_DISABLE>:

void GLOBAL_INTERRUPT_DISABLE(void)
{
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	cd b7       	in	r28, 0x3d	; 61
     b66:	de b7       	in	r29, 0x3e	; 62
	cli();
     b68:	f8 94       	cli
}
     b6a:	cf 91       	pop	r28
     b6c:	df 91       	pop	r29
     b6e:	08 95       	ret

00000b70 <INT0_init>:

void INT0_init( EXT_triggerType triggerType)
{
     b70:	df 93       	push	r29
     b72:	cf 93       	push	r28
     b74:	0f 92       	push	r0
     b76:	cd b7       	in	r28, 0x3d	; 61
     b78:	de b7       	in	r29, 0x3e	; 62
     b7a:	89 83       	std	Y+1, r24	; 0x01

	MCUCR = (MCUCR & 0xFC) | triggerType;/*set type of trigger*/
     b7c:	a5 e5       	ldi	r26, 0x55	; 85
     b7e:	b0 e0       	ldi	r27, 0x00	; 0
     b80:	e5 e5       	ldi	r30, 0x55	; 85
     b82:	f0 e0       	ldi	r31, 0x00	; 0
     b84:	80 81       	ld	r24, Z
     b86:	98 2f       	mov	r25, r24
     b88:	9c 7f       	andi	r25, 0xFC	; 252
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	89 2b       	or	r24, r25
     b8e:	8c 93       	st	X, r24
	SET_BIT(GICR ,6); /*enable INT0*/
     b90:	ab e5       	ldi	r26, 0x5B	; 91
     b92:	b0 e0       	ldi	r27, 0x00	; 0
     b94:	eb e5       	ldi	r30, 0x5B	; 91
     b96:	f0 e0       	ldi	r31, 0x00	; 0
     b98:	80 81       	ld	r24, Z
     b9a:	80 64       	ori	r24, 0x40	; 64
     b9c:	8c 93       	st	X, r24
}
     b9e:	0f 90       	pop	r0
     ba0:	cf 91       	pop	r28
     ba2:	df 91       	pop	r29
     ba4:	08 95       	ret

00000ba6 <INT0_deInit>:



void INT0_deInit(void)
{
     ba6:	df 93       	push	r29
     ba8:	cf 93       	push	r28
     baa:	cd b7       	in	r28, 0x3d	; 61
     bac:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(GICR ,6);
     bae:	ab e5       	ldi	r26, 0x5B	; 91
     bb0:	b0 e0       	ldi	r27, 0x00	; 0
     bb2:	eb e5       	ldi	r30, 0x5B	; 91
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	8f 7b       	andi	r24, 0xBF	; 191
     bba:	8c 93       	st	X, r24
}
     bbc:	cf 91       	pop	r28
     bbe:	df 91       	pop	r29
     bc0:	08 95       	ret

00000bc2 <led_on>:
 * turn on the led
 */


void led_on(uint8 led_id)
{
     bc2:	df 93       	push	r29
     bc4:	cf 93       	push	r28
     bc6:	0f 92       	push	r0
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
     bcc:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePin(led_lookup_table[led_id].port_num, led_lookup_table[led_id].pin_num, LOGIC_HIGH);
     bce:	89 81       	ldd	r24, Y+1	; 0x01
     bd0:	88 2f       	mov	r24, r24
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	88 0f       	add	r24, r24
     bd6:	99 1f       	adc	r25, r25
     bd8:	fc 01       	movw	r30, r24
     bda:	e5 5c       	subi	r30, 0xC5	; 197
     bdc:	fe 4f       	sbci	r31, 0xFE	; 254
     bde:	20 81       	ld	r18, Z
     be0:	89 81       	ldd	r24, Y+1	; 0x01
     be2:	88 2f       	mov	r24, r24
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	88 0f       	add	r24, r24
     be8:	99 1f       	adc	r25, r25
     bea:	fc 01       	movw	r30, r24
     bec:	e4 5c       	subi	r30, 0xC4	; 196
     bee:	fe 4f       	sbci	r31, 0xFE	; 254
     bf0:	90 81       	ld	r25, Z
     bf2:	82 2f       	mov	r24, r18
     bf4:	69 2f       	mov	r22, r25
     bf6:	41 e0       	ldi	r20, 0x01	; 1
     bf8:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
}
     bfc:	0f 90       	pop	r0
     bfe:	cf 91       	pop	r28
     c00:	df 91       	pop	r29
     c02:	08 95       	ret

00000c04 <led_off>:
/*
 * Description :
 * turn off the led
 */
void led_off(uint8 led_id)
{
     c04:	df 93       	push	r29
     c06:	cf 93       	push	r28
     c08:	0f 92       	push	r0
     c0a:	cd b7       	in	r28, 0x3d	; 61
     c0c:	de b7       	in	r29, 0x3e	; 62
     c0e:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePin(led_lookup_table[led_id].port_num, led_lookup_table[led_id].pin_num, LOGIC_LOW);
     c10:	89 81       	ldd	r24, Y+1	; 0x01
     c12:	88 2f       	mov	r24, r24
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	88 0f       	add	r24, r24
     c18:	99 1f       	adc	r25, r25
     c1a:	fc 01       	movw	r30, r24
     c1c:	e5 5c       	subi	r30, 0xC5	; 197
     c1e:	fe 4f       	sbci	r31, 0xFE	; 254
     c20:	20 81       	ld	r18, Z
     c22:	89 81       	ldd	r24, Y+1	; 0x01
     c24:	88 2f       	mov	r24, r24
     c26:	90 e0       	ldi	r25, 0x00	; 0
     c28:	88 0f       	add	r24, r24
     c2a:	99 1f       	adc	r25, r25
     c2c:	fc 01       	movw	r30, r24
     c2e:	e4 5c       	subi	r30, 0xC4	; 196
     c30:	fe 4f       	sbci	r31, 0xFE	; 254
     c32:	90 81       	ld	r25, Z
     c34:	82 2f       	mov	r24, r18
     c36:	69 2f       	mov	r22, r25
     c38:	40 e0       	ldi	r20, 0x00	; 0
     c3a:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
}
     c3e:	0f 90       	pop	r0
     c40:	cf 91       	pop	r28
     c42:	df 91       	pop	r29
     c44:	08 95       	ret

00000c46 <led_toggle>:
/*
 * Description :
 * toggle the led state
 */
void led_toggle(uint8 led_id)
{
     c46:	df 93       	push	r29
     c48:	cf 93       	push	r28
     c4a:	0f 92       	push	r0
     c4c:	cd b7       	in	r28, 0x3d	; 61
     c4e:	de b7       	in	r29, 0x3e	; 62
     c50:	89 83       	std	Y+1, r24	; 0x01
	GPIO_togglePin(led_lookup_table[led_id].port_num, led_lookup_table[led_id].pin_num);
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	88 2f       	mov	r24, r24
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	88 0f       	add	r24, r24
     c5a:	99 1f       	adc	r25, r25
     c5c:	fc 01       	movw	r30, r24
     c5e:	e5 5c       	subi	r30, 0xC5	; 197
     c60:	fe 4f       	sbci	r31, 0xFE	; 254
     c62:	20 81       	ld	r18, Z
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	88 2f       	mov	r24, r24
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	88 0f       	add	r24, r24
     c6c:	99 1f       	adc	r25, r25
     c6e:	fc 01       	movw	r30, r24
     c70:	e4 5c       	subi	r30, 0xC4	; 196
     c72:	fe 4f       	sbci	r31, 0xFE	; 254
     c74:	90 81       	ld	r25, Z
     c76:	82 2f       	mov	r24, r18
     c78:	69 2f       	mov	r22, r25
     c7a:	0e 94 ba 04 	call	0x974	; 0x974 <GPIO_togglePin>
}
     c7e:	0f 90       	pop	r0
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	08 95       	ret

00000c86 <button_init>:
 * Description :
 * Setup the direction of the required button to  input.
 * Setup the pull up or tri state
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void button_init(uint8 button_id,BUTTON_DefualtInputType DefualtInput){
     c86:	df 93       	push	r29
     c88:	cf 93       	push	r28
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <button_init+0x6>
     c8c:	cd b7       	in	r28, 0x3d	; 61
     c8e:	de b7       	in	r29, 0x3e	; 62
     c90:	89 83       	std	Y+1, r24	; 0x01
     c92:	6a 83       	std	Y+2, r22	; 0x02


	GPIO_setupPinDirection( button_lookup_table[button_id].port_num,  button_lookup_table[button_id].pin_num, PIN_INPUT);
     c94:	89 81       	ldd	r24, Y+1	; 0x01
     c96:	88 2f       	mov	r24, r24
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	88 0f       	add	r24, r24
     c9c:	99 1f       	adc	r25, r25
     c9e:	fc 01       	movw	r30, r24
     ca0:	e5 5c       	subi	r30, 0xC5	; 197
     ca2:	fe 4f       	sbci	r31, 0xFE	; 254
     ca4:	20 81       	ld	r18, Z
     ca6:	89 81       	ldd	r24, Y+1	; 0x01
     ca8:	88 2f       	mov	r24, r24
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	88 0f       	add	r24, r24
     cae:	99 1f       	adc	r25, r25
     cb0:	fc 01       	movw	r30, r24
     cb2:	e4 5c       	subi	r30, 0xC4	; 196
     cb4:	fe 4f       	sbci	r31, 0xFE	; 254
     cb6:	90 81       	ld	r25, Z
     cb8:	82 2f       	mov	r24, r18
     cba:	69 2f       	mov	r22, r25
     cbc:	40 e0       	ldi	r20, 0x00	; 0
     cbe:	0e 94 49 02 	call	0x492	; 0x492 <GPIO_setupPinDirection>

	if(DefualtInput == PULL_UP){
     cc2:	8a 81       	ldd	r24, Y+2	; 0x02
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	c1 f4       	brne	.+48     	; 0xcf8 <button_init+0x72>
		GPIO_writePin( button_lookup_table[button_id].port_num,  button_lookup_table[button_id].pin_num, LOGIC_HIGH);
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	88 2f       	mov	r24, r24
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	88 0f       	add	r24, r24
     cd0:	99 1f       	adc	r25, r25
     cd2:	fc 01       	movw	r30, r24
     cd4:	e5 5c       	subi	r30, 0xC5	; 197
     cd6:	fe 4f       	sbci	r31, 0xFE	; 254
     cd8:	20 81       	ld	r18, Z
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	88 2f       	mov	r24, r24
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	88 0f       	add	r24, r24
     ce2:	99 1f       	adc	r25, r25
     ce4:	fc 01       	movw	r30, r24
     ce6:	e4 5c       	subi	r30, 0xC4	; 196
     ce8:	fe 4f       	sbci	r31, 0xFE	; 254
     cea:	90 81       	ld	r25, Z
     cec:	82 2f       	mov	r24, r18
     cee:	69 2f       	mov	r22, r25
     cf0:	41 e0       	ldi	r20, 0x01	; 1
     cf2:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
     cf6:	17 c0       	rjmp	.+46     	; 0xd26 <button_init+0xa0>
	}
	else
	{
		GPIO_writePin( button_lookup_table[button_id].port_num,  button_lookup_table[button_id].pin_num, LOGIC_LOW);
     cf8:	89 81       	ldd	r24, Y+1	; 0x01
     cfa:	88 2f       	mov	r24, r24
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	88 0f       	add	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	fc 01       	movw	r30, r24
     d04:	e5 5c       	subi	r30, 0xC5	; 197
     d06:	fe 4f       	sbci	r31, 0xFE	; 254
     d08:	20 81       	ld	r18, Z
     d0a:	89 81       	ldd	r24, Y+1	; 0x01
     d0c:	88 2f       	mov	r24, r24
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	88 0f       	add	r24, r24
     d12:	99 1f       	adc	r25, r25
     d14:	fc 01       	movw	r30, r24
     d16:	e4 5c       	subi	r30, 0xC4	; 196
     d18:	fe 4f       	sbci	r31, 0xFE	; 254
     d1a:	90 81       	ld	r25, Z
     d1c:	82 2f       	mov	r24, r18
     d1e:	69 2f       	mov	r22, r25
     d20:	40 e0       	ldi	r20, 0x00	; 0
     d22:	0e 94 34 03 	call	0x668	; 0x668 <GPIO_writePin>
	}
}
     d26:	0f 90       	pop	r0
     d28:	0f 90       	pop	r0
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	08 95       	ret

00000d30 <read_button>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 read_button(uint8 button_id){
     d30:	df 93       	push	r29
     d32:	cf 93       	push	r28
     d34:	00 d0       	rcall	.+0      	; 0xd36 <read_button+0x6>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	8a 83       	std	Y+2, r24	; 0x02

	uint8 pin_value = LOGIC_LOW;
     d3c:	19 82       	std	Y+1, r1	; 0x01

	pin_value = GPIO_readPin( button_lookup_table[button_id].port_num,  button_lookup_table[button_id].pin_num);
     d3e:	8a 81       	ldd	r24, Y+2	; 0x02
     d40:	88 2f       	mov	r24, r24
     d42:	90 e0       	ldi	r25, 0x00	; 0
     d44:	88 0f       	add	r24, r24
     d46:	99 1f       	adc	r25, r25
     d48:	fc 01       	movw	r30, r24
     d4a:	e5 5c       	subi	r30, 0xC5	; 197
     d4c:	fe 4f       	sbci	r31, 0xFE	; 254
     d4e:	20 81       	ld	r18, Z
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	88 2f       	mov	r24, r24
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	88 0f       	add	r24, r24
     d58:	99 1f       	adc	r25, r25
     d5a:	fc 01       	movw	r30, r24
     d5c:	e4 5c       	subi	r30, 0xC4	; 196
     d5e:	fe 4f       	sbci	r31, 0xFE	; 254
     d60:	90 81       	ld	r25, Z
     d62:	82 2f       	mov	r24, r18
     d64:	69 2f       	mov	r22, r25
     d66:	0e 94 1f 04 	call	0x83e	; 0x83e <GPIO_readPin>
     d6a:	89 83       	std	Y+1, r24	; 0x01

	return pin_value;
     d6c:	89 81       	ldd	r24, Y+1	; 0x01

}
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	cf 91       	pop	r28
     d74:	df 91       	pop	r29
     d76:	08 95       	ret

00000d78 <Task0>:

/*the observer and the brain of the system it check button state and rise flag of the event group variable
 * depend of the conditions the flags unblock other tasks*/

void Task0(void *pvParameters)
{
     d78:	df 93       	push	r29
     d7a:	cf 93       	push	r28
     d7c:	cd b7       	in	r28, 0x3d	; 61
     d7e:	de b7       	in	r29, 0x3e	; 62
     d80:	2a 97       	sbiw	r28, 0x0a	; 10
     d82:	0f b6       	in	r0, 0x3f	; 63
     d84:	f8 94       	cli
     d86:	de bf       	out	0x3e, r29	; 62
     d88:	0f be       	out	0x3f, r0	; 63
     d8a:	cd bf       	out	0x3d, r28	; 61
     d8c:	9a 87       	std	Y+10, r25	; 0x0a
     d8e:	89 87       	std	Y+9, r24	; 0x09
	/****************************************************************
	 *                     local variable                         *
	 ***************************************************************/

	/*store the left led state ,it its on if the two sequential read is equal INDICATOR_ACTIVATION*/
	uint8 left_flag = LOGIC_LOW;
     d90:	1a 82       	std	Y+2, r1	; 0x02
	/*store the right led state, it its on if the two sequential read is equal INDICATOR_ACTIVATION*/
	uint8 right_flag = LOGIC_LOW;
     d92:	19 82       	std	Y+1, r1	; 0x01
	/*array to store the past read and present read of button to do some condition */
	uint8 btn_ingit_state[NUM_OF_STATE] = {LOGIC_HIGH , LOGIC_HIGH};
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	8b 83       	std	Y+3, r24	; 0x03
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	8c 83       	std	Y+4, r24	; 0x04
	uint8 btn_left_state[NUM_OF_STATE] = {LOGIC_HIGH , LOGIC_HIGH};
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	8d 83       	std	Y+5, r24	; 0x05
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	8e 83       	std	Y+6, r24	; 0x06
	uint8 btn_right_state[NUM_OF_STATE] = {LOGIC_HIGH , LOGIC_HIGH};
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	8f 83       	std	Y+7, r24	; 0x07
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	88 87       	std	Y+8, r24	; 0x08

	/*super loop*/
	while(1)
	{
		/*read the current state of the button and store it on variable*/
		btn_ingit_state[PRESENT_STATE] = read_button(IGNITION_BUTTON_ID);
     dac:	83 e0       	ldi	r24, 0x03	; 3
     dae:	0e 94 98 06 	call	0xd30	; 0xd30 <read_button>
     db2:	8c 83       	std	Y+4, r24	; 0x04
		btn_left_state[PRESENT_STATE] = read_button(LEFT_INDEICATOR_ID);
     db4:	81 e0       	ldi	r24, 0x01	; 1
     db6:	0e 94 98 06 	call	0xd30	; 0xd30 <read_button>
     dba:	8e 83       	std	Y+6, r24	; 0x06
		btn_right_state[PRESENT_STATE] = read_button(RIGHT_INDEICATOR_ID);
     dbc:	82 e0       	ldi	r24, 0x02	; 2
     dbe:	0e 94 98 06 	call	0xd30	; 0xd30 <read_button>
     dc2:	88 87       	std	Y+8, r24	; 0x08


		/*check the past state and present state of the ignition button if it active or not */
		if( (btn_ingit_state[PRESENT_STATE] == IGNITION_CTIVATION) && (btn_ingit_state[PAST_STATE] == IGNITION_CTIVATION) )
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	88 23       	and	r24, r24
     dc8:	a1 f4       	brne	.+40     	; 0xdf2 <Task0+0x7a>
     dca:	8b 81       	ldd	r24, Y+3	; 0x03
     dcc:	88 23       	and	r24, r24
     dce:	89 f4       	brne	.+34     	; 0xdf2 <Task0+0x7a>
		{
			/*if active set the ignition button flag in the event group to enable task 2,3,4
			 * and clear no ignition flag in the event group*/
			xEventGroupSetBits(xEventGroup,  BIT(IGNITION_FLAG));
     dd0:	80 91 93 04 	lds	r24, 0x0493
     dd4:	90 91 94 04 	lds	r25, 0x0494
     dd8:	61 e0       	ldi	r22, 0x01	; 1
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
			xEventGroupClearBits(xEventGroup,  BIT(NO_IGNITION_FLAG));
     de0:	80 91 93 04 	lds	r24, 0x0493
     de4:	90 91 94 04 	lds	r25, 0x0494
     de8:	60 e2       	ldi	r22, 0x20	; 32
     dea:	70 e0       	ldi	r23, 0x00	; 0
     dec:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
     df0:	12 c0       	rjmp	.+36     	; 0xe16 <Task0+0x9e>
		}
		else
		{
			/*if not active clear the ignition button flag in the event group to disable task 2,3,4
			 * and set no ignition flag in the event group to enable task1*/
			xEventGroupClearBits(xEventGroup,  BIT(IGNITION_FLAG));
     df2:	80 91 93 04 	lds	r24, 0x0493
     df6:	90 91 94 04 	lds	r25, 0x0494
     dfa:	61 e0       	ldi	r22, 0x01	; 1
     dfc:	70 e0       	ldi	r23, 0x00	; 0
     dfe:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
			xEventGroupSetBits(xEventGroup,  BIT(NO_IGNITION_FLAG));
     e02:	80 91 93 04 	lds	r24, 0x0493
     e06:	90 91 94 04 	lds	r25, 0x0494
     e0a:	60 e2       	ldi	r22, 0x20	; 32
     e0c:	70 e0       	ldi	r23, 0x00	; 0
     e0e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
			/*if the ignition button is not on ,clear the hazard state so it do not keep the history of the button when the ignition is on again*/
			hazard_isPressed = LOGIC_LOW;
     e12:	10 92 44 01 	sts	0x0144, r1

		}


		/*check the past state and present state of the left button if it active or not */
		if( (btn_left_state[PRESENT_STATE] == INDICATOR_ACTIVATION) && (btn_left_state[PAST_STATE] == INDICATOR_ACTIVATION) )
     e16:	8e 81       	ldd	r24, Y+6	; 0x06
     e18:	88 23       	and	r24, r24
     e1a:	71 f4       	brne	.+28     	; 0xe38 <Task0+0xc0>
     e1c:	8d 81       	ldd	r24, Y+5	; 0x05
     e1e:	88 23       	and	r24, r24
     e20:	59 f4       	brne	.+22     	; 0xe38 <Task0+0xc0>
		{
			/*if active set the left button flag in the event group to enable task2*/
			xEventGroupSetBits(xEventGroup,  BIT(LEFT_FLAG));
     e22:	80 91 93 04 	lds	r24, 0x0493
     e26:	90 91 94 04 	lds	r25, 0x0494
     e2a:	64 e0       	ldi	r22, 0x04	; 4
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
			left_flag = LOGIC_HIGH;
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	8a 83       	std	Y+2, r24	; 0x02
     e36:	09 c0       	rjmp	.+18     	; 0xe4a <Task0+0xd2>
		}
		else
		{
			/*if not active clear the left button flag in the event group to disable task2*/
			xEventGroupClearBits(xEventGroup,  BIT(LEFT_FLAG));
     e38:	80 91 93 04 	lds	r24, 0x0493
     e3c:	90 91 94 04 	lds	r25, 0x0494
     e40:	64 e0       	ldi	r22, 0x04	; 4
     e42:	70 e0       	ldi	r23, 0x00	; 0
     e44:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
			left_flag = LOGIC_LOW;
     e48:	1a 82       	std	Y+2, r1	; 0x02
		}



		/*check the past state and present state of the right button if it active or not */
		if( (btn_right_state[PRESENT_STATE] == INDICATOR_ACTIVATION) && (btn_right_state[PAST_STATE] == INDICATOR_ACTIVATION) )
     e4a:	88 85       	ldd	r24, Y+8	; 0x08
     e4c:	88 23       	and	r24, r24
     e4e:	71 f4       	brne	.+28     	; 0xe6c <Task0+0xf4>
     e50:	8f 81       	ldd	r24, Y+7	; 0x07
     e52:	88 23       	and	r24, r24
     e54:	59 f4       	brne	.+22     	; 0xe6c <Task0+0xf4>
		{
			/*if active set the right button flag in the event group to enable task3*/
			xEventGroupSetBits(xEventGroup,  BIT(RIGHT_FLAG));
     e56:	80 91 93 04 	lds	r24, 0x0493
     e5a:	90 91 94 04 	lds	r25, 0x0494
     e5e:	68 e0       	ldi	r22, 0x08	; 8
     e60:	70 e0       	ldi	r23, 0x00	; 0
     e62:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
			right_flag = LOGIC_HIGH;
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	89 83       	std	Y+1, r24	; 0x01
     e6a:	09 c0       	rjmp	.+18     	; 0xe7e <Task0+0x106>
		}
		else
		{
			/*if not active clear the right button flag in the event group to disable task3*/
			xEventGroupClearBits(xEventGroup,  BIT(RIGHT_FLAG));
     e6c:	80 91 93 04 	lds	r24, 0x0493
     e70:	90 91 94 04 	lds	r25, 0x0494
     e74:	68 e0       	ldi	r22, 0x08	; 8
     e76:	70 e0       	ldi	r23, 0x00	; 0
     e78:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
			right_flag = LOGIC_LOW;
     e7c:	19 82       	std	Y+1, r1	; 0x01
		}



		/*check if the two sequential read is not active in both button left and right*/
		 if( (right_flag == LOGIC_LOW)   &&    ( left_flag == LOGIC_LOW) &&  (hazard_isPressed == LOGIC_LOW))
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	88 23       	and	r24, r24
     e82:	81 f4       	brne	.+32     	; 0xea4 <Task0+0x12c>
     e84:	8a 81       	ldd	r24, Y+2	; 0x02
     e86:	88 23       	and	r24, r24
     e88:	69 f4       	brne	.+26     	; 0xea4 <Task0+0x12c>
     e8a:	80 91 44 01 	lds	r24, 0x0144
     e8e:	88 23       	and	r24, r24
     e90:	49 f4       	brne	.+18     	; 0xea4 <Task0+0x12c>
		{
			 /* if the condition is true set the idle flag to enable task1 */
			xEventGroupSetBits(xEventGroup,  BIT(IDLE_FLAG));
     e92:	80 91 93 04 	lds	r24, 0x0493
     e96:	90 91 94 04 	lds	r25, 0x0494
     e9a:	62 e0       	ldi	r22, 0x02	; 2
     e9c:	70 e0       	ldi	r23, 0x00	; 0
     e9e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
     ea2:	08 c0       	rjmp	.+16     	; 0xeb4 <Task0+0x13c>
		}
		else
		{
			/* if the condition is false set the idle flag to disable task1 */
			xEventGroupClearBits(xEventGroup,  BIT(IDLE_FLAG));
     ea4:	80 91 93 04 	lds	r24, 0x0493
     ea8:	90 91 94 04 	lds	r25, 0x0494
     eac:	62 e0       	ldi	r22, 0x02	; 2
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
		}



		 /*check if the hazard button is pressed */
		if (hazard_isPressed == LOGIC_HIGH)
     eb4:	80 91 44 01 	lds	r24, 0x0144
     eb8:	81 30       	cpi	r24, 0x01	; 1
     eba:	89 f4       	brne	.+34     	; 0xede <Task0+0x166>
		{
			/*if true set ALL_LED_IS_ON_FLAG to enable task4*/
			xEventGroupSetBits(xEventGroup,  BIT(ALL_LED_IS_ON_FLAG));
     ebc:	80 91 93 04 	lds	r24, 0x0493
     ec0:	90 91 94 04 	lds	r25, 0x0494
     ec4:	60 e1       	ldi	r22, 0x10	; 16
     ec6:	70 e0       	ldi	r23, 0x00	; 0
     ec8:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
			/*if true clear NOT_ALL_LED_IS_ON_FLAG to disable task 2,3*/
			xEventGroupClearBits(xEventGroup,  BIT(NOT_ALL_LED_IS_ON_FLAG));
     ecc:	80 91 93 04 	lds	r24, 0x0493
     ed0:	90 91 94 04 	lds	r25, 0x0494
     ed4:	60 e8       	ldi	r22, 0x80	; 128
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
     edc:	10 c0       	rjmp	.+32     	; 0xefe <Task0+0x186>

		}
		else
		{
			/*if false clear ALL_LED_IS_ON_FLAG to disable task4*/
			xEventGroupClearBits(xEventGroup,  BIT(ALL_LED_IS_ON_FLAG));
     ede:	80 91 93 04 	lds	r24, 0x0493
     ee2:	90 91 94 04 	lds	r25, 0x0494
     ee6:	60 e1       	ldi	r22, 0x10	; 16
     ee8:	70 e0       	ldi	r23, 0x00	; 0
     eea:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
			/*if false set NOT_ALL_LED_IS_ON_FLAG to enable task 2,3*/
			xEventGroupSetBits(xEventGroup,  BIT(NOT_ALL_LED_IS_ON_FLAG));
     eee:	80 91 93 04 	lds	r24, 0x0493
     ef2:	90 91 94 04 	lds	r25, 0x0494
     ef6:	60 e8       	ldi	r22, 0x80	; 128
     ef8:	70 e0       	ldi	r23, 0x00	; 0
     efa:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
		}


		/*after the task end store the present state to use it as past state in the next round*/
		btn_ingit_state[PAST_STATE] = btn_ingit_state[PRESENT_STATE];
     efe:	8c 81       	ldd	r24, Y+4	; 0x04
     f00:	8b 83       	std	Y+3, r24	; 0x03
		btn_left_state[PAST_STATE] = btn_left_state[PRESENT_STATE];
     f02:	8e 81       	ldd	r24, Y+6	; 0x06
     f04:	8d 83       	std	Y+5, r24	; 0x05
		btn_right_state[PAST_STATE] = btn_right_state[PRESENT_STATE];
     f06:	88 85       	ldd	r24, Y+8	; 0x08
     f08:	8f 83       	std	Y+7, r24	; 0x07

		/*the time to block the task 50ms */
		vTaskDelay(BUTTON_SIGNAL_SET_TIME);
     f0a:	82 e3       	ldi	r24, 0x32	; 50
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	0e 94 6f 1e 	call	0x3cde	; 0x3cde <vTaskDelay>
     f12:	4c cf       	rjmp	.-360    	; 0xdac <Task0+0x34>

00000f14 <Task1>:
 ***************************************************************/

/*idle task which mean no led is on all it does is to turn off all leds*/

void Task1(void *pvParameters)
{
     f14:	0f 93       	push	r16
     f16:	1f 93       	push	r17
     f18:	df 93       	push	r29
     f1a:	cf 93       	push	r28
     f1c:	00 d0       	rcall	.+0      	; 0xf1e <Task1+0xa>
     f1e:	cd b7       	in	r28, 0x3d	; 61
     f20:	de b7       	in	r29, 0x3e	; 62
     f22:	9a 83       	std	Y+2, r25	; 0x02
     f24:	89 83       	std	Y+1, r24	; 0x01
		* Parameters : to clear the flags when the function return
		* Parameters : and logic (true)   , or logic (false)
		* Return value: the event group variable
		* Description: wait on the specified flags to set to run the task.
		************************************************************************************/
		xEventGroupWaitBits( xEventGroup , BIT(IDLE_FLAG) | BIT(NO_IGNITION_FLAG) , pdFALSE , pdFALSE ,  portMAX_DELAY );
     f26:	80 91 93 04 	lds	r24, 0x0493
     f2a:	90 91 94 04 	lds	r25, 0x0494
     f2e:	62 e2       	ldi	r22, 0x22	; 34
     f30:	70 e0       	ldi	r23, 0x00	; 0
     f32:	40 e0       	ldi	r20, 0x00	; 0
     f34:	20 e0       	ldi	r18, 0x00	; 0
     f36:	0f ef       	ldi	r16, 0xFF	; 255
     f38:	1f ef       	ldi	r17, 0xFF	; 255
     f3a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xEventGroupWaitBits>
		/*turn off all leds*/
		PWM_Timer0_Stop();
     f3e:	0e 94 81 00 	call	0x102	; 0x102 <PWM_Timer0_Stop>
		PWM_Timer2_Stop();
     f42:	0e 94 8b 00 	call	0x116	; 0x116 <PWM_Timer2_Stop>
		/*the time to block the task 100ms*/
		vTaskDelay(FASTEST_PRESS);
     f46:	84 e6       	ldi	r24, 0x64	; 100
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	0e 94 6f 1e 	call	0x3cde	; 0x3cde <vTaskDelay>
     f4e:	eb cf       	rjmp	.-42     	; 0xf26 <Task1+0x12>

00000f50 <Task2>:
}
/****************************************************************
 *                             task2                            *
 ***************************************************************/
void Task2(void *pvParameters)
{
     f50:	0f 93       	push	r16
     f52:	1f 93       	push	r17
     f54:	df 93       	push	r29
     f56:	cf 93       	push	r28
     f58:	00 d0       	rcall	.+0      	; 0xf5a <Task2+0xa>
     f5a:	0f 92       	push	r0
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	9b 83       	std	Y+3, r25	; 0x03
     f62:	8a 83       	std	Y+2, r24	; 0x02
	/*local variable to toggle the led*/
	uint8 local_flag = LOGIC_LOW;
     f64:	19 82       	std	Y+1, r1	; 0x01
		* Parameters : to clear the flags when the function return
		* Parameters : and logic (true)   , or logic (false)
		* Return value: the event group variable
		* Description: wait on the specified flags to set to run the task.
		************************************************************************************/
		xEventGroupWaitBits(xEventGroup, BIT(LEFT_FLAG)|BIT(IGNITION_FLAG)|BIT(NOT_ALL_LED_IS_ON_FLAG) , pdFALSE, pdTRUE , portMAX_DELAY);
     f66:	80 91 93 04 	lds	r24, 0x0493
     f6a:	90 91 94 04 	lds	r25, 0x0494
     f6e:	65 e8       	ldi	r22, 0x85	; 133
     f70:	70 e0       	ldi	r23, 0x00	; 0
     f72:	40 e0       	ldi	r20, 0x00	; 0
     f74:	21 e0       	ldi	r18, 0x01	; 1
     f76:	0f ef       	ldi	r16, 0xFF	; 255
     f78:	1f ef       	ldi	r17, 0xFF	; 255
     f7a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xEventGroupWaitBits>


		/*turn of the right led*/
		PWM_Timer0_Stop();
     f7e:	0e 94 81 00 	call	0x102	; 0x102 <PWM_Timer0_Stop>

		/*the code below used to toggle the led*/
		if(local_flag == LOGIC_LOW)
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	88 23       	and	r24, r24
     f86:	29 f4       	brne	.+10     	; 0xf92 <Task2+0x42>
		{

			PWM_Timer2_Start();
     f88:	0e 94 64 00 	call	0xc8	; 0xc8 <PWM_Timer2_Start>
			local_flag = LOGIC_HIGH;
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	89 83       	std	Y+1, r24	; 0x01
     f90:	03 c0       	rjmp	.+6      	; 0xf98 <Task2+0x48>
		}
		else
		{

			PWM_Timer2_Stop();
     f92:	0e 94 8b 00 	call	0x116	; 0x116 <PWM_Timer2_Stop>
			local_flag = LOGIC_LOW;
     f96:	19 82       	std	Y+1, r1	; 0x01
		}

		/*the time to block the task 500ms*/
		vTaskDelay(LED_BLINKING_TIME);
     f98:	84 ef       	ldi	r24, 0xF4	; 244
     f9a:	91 e0       	ldi	r25, 0x01	; 1
     f9c:	0e 94 6f 1e 	call	0x3cde	; 0x3cde <vTaskDelay>
     fa0:	e2 cf       	rjmp	.-60     	; 0xf66 <Task2+0x16>

00000fa2 <Task3>:
}
/****************************************************************
 *                             task3                            *
 ***************************************************************/
void Task3(void *pvParameters)
{
     fa2:	0f 93       	push	r16
     fa4:	1f 93       	push	r17
     fa6:	df 93       	push	r29
     fa8:	cf 93       	push	r28
     faa:	00 d0       	rcall	.+0      	; 0xfac <Task3+0xa>
     fac:	0f 92       	push	r0
     fae:	cd b7       	in	r28, 0x3d	; 61
     fb0:	de b7       	in	r29, 0x3e	; 62
     fb2:	9b 83       	std	Y+3, r25	; 0x03
     fb4:	8a 83       	std	Y+2, r24	; 0x02
	/*local variable to toggle the led*/
	uint8 local_flag = LOGIC_LOW;
     fb6:	19 82       	std	Y+1, r1	; 0x01
		* Parameters : to clear the flags when the function return
		* Parameters : and logic (true)   , or logic (false)
		* Return value: the event group variable
		* Description: wait on the specified flags to set to run the task.
		************************************************************************************/
		xEventGroupWaitBits( xEventGroup , BIT(RIGHT_FLAG)|BIT(IGNITION_FLAG)|BIT(NOT_ALL_LED_IS_ON_FLAG) , pdFALSE , pdTRUE , portMAX_DELAY);
     fb8:	80 91 93 04 	lds	r24, 0x0493
     fbc:	90 91 94 04 	lds	r25, 0x0494
     fc0:	69 e8       	ldi	r22, 0x89	; 137
     fc2:	70 e0       	ldi	r23, 0x00	; 0
     fc4:	40 e0       	ldi	r20, 0x00	; 0
     fc6:	21 e0       	ldi	r18, 0x01	; 1
     fc8:	0f ef       	ldi	r16, 0xFF	; 255
     fca:	1f ef       	ldi	r17, 0xFF	; 255
     fcc:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xEventGroupWaitBits>


		/*turn of the left led*/
		PWM_Timer2_Stop();
     fd0:	0e 94 8b 00 	call	0x116	; 0x116 <PWM_Timer2_Stop>

		/*the code below used to toggle the led*/
		if(local_flag == LOGIC_LOW)
     fd4:	89 81       	ldd	r24, Y+1	; 0x01
     fd6:	88 23       	and	r24, r24
     fd8:	29 f4       	brne	.+10     	; 0xfe4 <Task3+0x42>
		{

			PWM_Timer0_Start();
     fda:	0e 94 47 00 	call	0x8e	; 0x8e <PWM_Timer0_Start>
			local_flag = LOGIC_HIGH;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	89 83       	std	Y+1, r24	; 0x01
     fe2:	03 c0       	rjmp	.+6      	; 0xfea <Task3+0x48>
		}
		else
		{

			PWM_Timer0_Stop();
     fe4:	0e 94 81 00 	call	0x102	; 0x102 <PWM_Timer0_Stop>
			local_flag = LOGIC_LOW;
     fe8:	19 82       	std	Y+1, r1	; 0x01
		}

		/*the time to block the task 500ms*/
		vTaskDelay(LED_BLINKING_TIME);
     fea:	84 ef       	ldi	r24, 0xF4	; 244
     fec:	91 e0       	ldi	r25, 0x01	; 1
     fee:	0e 94 6f 1e 	call	0x3cde	; 0x3cde <vTaskDelay>
     ff2:	e2 cf       	rjmp	.-60     	; 0xfb8 <Task3+0x16>

00000ff4 <Task4>:
}
/****************************************************************
 *                             task4                            *
 ***************************************************************/
void Task4(void *pvParameters)
{
     ff4:	0f 93       	push	r16
     ff6:	1f 93       	push	r17
     ff8:	df 93       	push	r29
     ffa:	cf 93       	push	r28
     ffc:	00 d0       	rcall	.+0      	; 0xffe <Task4+0xa>
     ffe:	0f 92       	push	r0
    1000:	cd b7       	in	r28, 0x3d	; 61
    1002:	de b7       	in	r29, 0x3e	; 62
    1004:	9b 83       	std	Y+3, r25	; 0x03
    1006:	8a 83       	std	Y+2, r24	; 0x02
	/*local variable to toggle the led*/
	uint8 local_flag = LOGIC_LOW;
    1008:	19 82       	std	Y+1, r1	; 0x01
		* Parameters : to clear the flags when the function return
		* Parameters : and logic (true)   , or logic (false)
		* Return value: the event group variable
		* Description: wait on the specified flags to set to run the task.
		************************************************************************************/
		 xEventGroupWaitBits( xEventGroup , BIT(ALL_LED_IS_ON_FLAG)|BIT(IGNITION_FLAG) , pdFALSE, pdTRUE , portMAX_DELAY );
    100a:	80 91 93 04 	lds	r24, 0x0493
    100e:	90 91 94 04 	lds	r25, 0x0494
    1012:	61 e1       	ldi	r22, 0x11	; 17
    1014:	70 e0       	ldi	r23, 0x00	; 0
    1016:	40 e0       	ldi	r20, 0x00	; 0
    1018:	21 e0       	ldi	r18, 0x01	; 1
    101a:	0f ef       	ldi	r16, 0xFF	; 255
    101c:	1f ef       	ldi	r17, 0xFF	; 255
    101e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xEventGroupWaitBits>


		 /*the code below used to toggle all the led*/
		if(local_flag == LOGIC_LOW)
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	88 23       	and	r24, r24
    1026:	39 f4       	brne	.+14     	; 0x1036 <Task4+0x42>
		{
			PWM_Timer2_Start();
    1028:	0e 94 64 00 	call	0xc8	; 0xc8 <PWM_Timer2_Start>
			PWM_Timer0_Start();
    102c:	0e 94 47 00 	call	0x8e	; 0x8e <PWM_Timer0_Start>
			local_flag = LOGIC_HIGH;
    1030:	81 e0       	ldi	r24, 0x01	; 1
    1032:	89 83       	std	Y+1, r24	; 0x01
    1034:	05 c0       	rjmp	.+10     	; 0x1040 <Task4+0x4c>
		}
		else
		{

			PWM_Timer2_Stop();
    1036:	0e 94 8b 00 	call	0x116	; 0x116 <PWM_Timer2_Stop>
			PWM_Timer0_Stop();
    103a:	0e 94 81 00 	call	0x102	; 0x102 <PWM_Timer0_Stop>
			local_flag = LOGIC_LOW;
    103e:	19 82       	std	Y+1, r1	; 0x01
		}

		/*the time to block the task 500ms*/
		vTaskDelay(LED_BLINKING_TIME);
    1040:	84 ef       	ldi	r24, 0xF4	; 244
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	0e 94 6f 1e 	call	0x3cde	; 0x3cde <vTaskDelay>
    1048:	e0 cf       	rjmp	.-64     	; 0x100a <Task4+0x16>

0000104a <__vector_1>:
 *              interrupt implementation                        *
 ***************************************************************/

/*toggle the state with every interrupt*/
ISR(INT0_vect)
{
    104a:	1f 92       	push	r1
    104c:	0f 92       	push	r0
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	0f 92       	push	r0
    1052:	11 24       	eor	r1, r1
    1054:	8f 93       	push	r24
    1056:	df 93       	push	r29
    1058:	cf 93       	push	r28
    105a:	cd b7       	in	r28, 0x3d	; 61
    105c:	de b7       	in	r29, 0x3e	; 62
	if(hazard_isPressed == LOGIC_HIGH)
    105e:	80 91 44 01 	lds	r24, 0x0144
    1062:	81 30       	cpi	r24, 0x01	; 1
    1064:	19 f4       	brne	.+6      	; 0x106c <__vector_1+0x22>
	{
		hazard_isPressed = LOGIC_LOW;
    1066:	10 92 44 01 	sts	0x0144, r1
    106a:	03 c0       	rjmp	.+6      	; 0x1072 <__vector_1+0x28>
	}
	else
	{
		hazard_isPressed = LOGIC_HIGH;
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	80 93 44 01 	sts	0x0144, r24
	}
}
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	8f 91       	pop	r24
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63
    107c:	0f 90       	pop	r0
    107e:	1f 90       	pop	r1
    1080:	18 95       	reti

00001082 <main>:




int main(int argc, char **argv)
{
    1082:	ef 92       	push	r14
    1084:	ff 92       	push	r15
    1086:	0f 93       	push	r16
    1088:	df 93       	push	r29
    108a:	cf 93       	push	r28
    108c:	00 d0       	rcall	.+0      	; 0x108e <main+0xc>
    108e:	00 d0       	rcall	.+0      	; 0x1090 <main+0xe>
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
    1094:	9a 83       	std	Y+2, r25	; 0x02
    1096:	89 83       	std	Y+1, r24	; 0x01
    1098:	7c 83       	std	Y+4, r23	; 0x04
    109a:	6b 83       	std	Y+3, r22	; 0x03

	GPIO_Init();
    109c:	0e 94 95 00 	call	0x12a	; 0x12a <GPIO_Init>
	GLOBAL_INTERRUPT_ENABLE();
    10a0:	0e 94 a8 05 	call	0xb50	; 0xb50 <GLOBAL_INTERRUPT_ENABLE>
	INT0_init(RISING_EDGE_TRIGGER);
    10a4:	83 e0       	ldi	r24, 0x03	; 3
    10a6:	0e 94 b8 05 	call	0xb70	; 0xb70 <INT0_init>

	xEventGroup = xEventGroupCreate();
    10aa:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <xEventGroupCreate>
    10ae:	90 93 94 04 	sts	0x0494, r25
    10b2:	80 93 93 04 	sts	0x0493, r24

	xTaskCreate(Task0 , "observer" , TASK0_STACK_SIZE ,NULL ,  2 , &task0ptr);
    10b6:	8c eb       	ldi	r24, 0xBC	; 188
    10b8:	96 e0       	ldi	r25, 0x06	; 6
    10ba:	20 e6       	ldi	r18, 0x60	; 96
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	eb e9       	ldi	r30, 0x9B	; 155
    10c0:	f4 e0       	ldi	r31, 0x04	; 4
    10c2:	b9 01       	movw	r22, r18
    10c4:	4b e4       	ldi	r20, 0x4B	; 75
    10c6:	50 e0       	ldi	r21, 0x00	; 0
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	02 e0       	ldi	r16, 0x02	; 2
    10ce:	7f 01       	movw	r14, r30
    10d0:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>
	xTaskCreate(Task1 , "idle state" , configMINIMAL_STACK_SIZE,NULL ,  1 , &task1ptr);
    10d4:	8a e8       	ldi	r24, 0x8A	; 138
    10d6:	97 e0       	ldi	r25, 0x07	; 7
    10d8:	29 e6       	ldi	r18, 0x69	; 105
    10da:	30 e0       	ldi	r19, 0x00	; 0
    10dc:	e9 e9       	ldi	r30, 0x99	; 153
    10de:	f4 e0       	ldi	r31, 0x04	; 4
    10e0:	b9 01       	movw	r22, r18
    10e2:	41 e4       	ldi	r20, 0x41	; 65
    10e4:	50 e0       	ldi	r21, 0x00	; 0
    10e6:	20 e0       	ldi	r18, 0x00	; 0
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	01 e0       	ldi	r16, 0x01	; 1
    10ec:	7f 01       	movw	r14, r30
    10ee:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>
	xTaskCreate(Task2 , "left led" , configMINIMAL_STACK_SIZE,NULL ,  1 , &task2ptr);
    10f2:	88 ea       	ldi	r24, 0xA8	; 168
    10f4:	97 e0       	ldi	r25, 0x07	; 7
    10f6:	24 e7       	ldi	r18, 0x74	; 116
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	e7 e9       	ldi	r30, 0x97	; 151
    10fc:	f4 e0       	ldi	r31, 0x04	; 4
    10fe:	b9 01       	movw	r22, r18
    1100:	41 e4       	ldi	r20, 0x41	; 65
    1102:	50 e0       	ldi	r21, 0x00	; 0
    1104:	20 e0       	ldi	r18, 0x00	; 0
    1106:	30 e0       	ldi	r19, 0x00	; 0
    1108:	01 e0       	ldi	r16, 0x01	; 1
    110a:	7f 01       	movw	r14, r30
    110c:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>
	xTaskCreate(Task3 , "right led" , configMINIMAL_STACK_SIZE,NULL ,  1 , &task3ptr);
    1110:	81 ed       	ldi	r24, 0xD1	; 209
    1112:	97 e0       	ldi	r25, 0x07	; 7
    1114:	2d e7       	ldi	r18, 0x7D	; 125
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	e5 e9       	ldi	r30, 0x95	; 149
    111a:	f4 e0       	ldi	r31, 0x04	; 4
    111c:	b9 01       	movw	r22, r18
    111e:	41 e4       	ldi	r20, 0x41	; 65
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	20 e0       	ldi	r18, 0x00	; 0
    1124:	30 e0       	ldi	r19, 0x00	; 0
    1126:	01 e0       	ldi	r16, 0x01	; 1
    1128:	7f 01       	movw	r14, r30
    112a:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>
	xTaskCreate(Task4 , "all led is on" , configMINIMAL_STACK_SIZE,NULL ,  1 , &task4ptr);
    112e:	8a ef       	ldi	r24, 0xFA	; 250
    1130:	97 e0       	ldi	r25, 0x07	; 7
    1132:	27 e8       	ldi	r18, 0x87	; 135
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	ed e9       	ldi	r30, 0x9D	; 157
    1138:	f4 e0       	ldi	r31, 0x04	; 4
    113a:	b9 01       	movw	r22, r18
    113c:	41 e4       	ldi	r20, 0x41	; 65
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	20 e0       	ldi	r18, 0x00	; 0
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	01 e0       	ldi	r16, 0x01	; 1
    1146:	7f 01       	movw	r14, r30
    1148:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>

	vTaskStartScheduler();
    114c:	0e 94 91 1e 	call	0x3d22	; 0x3d22 <vTaskStartScheduler>



	return 0;
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
}
    1154:	0f 90       	pop	r0
    1156:	0f 90       	pop	r0
    1158:	0f 90       	pop	r0
    115a:	0f 90       	pop	r0
    115c:	cf 91       	pop	r28
    115e:	df 91       	pop	r29
    1160:	0f 91       	pop	r16
    1162:	ff 90       	pop	r15
    1164:	ef 90       	pop	r14
    1166:	08 95       	ret

00001168 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1168:	df 93       	push	r29
    116a:	cf 93       	push	r28
    116c:	00 d0       	rcall	.+0      	; 0x116e <pvPortMalloc+0x6>
    116e:	00 d0       	rcall	.+0      	; 0x1170 <pvPortMalloc+0x8>
    1170:	cd b7       	in	r28, 0x3d	; 61
    1172:	de b7       	in	r29, 0x3e	; 62
    1174:	9c 83       	std	Y+4, r25	; 0x04
    1176:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    1178:	1a 82       	std	Y+2, r1	; 0x02
    117a:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
    117c:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1180:	80 91 47 01 	lds	r24, 0x0147
    1184:	90 91 48 01 	lds	r25, 0x0148
    1188:	00 97       	sbiw	r24, 0x00	; 0
    118a:	31 f4       	brne	.+12     	; 0x1198 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    118c:	89 e4       	ldi	r24, 0x49	; 73
    118e:	91 e0       	ldi	r25, 0x01	; 1
    1190:	90 93 48 01 	sts	0x0148, r25
    1194:	80 93 47 01 	sts	0x0147, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
    1198:	8b 81       	ldd	r24, Y+3	; 0x03
    119a:	9c 81       	ldd	r25, Y+4	; 0x04
    119c:	00 97       	sbiw	r24, 0x00	; 0
    119e:	99 f1       	breq	.+102    	; 0x1206 <pvPortMalloc+0x9e>
    11a0:	80 91 45 01 	lds	r24, 0x0145
    11a4:	90 91 46 01 	lds	r25, 0x0146
    11a8:	2b 81       	ldd	r18, Y+3	; 0x03
    11aa:	3c 81       	ldd	r19, Y+4	; 0x04
    11ac:	82 0f       	add	r24, r18
    11ae:	93 1f       	adc	r25, r19
    11b0:	22 e0       	ldi	r18, 0x02	; 2
    11b2:	8b 3b       	cpi	r24, 0xBB	; 187
    11b4:	92 07       	cpc	r25, r18
    11b6:	38 f5       	brcc	.+78     	; 0x1206 <pvPortMalloc+0x9e>
    11b8:	20 91 45 01 	lds	r18, 0x0145
    11bc:	30 91 46 01 	lds	r19, 0x0146
    11c0:	8b 81       	ldd	r24, Y+3	; 0x03
    11c2:	9c 81       	ldd	r25, Y+4	; 0x04
    11c4:	28 0f       	add	r18, r24
    11c6:	39 1f       	adc	r19, r25
    11c8:	80 91 45 01 	lds	r24, 0x0145
    11cc:	90 91 46 01 	lds	r25, 0x0146
    11d0:	82 17       	cp	r24, r18
    11d2:	93 07       	cpc	r25, r19
    11d4:	c0 f4       	brcc	.+48     	; 0x1206 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    11d6:	20 91 47 01 	lds	r18, 0x0147
    11da:	30 91 48 01 	lds	r19, 0x0148
    11de:	80 91 45 01 	lds	r24, 0x0145
    11e2:	90 91 46 01 	lds	r25, 0x0146
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	9a 83       	std	Y+2, r25	; 0x02
    11ec:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    11ee:	20 91 45 01 	lds	r18, 0x0145
    11f2:	30 91 46 01 	lds	r19, 0x0146
    11f6:	8b 81       	ldd	r24, Y+3	; 0x03
    11f8:	9c 81       	ldd	r25, Y+4	; 0x04
    11fa:	82 0f       	add	r24, r18
    11fc:	93 1f       	adc	r25, r19
    11fe:	90 93 46 01 	sts	0x0146, r25
    1202:	80 93 45 01 	sts	0x0145, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1206:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
    120a:	89 81       	ldd	r24, Y+1	; 0x01
    120c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    120e:	0f 90       	pop	r0
    1210:	0f 90       	pop	r0
    1212:	0f 90       	pop	r0
    1214:	0f 90       	pop	r0
    1216:	cf 91       	pop	r28
    1218:	df 91       	pop	r29
    121a:	08 95       	ret

0000121c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    121c:	df 93       	push	r29
    121e:	cf 93       	push	r28
    1220:	00 d0       	rcall	.+0      	; 0x1222 <vPortFree+0x6>
    1222:	cd b7       	in	r28, 0x3d	; 61
    1224:	de b7       	in	r29, 0x3e	; 62
    1226:	9a 83       	std	Y+2, r25	; 0x02
    1228:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    122a:	0f 90       	pop	r0
    122c:	0f 90       	pop	r0
    122e:	cf 91       	pop	r28
    1230:	df 91       	pop	r29
    1232:	08 95       	ret

00001234 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1234:	df 93       	push	r29
    1236:	cf 93       	push	r28
    1238:	cd b7       	in	r28, 0x3d	; 61
    123a:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    123c:	10 92 46 01 	sts	0x0146, r1
    1240:	10 92 45 01 	sts	0x0145, r1
}
    1244:	cf 91       	pop	r28
    1246:	df 91       	pop	r29
    1248:	08 95       	ret

0000124a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    124a:	df 93       	push	r29
    124c:	cf 93       	push	r28
    124e:	cd b7       	in	r28, 0x3d	; 61
    1250:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1252:	20 91 45 01 	lds	r18, 0x0145
    1256:	30 91 46 01 	lds	r19, 0x0146
    125a:	8b eb       	ldi	r24, 0xBB	; 187
    125c:	92 e0       	ldi	r25, 0x02	; 2
    125e:	82 1b       	sub	r24, r18
    1260:	93 0b       	sbc	r25, r19
}
    1262:	cf 91       	pop	r28
    1264:	df 91       	pop	r29
    1266:	08 95       	ret

00001268 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1268:	df 93       	push	r29
    126a:	cf 93       	push	r28
    126c:	cd b7       	in	r28, 0x3d	; 61
    126e:	de b7       	in	r29, 0x3e	; 62
    1270:	28 97       	sbiw	r28, 0x08	; 8
    1272:	0f b6       	in	r0, 0x3f	; 63
    1274:	f8 94       	cli
    1276:	de bf       	out	0x3e, r29	; 62
    1278:	0f be       	out	0x3f, r0	; 63
    127a:	cd bf       	out	0x3d, r28	; 61
    127c:	9c 83       	std	Y+4, r25	; 0x04
    127e:	8b 83       	std	Y+3, r24	; 0x03
    1280:	7e 83       	std	Y+6, r23	; 0x06
    1282:	6d 83       	std	Y+5, r22	; 0x05
    1284:	58 87       	std	Y+8, r21	; 0x08
    1286:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1288:	eb 81       	ldd	r30, Y+3	; 0x03
    128a:	fc 81       	ldd	r31, Y+4	; 0x04
    128c:	81 e1       	ldi	r24, 0x11	; 17
    128e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1290:	8b 81       	ldd	r24, Y+3	; 0x03
    1292:	9c 81       	ldd	r25, Y+4	; 0x04
    1294:	01 97       	sbiw	r24, 0x01	; 1
    1296:	9c 83       	std	Y+4, r25	; 0x04
    1298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    129a:	eb 81       	ldd	r30, Y+3	; 0x03
    129c:	fc 81       	ldd	r31, Y+4	; 0x04
    129e:	82 e2       	ldi	r24, 0x22	; 34
    12a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12a2:	8b 81       	ldd	r24, Y+3	; 0x03
    12a4:	9c 81       	ldd	r25, Y+4	; 0x04
    12a6:	01 97       	sbiw	r24, 0x01	; 1
    12a8:	9c 83       	std	Y+4, r25	; 0x04
    12aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    12ac:	eb 81       	ldd	r30, Y+3	; 0x03
    12ae:	fc 81       	ldd	r31, Y+4	; 0x04
    12b0:	83 e3       	ldi	r24, 0x33	; 51
    12b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12b4:	8b 81       	ldd	r24, Y+3	; 0x03
    12b6:	9c 81       	ldd	r25, Y+4	; 0x04
    12b8:	01 97       	sbiw	r24, 0x01	; 1
    12ba:	9c 83       	std	Y+4, r25	; 0x04
    12bc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    12be:	8d 81       	ldd	r24, Y+5	; 0x05
    12c0:	9e 81       	ldd	r25, Y+6	; 0x06
    12c2:	9a 83       	std	Y+2, r25	; 0x02
    12c4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    12c6:	89 81       	ldd	r24, Y+1	; 0x01
    12c8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ca:	fc 81       	ldd	r31, Y+4	; 0x04
    12cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ce:	8b 81       	ldd	r24, Y+3	; 0x03
    12d0:	9c 81       	ldd	r25, Y+4	; 0x04
    12d2:	01 97       	sbiw	r24, 0x01	; 1
    12d4:	9c 83       	std	Y+4, r25	; 0x04
    12d6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    12d8:	89 81       	ldd	r24, Y+1	; 0x01
    12da:	9a 81       	ldd	r25, Y+2	; 0x02
    12dc:	89 2f       	mov	r24, r25
    12de:	99 27       	eor	r25, r25
    12e0:	9a 83       	std	Y+2, r25	; 0x02
    12e2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    12e4:	89 81       	ldd	r24, Y+1	; 0x01
    12e6:	eb 81       	ldd	r30, Y+3	; 0x03
    12e8:	fc 81       	ldd	r31, Y+4	; 0x04
    12ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ec:	8b 81       	ldd	r24, Y+3	; 0x03
    12ee:	9c 81       	ldd	r25, Y+4	; 0x04
    12f0:	01 97       	sbiw	r24, 0x01	; 1
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    12f6:	eb 81       	ldd	r30, Y+3	; 0x03
    12f8:	fc 81       	ldd	r31, Y+4	; 0x04
    12fa:	10 82       	st	Z, r1
	pxTopOfStack--;
    12fc:	8b 81       	ldd	r24, Y+3	; 0x03
    12fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1300:	01 97       	sbiw	r24, 0x01	; 1
    1302:	9c 83       	std	Y+4, r25	; 0x04
    1304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1306:	eb 81       	ldd	r30, Y+3	; 0x03
    1308:	fc 81       	ldd	r31, Y+4	; 0x04
    130a:	80 e8       	ldi	r24, 0x80	; 128
    130c:	80 83       	st	Z, r24
	pxTopOfStack--;
    130e:	8b 81       	ldd	r24, Y+3	; 0x03
    1310:	9c 81       	ldd	r25, Y+4	; 0x04
    1312:	01 97       	sbiw	r24, 0x01	; 1
    1314:	9c 83       	std	Y+4, r25	; 0x04
    1316:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1318:	eb 81       	ldd	r30, Y+3	; 0x03
    131a:	fc 81       	ldd	r31, Y+4	; 0x04
    131c:	10 82       	st	Z, r1
	pxTopOfStack--;
    131e:	8b 81       	ldd	r24, Y+3	; 0x03
    1320:	9c 81       	ldd	r25, Y+4	; 0x04
    1322:	01 97       	sbiw	r24, 0x01	; 1
    1324:	9c 83       	std	Y+4, r25	; 0x04
    1326:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1328:	eb 81       	ldd	r30, Y+3	; 0x03
    132a:	fc 81       	ldd	r31, Y+4	; 0x04
    132c:	82 e0       	ldi	r24, 0x02	; 2
    132e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1330:	8b 81       	ldd	r24, Y+3	; 0x03
    1332:	9c 81       	ldd	r25, Y+4	; 0x04
    1334:	01 97       	sbiw	r24, 0x01	; 1
    1336:	9c 83       	std	Y+4, r25	; 0x04
    1338:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    133a:	eb 81       	ldd	r30, Y+3	; 0x03
    133c:	fc 81       	ldd	r31, Y+4	; 0x04
    133e:	83 e0       	ldi	r24, 0x03	; 3
    1340:	80 83       	st	Z, r24
	pxTopOfStack--;
    1342:	8b 81       	ldd	r24, Y+3	; 0x03
    1344:	9c 81       	ldd	r25, Y+4	; 0x04
    1346:	01 97       	sbiw	r24, 0x01	; 1
    1348:	9c 83       	std	Y+4, r25	; 0x04
    134a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    134c:	eb 81       	ldd	r30, Y+3	; 0x03
    134e:	fc 81       	ldd	r31, Y+4	; 0x04
    1350:	84 e0       	ldi	r24, 0x04	; 4
    1352:	80 83       	st	Z, r24
	pxTopOfStack--;
    1354:	8b 81       	ldd	r24, Y+3	; 0x03
    1356:	9c 81       	ldd	r25, Y+4	; 0x04
    1358:	01 97       	sbiw	r24, 0x01	; 1
    135a:	9c 83       	std	Y+4, r25	; 0x04
    135c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    135e:	eb 81       	ldd	r30, Y+3	; 0x03
    1360:	fc 81       	ldd	r31, Y+4	; 0x04
    1362:	85 e0       	ldi	r24, 0x05	; 5
    1364:	80 83       	st	Z, r24
	pxTopOfStack--;
    1366:	8b 81       	ldd	r24, Y+3	; 0x03
    1368:	9c 81       	ldd	r25, Y+4	; 0x04
    136a:	01 97       	sbiw	r24, 0x01	; 1
    136c:	9c 83       	std	Y+4, r25	; 0x04
    136e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1370:	eb 81       	ldd	r30, Y+3	; 0x03
    1372:	fc 81       	ldd	r31, Y+4	; 0x04
    1374:	86 e0       	ldi	r24, 0x06	; 6
    1376:	80 83       	st	Z, r24
	pxTopOfStack--;
    1378:	8b 81       	ldd	r24, Y+3	; 0x03
    137a:	9c 81       	ldd	r25, Y+4	; 0x04
    137c:	01 97       	sbiw	r24, 0x01	; 1
    137e:	9c 83       	std	Y+4, r25	; 0x04
    1380:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1382:	eb 81       	ldd	r30, Y+3	; 0x03
    1384:	fc 81       	ldd	r31, Y+4	; 0x04
    1386:	87 e0       	ldi	r24, 0x07	; 7
    1388:	80 83       	st	Z, r24
	pxTopOfStack--;
    138a:	8b 81       	ldd	r24, Y+3	; 0x03
    138c:	9c 81       	ldd	r25, Y+4	; 0x04
    138e:	01 97       	sbiw	r24, 0x01	; 1
    1390:	9c 83       	std	Y+4, r25	; 0x04
    1392:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1394:	eb 81       	ldd	r30, Y+3	; 0x03
    1396:	fc 81       	ldd	r31, Y+4	; 0x04
    1398:	88 e0       	ldi	r24, 0x08	; 8
    139a:	80 83       	st	Z, r24
	pxTopOfStack--;
    139c:	8b 81       	ldd	r24, Y+3	; 0x03
    139e:	9c 81       	ldd	r25, Y+4	; 0x04
    13a0:	01 97       	sbiw	r24, 0x01	; 1
    13a2:	9c 83       	std	Y+4, r25	; 0x04
    13a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    13a6:	eb 81       	ldd	r30, Y+3	; 0x03
    13a8:	fc 81       	ldd	r31, Y+4	; 0x04
    13aa:	89 e0       	ldi	r24, 0x09	; 9
    13ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	9c 81       	ldd	r25, Y+4	; 0x04
    13b2:	01 97       	sbiw	r24, 0x01	; 1
    13b4:	9c 83       	std	Y+4, r25	; 0x04
    13b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    13b8:	eb 81       	ldd	r30, Y+3	; 0x03
    13ba:	fc 81       	ldd	r31, Y+4	; 0x04
    13bc:	80 e1       	ldi	r24, 0x10	; 16
    13be:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c0:	8b 81       	ldd	r24, Y+3	; 0x03
    13c2:	9c 81       	ldd	r25, Y+4	; 0x04
    13c4:	01 97       	sbiw	r24, 0x01	; 1
    13c6:	9c 83       	std	Y+4, r25	; 0x04
    13c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    13ca:	eb 81       	ldd	r30, Y+3	; 0x03
    13cc:	fc 81       	ldd	r31, Y+4	; 0x04
    13ce:	81 e1       	ldi	r24, 0x11	; 17
    13d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d2:	8b 81       	ldd	r24, Y+3	; 0x03
    13d4:	9c 81       	ldd	r25, Y+4	; 0x04
    13d6:	01 97       	sbiw	r24, 0x01	; 1
    13d8:	9c 83       	std	Y+4, r25	; 0x04
    13da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    13dc:	eb 81       	ldd	r30, Y+3	; 0x03
    13de:	fc 81       	ldd	r31, Y+4	; 0x04
    13e0:	82 e1       	ldi	r24, 0x12	; 18
    13e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e4:	8b 81       	ldd	r24, Y+3	; 0x03
    13e6:	9c 81       	ldd	r25, Y+4	; 0x04
    13e8:	01 97       	sbiw	r24, 0x01	; 1
    13ea:	9c 83       	std	Y+4, r25	; 0x04
    13ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    13ee:	eb 81       	ldd	r30, Y+3	; 0x03
    13f0:	fc 81       	ldd	r31, Y+4	; 0x04
    13f2:	83 e1       	ldi	r24, 0x13	; 19
    13f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f6:	8b 81       	ldd	r24, Y+3	; 0x03
    13f8:	9c 81       	ldd	r25, Y+4	; 0x04
    13fa:	01 97       	sbiw	r24, 0x01	; 1
    13fc:	9c 83       	std	Y+4, r25	; 0x04
    13fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1400:	eb 81       	ldd	r30, Y+3	; 0x03
    1402:	fc 81       	ldd	r31, Y+4	; 0x04
    1404:	84 e1       	ldi	r24, 0x14	; 20
    1406:	80 83       	st	Z, r24
	pxTopOfStack--;
    1408:	8b 81       	ldd	r24, Y+3	; 0x03
    140a:	9c 81       	ldd	r25, Y+4	; 0x04
    140c:	01 97       	sbiw	r24, 0x01	; 1
    140e:	9c 83       	std	Y+4, r25	; 0x04
    1410:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1412:	eb 81       	ldd	r30, Y+3	; 0x03
    1414:	fc 81       	ldd	r31, Y+4	; 0x04
    1416:	85 e1       	ldi	r24, 0x15	; 21
    1418:	80 83       	st	Z, r24
	pxTopOfStack--;
    141a:	8b 81       	ldd	r24, Y+3	; 0x03
    141c:	9c 81       	ldd	r25, Y+4	; 0x04
    141e:	01 97       	sbiw	r24, 0x01	; 1
    1420:	9c 83       	std	Y+4, r25	; 0x04
    1422:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1424:	eb 81       	ldd	r30, Y+3	; 0x03
    1426:	fc 81       	ldd	r31, Y+4	; 0x04
    1428:	86 e1       	ldi	r24, 0x16	; 22
    142a:	80 83       	st	Z, r24
	pxTopOfStack--;
    142c:	8b 81       	ldd	r24, Y+3	; 0x03
    142e:	9c 81       	ldd	r25, Y+4	; 0x04
    1430:	01 97       	sbiw	r24, 0x01	; 1
    1432:	9c 83       	std	Y+4, r25	; 0x04
    1434:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1436:	eb 81       	ldd	r30, Y+3	; 0x03
    1438:	fc 81       	ldd	r31, Y+4	; 0x04
    143a:	87 e1       	ldi	r24, 0x17	; 23
    143c:	80 83       	st	Z, r24
	pxTopOfStack--;
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	9c 81       	ldd	r25, Y+4	; 0x04
    1442:	01 97       	sbiw	r24, 0x01	; 1
    1444:	9c 83       	std	Y+4, r25	; 0x04
    1446:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1448:	eb 81       	ldd	r30, Y+3	; 0x03
    144a:	fc 81       	ldd	r31, Y+4	; 0x04
    144c:	88 e1       	ldi	r24, 0x18	; 24
    144e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1450:	8b 81       	ldd	r24, Y+3	; 0x03
    1452:	9c 81       	ldd	r25, Y+4	; 0x04
    1454:	01 97       	sbiw	r24, 0x01	; 1
    1456:	9c 83       	std	Y+4, r25	; 0x04
    1458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    145a:	eb 81       	ldd	r30, Y+3	; 0x03
    145c:	fc 81       	ldd	r31, Y+4	; 0x04
    145e:	89 e1       	ldi	r24, 0x19	; 25
    1460:	80 83       	st	Z, r24
	pxTopOfStack--;
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	01 97       	sbiw	r24, 0x01	; 1
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    146c:	eb 81       	ldd	r30, Y+3	; 0x03
    146e:	fc 81       	ldd	r31, Y+4	; 0x04
    1470:	80 e2       	ldi	r24, 0x20	; 32
    1472:	80 83       	st	Z, r24
	pxTopOfStack--;
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	9c 83       	std	Y+4, r25	; 0x04
    147c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    147e:	eb 81       	ldd	r30, Y+3	; 0x03
    1480:	fc 81       	ldd	r31, Y+4	; 0x04
    1482:	81 e2       	ldi	r24, 0x21	; 33
    1484:	80 83       	st	Z, r24
	pxTopOfStack--;
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	01 97       	sbiw	r24, 0x01	; 1
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	82 e2       	ldi	r24, 0x22	; 34
    1496:	80 83       	st	Z, r24
	pxTopOfStack--;
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
    149c:	01 97       	sbiw	r24, 0x01	; 1
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    14a2:	eb 81       	ldd	r30, Y+3	; 0x03
    14a4:	fc 81       	ldd	r31, Y+4	; 0x04
    14a6:	83 e2       	ldi	r24, 0x23	; 35
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    14b4:	8f 81       	ldd	r24, Y+7	; 0x07
    14b6:	98 85       	ldd	r25, Y+8	; 0x08
    14b8:	9a 83       	std	Y+2, r25	; 0x02
    14ba:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14bc:	89 81       	ldd	r24, Y+1	; 0x01
    14be:	eb 81       	ldd	r30, Y+3	; 0x03
    14c0:	fc 81       	ldd	r31, Y+4	; 0x04
    14c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14c4:	8b 81       	ldd	r24, Y+3	; 0x03
    14c6:	9c 81       	ldd	r25, Y+4	; 0x04
    14c8:	01 97       	sbiw	r24, 0x01	; 1
    14ca:	9c 83       	std	Y+4, r25	; 0x04
    14cc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
    14d0:	9a 81       	ldd	r25, Y+2	; 0x02
    14d2:	89 2f       	mov	r24, r25
    14d4:	99 27       	eor	r25, r25
    14d6:	9a 83       	std	Y+2, r25	; 0x02
    14d8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14da:	89 81       	ldd	r24, Y+1	; 0x01
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e2:	8b 81       	ldd	r24, Y+3	; 0x03
    14e4:	9c 81       	ldd	r25, Y+4	; 0x04
    14e6:	01 97       	sbiw	r24, 0x01	; 1
    14e8:	9c 83       	std	Y+4, r25	; 0x04
    14ea:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    14ec:	eb 81       	ldd	r30, Y+3	; 0x03
    14ee:	fc 81       	ldd	r31, Y+4	; 0x04
    14f0:	86 e2       	ldi	r24, 0x26	; 38
    14f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f4:	8b 81       	ldd	r24, Y+3	; 0x03
    14f6:	9c 81       	ldd	r25, Y+4	; 0x04
    14f8:	01 97       	sbiw	r24, 0x01	; 1
    14fa:	9c 83       	std	Y+4, r25	; 0x04
    14fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    14fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1500:	fc 81       	ldd	r31, Y+4	; 0x04
    1502:	87 e2       	ldi	r24, 0x27	; 39
    1504:	80 83       	st	Z, r24
	pxTopOfStack--;
    1506:	8b 81       	ldd	r24, Y+3	; 0x03
    1508:	9c 81       	ldd	r25, Y+4	; 0x04
    150a:	01 97       	sbiw	r24, 0x01	; 1
    150c:	9c 83       	std	Y+4, r25	; 0x04
    150e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1510:	eb 81       	ldd	r30, Y+3	; 0x03
    1512:	fc 81       	ldd	r31, Y+4	; 0x04
    1514:	88 e2       	ldi	r24, 0x28	; 40
    1516:	80 83       	st	Z, r24
	pxTopOfStack--;
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	9c 81       	ldd	r25, Y+4	; 0x04
    151c:	01 97       	sbiw	r24, 0x01	; 1
    151e:	9c 83       	std	Y+4, r25	; 0x04
    1520:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1522:	eb 81       	ldd	r30, Y+3	; 0x03
    1524:	fc 81       	ldd	r31, Y+4	; 0x04
    1526:	89 e2       	ldi	r24, 0x29	; 41
    1528:	80 83       	st	Z, r24
	pxTopOfStack--;
    152a:	8b 81       	ldd	r24, Y+3	; 0x03
    152c:	9c 81       	ldd	r25, Y+4	; 0x04
    152e:	01 97       	sbiw	r24, 0x01	; 1
    1530:	9c 83       	std	Y+4, r25	; 0x04
    1532:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	80 e3       	ldi	r24, 0x30	; 48
    153a:	80 83       	st	Z, r24
	pxTopOfStack--;
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	01 97       	sbiw	r24, 0x01	; 1
    1542:	9c 83       	std	Y+4, r25	; 0x04
    1544:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1546:	eb 81       	ldd	r30, Y+3	; 0x03
    1548:	fc 81       	ldd	r31, Y+4	; 0x04
    154a:	81 e3       	ldi	r24, 0x31	; 49
    154c:	80 83       	st	Z, r24
	pxTopOfStack--;
    154e:	8b 81       	ldd	r24, Y+3	; 0x03
    1550:	9c 81       	ldd	r25, Y+4	; 0x04
    1552:	01 97       	sbiw	r24, 0x01	; 1
    1554:	9c 83       	std	Y+4, r25	; 0x04
    1556:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1558:	8b 81       	ldd	r24, Y+3	; 0x03
    155a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    155c:	28 96       	adiw	r28, 0x08	; 8
    155e:	0f b6       	in	r0, 0x3f	; 63
    1560:	f8 94       	cli
    1562:	de bf       	out	0x3e, r29	; 62
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	cd bf       	out	0x3d, r28	; 61
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	08 95       	ret

0000156e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    156e:	df 93       	push	r29
    1570:	cf 93       	push	r28
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1576:	0e 94 a9 0b 	call	0x1752	; 0x1752 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    157a:	a0 91 3f 04 	lds	r26, 0x043F
    157e:	b0 91 40 04 	lds	r27, 0x0440
    1582:	cd 91       	ld	r28, X+
    1584:	cd bf       	out	0x3d, r28	; 61
    1586:	dd 91       	ld	r29, X+
    1588:	de bf       	out	0x3e, r29	; 62
    158a:	ff 91       	pop	r31
    158c:	ef 91       	pop	r30
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	bf 91       	pop	r27
    1594:	af 91       	pop	r26
    1596:	9f 91       	pop	r25
    1598:	8f 91       	pop	r24
    159a:	7f 91       	pop	r23
    159c:	6f 91       	pop	r22
    159e:	5f 91       	pop	r21
    15a0:	4f 91       	pop	r20
    15a2:	3f 91       	pop	r19
    15a4:	2f 91       	pop	r18
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	ff 90       	pop	r15
    15ac:	ef 90       	pop	r14
    15ae:	df 90       	pop	r13
    15b0:	cf 90       	pop	r12
    15b2:	bf 90       	pop	r11
    15b4:	af 90       	pop	r10
    15b6:	9f 90       	pop	r9
    15b8:	8f 90       	pop	r8
    15ba:	7f 90       	pop	r7
    15bc:	6f 90       	pop	r6
    15be:	5f 90       	pop	r5
    15c0:	4f 90       	pop	r4
    15c2:	3f 90       	pop	r3
    15c4:	2f 90       	pop	r2
    15c6:	1f 90       	pop	r1
    15c8:	0f 90       	pop	r0
    15ca:	0f be       	out	0x3f, r0	; 63
    15cc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    15ce:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    15d0:	81 e0       	ldi	r24, 0x01	; 1
}
    15d2:	cf 91       	pop	r28
    15d4:	df 91       	pop	r29
    15d6:	08 95       	ret

000015d8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15d8:	df 93       	push	r29
    15da:	cf 93       	push	r28
    15dc:	cd b7       	in	r28, 0x3d	; 61
    15de:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    15e0:	cf 91       	pop	r28
    15e2:	df 91       	pop	r29
    15e4:	08 95       	ret

000015e6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    15e6:	0f 92       	push	r0
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	0f 92       	push	r0
    15ee:	1f 92       	push	r1
    15f0:	11 24       	eor	r1, r1
    15f2:	2f 92       	push	r2
    15f4:	3f 92       	push	r3
    15f6:	4f 92       	push	r4
    15f8:	5f 92       	push	r5
    15fa:	6f 92       	push	r6
    15fc:	7f 92       	push	r7
    15fe:	8f 92       	push	r8
    1600:	9f 92       	push	r9
    1602:	af 92       	push	r10
    1604:	bf 92       	push	r11
    1606:	cf 92       	push	r12
    1608:	df 92       	push	r13
    160a:	ef 92       	push	r14
    160c:	ff 92       	push	r15
    160e:	0f 93       	push	r16
    1610:	1f 93       	push	r17
    1612:	2f 93       	push	r18
    1614:	3f 93       	push	r19
    1616:	4f 93       	push	r20
    1618:	5f 93       	push	r21
    161a:	6f 93       	push	r22
    161c:	7f 93       	push	r23
    161e:	8f 93       	push	r24
    1620:	9f 93       	push	r25
    1622:	af 93       	push	r26
    1624:	bf 93       	push	r27
    1626:	cf 93       	push	r28
    1628:	df 93       	push	r29
    162a:	ef 93       	push	r30
    162c:	ff 93       	push	r31
    162e:	a0 91 3f 04 	lds	r26, 0x043F
    1632:	b0 91 40 04 	lds	r27, 0x0440
    1636:	0d b6       	in	r0, 0x3d	; 61
    1638:	0d 92       	st	X+, r0
    163a:	0e b6       	in	r0, 0x3e	; 62
    163c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    163e:	0e 94 42 22 	call	0x4484	; 0x4484 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1642:	a0 91 3f 04 	lds	r26, 0x043F
    1646:	b0 91 40 04 	lds	r27, 0x0440
    164a:	cd 91       	ld	r28, X+
    164c:	cd bf       	out	0x3d, r28	; 61
    164e:	dd 91       	ld	r29, X+
    1650:	de bf       	out	0x3e, r29	; 62
    1652:	ff 91       	pop	r31
    1654:	ef 91       	pop	r30
    1656:	df 91       	pop	r29
    1658:	cf 91       	pop	r28
    165a:	bf 91       	pop	r27
    165c:	af 91       	pop	r26
    165e:	9f 91       	pop	r25
    1660:	8f 91       	pop	r24
    1662:	7f 91       	pop	r23
    1664:	6f 91       	pop	r22
    1666:	5f 91       	pop	r21
    1668:	4f 91       	pop	r20
    166a:	3f 91       	pop	r19
    166c:	2f 91       	pop	r18
    166e:	1f 91       	pop	r17
    1670:	0f 91       	pop	r16
    1672:	ff 90       	pop	r15
    1674:	ef 90       	pop	r14
    1676:	df 90       	pop	r13
    1678:	cf 90       	pop	r12
    167a:	bf 90       	pop	r11
    167c:	af 90       	pop	r10
    167e:	9f 90       	pop	r9
    1680:	8f 90       	pop	r8
    1682:	7f 90       	pop	r7
    1684:	6f 90       	pop	r6
    1686:	5f 90       	pop	r5
    1688:	4f 90       	pop	r4
    168a:	3f 90       	pop	r3
    168c:	2f 90       	pop	r2
    168e:	1f 90       	pop	r1
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1696:	08 95       	ret

00001698 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1698:	0f 92       	push	r0
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
    16a0:	1f 92       	push	r1
    16a2:	11 24       	eor	r1, r1
    16a4:	2f 92       	push	r2
    16a6:	3f 92       	push	r3
    16a8:	4f 92       	push	r4
    16aa:	5f 92       	push	r5
    16ac:	6f 92       	push	r6
    16ae:	7f 92       	push	r7
    16b0:	8f 92       	push	r8
    16b2:	9f 92       	push	r9
    16b4:	af 92       	push	r10
    16b6:	bf 92       	push	r11
    16b8:	cf 92       	push	r12
    16ba:	df 92       	push	r13
    16bc:	ef 92       	push	r14
    16be:	ff 92       	push	r15
    16c0:	0f 93       	push	r16
    16c2:	1f 93       	push	r17
    16c4:	2f 93       	push	r18
    16c6:	3f 93       	push	r19
    16c8:	4f 93       	push	r20
    16ca:	5f 93       	push	r21
    16cc:	6f 93       	push	r22
    16ce:	7f 93       	push	r23
    16d0:	8f 93       	push	r24
    16d2:	9f 93       	push	r25
    16d4:	af 93       	push	r26
    16d6:	bf 93       	push	r27
    16d8:	cf 93       	push	r28
    16da:	df 93       	push	r29
    16dc:	ef 93       	push	r30
    16de:	ff 93       	push	r31
    16e0:	a0 91 3f 04 	lds	r26, 0x043F
    16e4:	b0 91 40 04 	lds	r27, 0x0440
    16e8:	0d b6       	in	r0, 0x3d	; 61
    16ea:	0d 92       	st	X+, r0
    16ec:	0e b6       	in	r0, 0x3e	; 62
    16ee:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    16f0:	0e 94 ab 20 	call	0x4156	; 0x4156 <xTaskIncrementTick>
    16f4:	88 23       	and	r24, r24
    16f6:	11 f0       	breq	.+4      	; 0x16fc <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    16f8:	0e 94 42 22 	call	0x4484	; 0x4484 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    16fc:	a0 91 3f 04 	lds	r26, 0x043F
    1700:	b0 91 40 04 	lds	r27, 0x0440
    1704:	cd 91       	ld	r28, X+
    1706:	cd bf       	out	0x3d, r28	; 61
    1708:	dd 91       	ld	r29, X+
    170a:	de bf       	out	0x3e, r29	; 62
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	bf 91       	pop	r27
    1716:	af 91       	pop	r26
    1718:	9f 91       	pop	r25
    171a:	8f 91       	pop	r24
    171c:	7f 91       	pop	r23
    171e:	6f 91       	pop	r22
    1720:	5f 91       	pop	r21
    1722:	4f 91       	pop	r20
    1724:	3f 91       	pop	r19
    1726:	2f 91       	pop	r18
    1728:	1f 91       	pop	r17
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	9f 90       	pop	r9
    173a:	8f 90       	pop	r8
    173c:	7f 90       	pop	r7
    173e:	6f 90       	pop	r6
    1740:	5f 90       	pop	r5
    1742:	4f 90       	pop	r4
    1744:	3f 90       	pop	r3
    1746:	2f 90       	pop	r2
    1748:	1f 90       	pop	r1
    174a:	0f 90       	pop	r0
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1750:	08 95       	ret

00001752 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1752:	df 93       	push	r29
    1754:	cf 93       	push	r28
    1756:	00 d0       	rcall	.+0      	; 0x1758 <prvSetupTimerInterrupt+0x6>
    1758:	00 d0       	rcall	.+0      	; 0x175a <prvSetupTimerInterrupt+0x8>
    175a:	00 d0       	rcall	.+0      	; 0x175c <prvSetupTimerInterrupt+0xa>
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1760:	80 e4       	ldi	r24, 0x40	; 64
    1762:	9f e1       	ldi	r25, 0x1F	; 31
    1764:	a0 e0       	ldi	r26, 0x00	; 0
    1766:	b0 e0       	ldi	r27, 0x00	; 0
    1768:	8b 83       	std	Y+3, r24	; 0x03
    176a:	9c 83       	std	Y+4, r25	; 0x04
    176c:	ad 83       	std	Y+5, r26	; 0x05
    176e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1770:	8b 81       	ldd	r24, Y+3	; 0x03
    1772:	9c 81       	ldd	r25, Y+4	; 0x04
    1774:	ad 81       	ldd	r26, Y+5	; 0x05
    1776:	be 81       	ldd	r27, Y+6	; 0x06
    1778:	68 94       	set
    177a:	15 f8       	bld	r1, 5
    177c:	b6 95       	lsr	r27
    177e:	a7 95       	ror	r26
    1780:	97 95       	ror	r25
    1782:	87 95       	ror	r24
    1784:	16 94       	lsr	r1
    1786:	d1 f7       	brne	.-12     	; 0x177c <prvSetupTimerInterrupt+0x2a>
    1788:	8b 83       	std	Y+3, r24	; 0x03
    178a:	9c 83       	std	Y+4, r25	; 0x04
    178c:	ad 83       	std	Y+5, r26	; 0x05
    178e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1790:	8b 81       	ldd	r24, Y+3	; 0x03
    1792:	9c 81       	ldd	r25, Y+4	; 0x04
    1794:	ad 81       	ldd	r26, Y+5	; 0x05
    1796:	be 81       	ldd	r27, Y+6	; 0x06
    1798:	01 97       	sbiw	r24, 0x01	; 1
    179a:	a1 09       	sbc	r26, r1
    179c:	b1 09       	sbc	r27, r1
    179e:	8b 83       	std	Y+3, r24	; 0x03
    17a0:	9c 83       	std	Y+4, r25	; 0x04
    17a2:	ad 83       	std	Y+5, r26	; 0x05
    17a4:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    17a6:	8b 81       	ldd	r24, Y+3	; 0x03
    17a8:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    17aa:	8b 81       	ldd	r24, Y+3	; 0x03
    17ac:	9c 81       	ldd	r25, Y+4	; 0x04
    17ae:	ad 81       	ldd	r26, Y+5	; 0x05
    17b0:	be 81       	ldd	r27, Y+6	; 0x06
    17b2:	89 2f       	mov	r24, r25
    17b4:	9a 2f       	mov	r25, r26
    17b6:	ab 2f       	mov	r26, r27
    17b8:	bb 27       	eor	r27, r27
    17ba:	8b 83       	std	Y+3, r24	; 0x03
    17bc:	9c 83       	std	Y+4, r25	; 0x04
    17be:	ad 83       	std	Y+5, r26	; 0x05
    17c0:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    17c2:	8b 81       	ldd	r24, Y+3	; 0x03
    17c4:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    17c6:	eb e4       	ldi	r30, 0x4B	; 75
    17c8:	f0 e0       	ldi	r31, 0x00	; 0
    17ca:	8a 81       	ldd	r24, Y+2	; 0x02
    17cc:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    17ce:	ea e4       	ldi	r30, 0x4A	; 74
    17d0:	f0 e0       	ldi	r31, 0x00	; 0
    17d2:	89 81       	ldd	r24, Y+1	; 0x01
    17d4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    17d6:	8b e0       	ldi	r24, 0x0B	; 11
    17d8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    17da:	ee e4       	ldi	r30, 0x4E	; 78
    17dc:	f0 e0       	ldi	r31, 0x00	; 0
    17de:	89 81       	ldd	r24, Y+1	; 0x01
    17e0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    17e2:	e9 e5       	ldi	r30, 0x59	; 89
    17e4:	f0 e0       	ldi	r31, 0x00	; 0
    17e6:	80 81       	ld	r24, Z
    17e8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    17ea:	89 81       	ldd	r24, Y+1	; 0x01
    17ec:	80 61       	ori	r24, 0x10	; 16
    17ee:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    17f0:	e9 e5       	ldi	r30, 0x59	; 89
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	80 83       	st	Z, r24
}
    17f8:	26 96       	adiw	r28, 0x06	; 6
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
    1804:	cf 91       	pop	r28
    1806:	df 91       	pop	r29
    1808:	08 95       	ret

0000180a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    180a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vPortYieldFromTick>
		asm volatile ( "reti" );
    180e:	18 95       	reti

00001810 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	27 97       	sbiw	r28, 0x07	; 7
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	cd bf       	out	0x3d, r28	; 61
    1824:	9d 83       	std	Y+5, r25	; 0x05
    1826:	8c 83       	std	Y+4, r24	; 0x04
    1828:	6e 83       	std	Y+6, r22	; 0x06
    182a:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    182c:	8a e1       	ldi	r24, 0x1A	; 26
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	0e 94 b4 08 	call	0x1168	; 0x1168 <pvPortMalloc>
    1834:	9a 83       	std	Y+2, r25	; 0x02
    1836:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    1838:	89 81       	ldd	r24, Y+1	; 0x01
    183a:	9a 81       	ldd	r25, Y+2	; 0x02
    183c:	00 97       	sbiw	r24, 0x00	; 0
    183e:	09 f4       	brne	.+2      	; 0x1842 <xCoRoutineCreate+0x32>
    1840:	6f c0       	rjmp	.+222    	; 0x1920 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    1842:	80 91 09 04 	lds	r24, 0x0409
    1846:	90 91 0a 04 	lds	r25, 0x040A
    184a:	00 97       	sbiw	r24, 0x00	; 0
    184c:	41 f4       	brne	.+16     	; 0x185e <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    184e:	89 81       	ldd	r24, Y+1	; 0x01
    1850:	9a 81       	ldd	r25, Y+2	; 0x02
    1852:	90 93 0a 04 	sts	0x040A, r25
    1856:	80 93 09 04 	sts	0x0409, r24
                prvInitialiseCoRoutineLists();
    185a:	0e 94 76 0e 	call	0x1cec	; 0x1cec <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    185e:	8e 81       	ldd	r24, Y+6	; 0x06
    1860:	82 30       	cpi	r24, 0x02	; 2
    1862:	10 f0       	brcs	.+4      	; 0x1868 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1864:	81 e0       	ldi	r24, 0x01	; 1
    1866:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    1868:	e9 81       	ldd	r30, Y+1	; 0x01
    186a:	fa 81       	ldd	r31, Y+2	; 0x02
    186c:	11 8e       	std	Z+25, r1	; 0x19
    186e:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    1870:	e9 81       	ldd	r30, Y+1	; 0x01
    1872:	fa 81       	ldd	r31, Y+2	; 0x02
    1874:	8e 81       	ldd	r24, Y+6	; 0x06
    1876:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    1878:	e9 81       	ldd	r30, Y+1	; 0x01
    187a:	fa 81       	ldd	r31, Y+2	; 0x02
    187c:	8f 81       	ldd	r24, Y+7	; 0x07
    187e:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1880:	e9 81       	ldd	r30, Y+1	; 0x01
    1882:	fa 81       	ldd	r31, Y+2	; 0x02
    1884:	8c 81       	ldd	r24, Y+4	; 0x04
    1886:	9d 81       	ldd	r25, Y+5	; 0x05
    1888:	91 83       	std	Z+1, r25	; 0x01
    188a:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    188c:	89 81       	ldd	r24, Y+1	; 0x01
    188e:	9a 81       	ldd	r25, Y+2	; 0x02
    1890:	02 96       	adiw	r24, 0x02	; 2
    1892:	0e 94 56 12 	call	0x24ac	; 0x24ac <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1896:	89 81       	ldd	r24, Y+1	; 0x01
    1898:	9a 81       	ldd	r25, Y+2	; 0x02
    189a:	0c 96       	adiw	r24, 0x0c	; 12
    189c:	0e 94 56 12 	call	0x24ac	; 0x24ac <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    18a0:	e9 81       	ldd	r30, Y+1	; 0x01
    18a2:	fa 81       	ldd	r31, Y+2	; 0x02
    18a4:	89 81       	ldd	r24, Y+1	; 0x01
    18a6:	9a 81       	ldd	r25, Y+2	; 0x02
    18a8:	91 87       	std	Z+9, r25	; 0x09
    18aa:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    18ac:	e9 81       	ldd	r30, Y+1	; 0x01
    18ae:	fa 81       	ldd	r31, Y+2	; 0x02
    18b0:	89 81       	ldd	r24, Y+1	; 0x01
    18b2:	9a 81       	ldd	r25, Y+2	; 0x02
    18b4:	93 8b       	std	Z+19, r25	; 0x13
    18b6:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    18b8:	8e 81       	ldd	r24, Y+6	; 0x06
    18ba:	28 2f       	mov	r18, r24
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	82 e0       	ldi	r24, 0x02	; 2
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	82 1b       	sub	r24, r18
    18c4:	93 0b       	sbc	r25, r19
    18c6:	e9 81       	ldd	r30, Y+1	; 0x01
    18c8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ca:	95 87       	std	Z+13, r25	; 0x0d
    18cc:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    18ce:	e9 81       	ldd	r30, Y+1	; 0x01
    18d0:	fa 81       	ldd	r31, Y+2	; 0x02
    18d2:	96 89       	ldd	r25, Z+22	; 0x16
    18d4:	80 91 0b 04 	lds	r24, 0x040B
    18d8:	89 17       	cp	r24, r25
    18da:	28 f4       	brcc	.+10     	; 0x18e6 <xCoRoutineCreate+0xd6>
    18dc:	e9 81       	ldd	r30, Y+1	; 0x01
    18de:	fa 81       	ldd	r31, Y+2	; 0x02
    18e0:	86 89       	ldd	r24, Z+22	; 0x16
    18e2:	80 93 0b 04 	sts	0x040B, r24
    18e6:	e9 81       	ldd	r30, Y+1	; 0x01
    18e8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ea:	86 89       	ldd	r24, Z+22	; 0x16
    18ec:	28 2f       	mov	r18, r24
    18ee:	30 e0       	ldi	r19, 0x00	; 0
    18f0:	c9 01       	movw	r24, r18
    18f2:	88 0f       	add	r24, r24
    18f4:	99 1f       	adc	r25, r25
    18f6:	88 0f       	add	r24, r24
    18f8:	99 1f       	adc	r25, r25
    18fa:	88 0f       	add	r24, r24
    18fc:	99 1f       	adc	r25, r25
    18fe:	82 0f       	add	r24, r18
    1900:	93 1f       	adc	r25, r19
    1902:	ac 01       	movw	r20, r24
    1904:	4e 5e       	subi	r20, 0xEE	; 238
    1906:	5b 4f       	sbci	r21, 0xFB	; 251
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	9a 81       	ldd	r25, Y+2	; 0x02
    190c:	9c 01       	movw	r18, r24
    190e:	2e 5f       	subi	r18, 0xFE	; 254
    1910:	3f 4f       	sbci	r19, 0xFF	; 255
    1912:	ca 01       	movw	r24, r20
    1914:	b9 01       	movw	r22, r18
    1916:	0e 94 66 12 	call	0x24cc	; 0x24cc <vListInsertEnd>

            xReturn = pdPASS;
    191a:	81 e0       	ldi	r24, 0x01	; 1
    191c:	8b 83       	std	Y+3, r24	; 0x03
    191e:	02 c0       	rjmp	.+4      	; 0x1924 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1920:	8f ef       	ldi	r24, 0xFF	; 255
    1922:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1924:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1926:	27 96       	adiw	r28, 0x07	; 7
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	de bf       	out	0x3e, r29	; 62
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	cd bf       	out	0x3d, r28	; 61
    1932:	cf 91       	pop	r28
    1934:	df 91       	pop	r29
    1936:	08 95       	ret

00001938 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    1938:	df 93       	push	r29
    193a:	cf 93       	push	r28
    193c:	00 d0       	rcall	.+0      	; 0x193e <vCoRoutineAddToDelayedList+0x6>
    193e:	00 d0       	rcall	.+0      	; 0x1940 <vCoRoutineAddToDelayedList+0x8>
    1940:	00 d0       	rcall	.+0      	; 0x1942 <vCoRoutineAddToDelayedList+0xa>
    1942:	cd b7       	in	r28, 0x3d	; 61
    1944:	de b7       	in	r29, 0x3e	; 62
    1946:	9c 83       	std	Y+4, r25	; 0x04
    1948:	8b 83       	std	Y+3, r24	; 0x03
    194a:	7e 83       	std	Y+6, r23	; 0x06
    194c:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    194e:	20 91 0c 04 	lds	r18, 0x040C
    1952:	30 91 0d 04 	lds	r19, 0x040D
    1956:	8b 81       	ldd	r24, Y+3	; 0x03
    1958:	9c 81       	ldd	r25, Y+4	; 0x04
    195a:	82 0f       	add	r24, r18
    195c:	93 1f       	adc	r25, r19
    195e:	9a 83       	std	Y+2, r25	; 0x02
    1960:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1962:	80 91 09 04 	lds	r24, 0x0409
    1966:	90 91 0a 04 	lds	r25, 0x040A
    196a:	02 96       	adiw	r24, 0x02	; 2
    196c:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1970:	e0 91 09 04 	lds	r30, 0x0409
    1974:	f0 91 0a 04 	lds	r31, 0x040A
    1978:	89 81       	ldd	r24, Y+1	; 0x01
    197a:	9a 81       	ldd	r25, Y+2	; 0x02
    197c:	93 83       	std	Z+3, r25	; 0x03
    197e:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    1980:	20 91 0c 04 	lds	r18, 0x040C
    1984:	30 91 0d 04 	lds	r19, 0x040D
    1988:	89 81       	ldd	r24, Y+1	; 0x01
    198a:	9a 81       	ldd	r25, Y+2	; 0x02
    198c:	82 17       	cp	r24, r18
    198e:	93 07       	cpc	r25, r19
    1990:	70 f4       	brcc	.+28     	; 0x19ae <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1992:	80 91 07 04 	lds	r24, 0x0407
    1996:	90 91 08 04 	lds	r25, 0x0408
    199a:	20 91 09 04 	lds	r18, 0x0409
    199e:	30 91 0a 04 	lds	r19, 0x040A
    19a2:	2e 5f       	subi	r18, 0xFE	; 254
    19a4:	3f 4f       	sbci	r19, 0xFF	; 255
    19a6:	b9 01       	movw	r22, r18
    19a8:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>
    19ac:	0d c0       	rjmp	.+26     	; 0x19c8 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    19ae:	80 91 05 04 	lds	r24, 0x0405
    19b2:	90 91 06 04 	lds	r25, 0x0406
    19b6:	20 91 09 04 	lds	r18, 0x0409
    19ba:	30 91 0a 04 	lds	r19, 0x040A
    19be:	2e 5f       	subi	r18, 0xFE	; 254
    19c0:	3f 4f       	sbci	r19, 0xFF	; 255
    19c2:	b9 01       	movw	r22, r18
    19c4:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>
        }

        if( pxEventList )
    19c8:	8d 81       	ldd	r24, Y+5	; 0x05
    19ca:	9e 81       	ldd	r25, Y+6	; 0x06
    19cc:	00 97       	sbiw	r24, 0x00	; 0
    19ce:	61 f0       	breq	.+24     	; 0x19e8 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    19d0:	80 91 09 04 	lds	r24, 0x0409
    19d4:	90 91 0a 04 	lds	r25, 0x040A
    19d8:	9c 01       	movw	r18, r24
    19da:	24 5f       	subi	r18, 0xF4	; 244
    19dc:	3f 4f       	sbci	r19, 0xFF	; 255
    19de:	8d 81       	ldd	r24, Y+5	; 0x05
    19e0:	9e 81       	ldd	r25, Y+6	; 0x06
    19e2:	b9 01       	movw	r22, r18
    19e4:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>
        }
    }
    19e8:	26 96       	adiw	r28, 0x06	; 6
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	f8 94       	cli
    19ee:	de bf       	out	0x3e, r29	; 62
    19f0:	0f be       	out	0x3f, r0	; 63
    19f2:	cd bf       	out	0x3d, r28	; 61
    19f4:	cf 91       	pop	r28
    19f6:	df 91       	pop	r29
    19f8:	08 95       	ret

000019fa <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    19fa:	df 93       	push	r29
    19fc:	cf 93       	push	r28
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <prvCheckPendingReadyList+0x6>
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
    1a04:	3a c0       	rjmp	.+116    	; 0x1a7a <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    1a06:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    1a08:	e0 91 3b 04 	lds	r30, 0x043B
    1a0c:	f0 91 3c 04 	lds	r31, 0x043C
    1a10:	86 81       	ldd	r24, Z+6	; 0x06
    1a12:	97 81       	ldd	r25, Z+7	; 0x07
    1a14:	9a 83       	std	Y+2, r25	; 0x02
    1a16:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a1c:	0c 96       	adiw	r24, 0x0c	; 12
    1a1e:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1a22:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	02 96       	adiw	r24, 0x02	; 2
    1a2a:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1a2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a30:	fa 81       	ldd	r31, Y+2	; 0x02
    1a32:	96 89       	ldd	r25, Z+22	; 0x16
    1a34:	80 91 0b 04 	lds	r24, 0x040B
    1a38:	89 17       	cp	r24, r25
    1a3a:	28 f4       	brcc	.+10     	; 0x1a46 <prvCheckPendingReadyList+0x4c>
    1a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a40:	86 89       	ldd	r24, Z+22	; 0x16
    1a42:	80 93 0b 04 	sts	0x040B, r24
    1a46:	e9 81       	ldd	r30, Y+1	; 0x01
    1a48:	fa 81       	ldd	r31, Y+2	; 0x02
    1a4a:	86 89       	ldd	r24, Z+22	; 0x16
    1a4c:	28 2f       	mov	r18, r24
    1a4e:	30 e0       	ldi	r19, 0x00	; 0
    1a50:	c9 01       	movw	r24, r18
    1a52:	88 0f       	add	r24, r24
    1a54:	99 1f       	adc	r25, r25
    1a56:	88 0f       	add	r24, r24
    1a58:	99 1f       	adc	r25, r25
    1a5a:	88 0f       	add	r24, r24
    1a5c:	99 1f       	adc	r25, r25
    1a5e:	82 0f       	add	r24, r18
    1a60:	93 1f       	adc	r25, r19
    1a62:	ac 01       	movw	r20, r24
    1a64:	4e 5e       	subi	r20, 0xEE	; 238
    1a66:	5b 4f       	sbci	r21, 0xFB	; 251
    1a68:	89 81       	ldd	r24, Y+1	; 0x01
    1a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a6c:	9c 01       	movw	r18, r24
    1a6e:	2e 5f       	subi	r18, 0xFE	; 254
    1a70:	3f 4f       	sbci	r19, 0xFF	; 255
    1a72:	ca 01       	movw	r24, r20
    1a74:	b9 01       	movw	r22, r18
    1a76:	0e 94 66 12 	call	0x24cc	; 0x24cc <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1a7a:	80 91 36 04 	lds	r24, 0x0436
    1a7e:	88 23       	and	r24, r24
    1a80:	09 f0       	breq	.+2      	; 0x1a84 <prvCheckPendingReadyList+0x8a>
    1a82:	c1 cf       	rjmp	.-126    	; 0x1a06 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	cf 91       	pop	r28
    1a8a:	df 91       	pop	r29
    1a8c:	08 95       	ret

00001a8e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1a8e:	df 93       	push	r29
    1a90:	cf 93       	push	r28
    1a92:	00 d0       	rcall	.+0      	; 0x1a94 <prvCheckDelayedList+0x6>
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <prvCheckDelayedList+0x8>
    1a96:	cd b7       	in	r28, 0x3d	; 61
    1a98:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1a9a:	0e 94 2e 20 	call	0x405c	; 0x405c <xTaskGetTickCount>
    1a9e:	20 91 0e 04 	lds	r18, 0x040E
    1aa2:	30 91 0f 04 	lds	r19, 0x040F
    1aa6:	82 1b       	sub	r24, r18
    1aa8:	93 0b       	sbc	r25, r19
    1aaa:	90 93 11 04 	sts	0x0411, r25
    1aae:	80 93 10 04 	sts	0x0410, r24
    1ab2:	85 c0       	rjmp	.+266    	; 0x1bbe <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    1ab4:	80 91 0c 04 	lds	r24, 0x040C
    1ab8:	90 91 0d 04 	lds	r25, 0x040D
    1abc:	01 96       	adiw	r24, 0x01	; 1
    1abe:	90 93 0d 04 	sts	0x040D, r25
    1ac2:	80 93 0c 04 	sts	0x040C, r24
            xPassedTicks--;
    1ac6:	80 91 10 04 	lds	r24, 0x0410
    1aca:	90 91 11 04 	lds	r25, 0x0411
    1ace:	01 97       	sbiw	r24, 0x01	; 1
    1ad0:	90 93 11 04 	sts	0x0411, r25
    1ad4:	80 93 10 04 	sts	0x0410, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    1ad8:	80 91 0c 04 	lds	r24, 0x040C
    1adc:	90 91 0d 04 	lds	r25, 0x040D
    1ae0:	00 97       	sbiw	r24, 0x00	; 0
    1ae2:	09 f0       	breq	.+2      	; 0x1ae6 <prvCheckDelayedList+0x58>
    1ae4:	64 c0       	rjmp	.+200    	; 0x1bae <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    1ae6:	80 91 05 04 	lds	r24, 0x0405
    1aea:	90 91 06 04 	lds	r25, 0x0406
    1aee:	9a 83       	std	Y+2, r25	; 0x02
    1af0:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1af2:	80 91 07 04 	lds	r24, 0x0407
    1af6:	90 91 08 04 	lds	r25, 0x0408
    1afa:	90 93 06 04 	sts	0x0406, r25
    1afe:	80 93 05 04 	sts	0x0405, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1b02:	89 81       	ldd	r24, Y+1	; 0x01
    1b04:	9a 81       	ldd	r25, Y+2	; 0x02
    1b06:	90 93 08 04 	sts	0x0408, r25
    1b0a:	80 93 07 04 	sts	0x0407, r24
    1b0e:	4f c0       	rjmp	.+158    	; 0x1bae <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1b10:	e0 91 05 04 	lds	r30, 0x0405
    1b14:	f0 91 06 04 	lds	r31, 0x0406
    1b18:	05 80       	ldd	r0, Z+5	; 0x05
    1b1a:	f6 81       	ldd	r31, Z+6	; 0x06
    1b1c:	e0 2d       	mov	r30, r0
    1b1e:	86 81       	ldd	r24, Z+6	; 0x06
    1b20:	97 81       	ldd	r25, Z+7	; 0x07
    1b22:	9c 83       	std	Y+4, r25	; 0x04
    1b24:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1b26:	eb 81       	ldd	r30, Y+3	; 0x03
    1b28:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2a:	22 81       	ldd	r18, Z+2	; 0x02
    1b2c:	33 81       	ldd	r19, Z+3	; 0x03
    1b2e:	80 91 0c 04 	lds	r24, 0x040C
    1b32:	90 91 0d 04 	lds	r25, 0x040D
    1b36:	82 17       	cp	r24, r18
    1b38:	93 07       	cpc	r25, r19
    1b3a:	08 f4       	brcc	.+2      	; 0x1b3e <prvCheckDelayedList+0xb0>
    1b3c:	40 c0       	rjmp	.+128    	; 0x1bbe <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    1b3e:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	9c 81       	ldd	r25, Y+4	; 0x04
    1b44:	02 96       	adiw	r24, 0x02	; 2
    1b46:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b4e:	84 89       	ldd	r24, Z+20	; 0x14
    1b50:	95 89       	ldd	r25, Z+21	; 0x15
    1b52:	00 97       	sbiw	r24, 0x00	; 0
    1b54:	29 f0       	breq	.+10     	; 0x1b60 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1b56:	8b 81       	ldd	r24, Y+3	; 0x03
    1b58:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5a:	0c 96       	adiw	r24, 0x0c	; 12
    1b5c:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    1b60:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    1b62:	eb 81       	ldd	r30, Y+3	; 0x03
    1b64:	fc 81       	ldd	r31, Y+4	; 0x04
    1b66:	96 89       	ldd	r25, Z+22	; 0x16
    1b68:	80 91 0b 04 	lds	r24, 0x040B
    1b6c:	89 17       	cp	r24, r25
    1b6e:	28 f4       	brcc	.+10     	; 0x1b7a <prvCheckDelayedList+0xec>
    1b70:	eb 81       	ldd	r30, Y+3	; 0x03
    1b72:	fc 81       	ldd	r31, Y+4	; 0x04
    1b74:	86 89       	ldd	r24, Z+22	; 0x16
    1b76:	80 93 0b 04 	sts	0x040B, r24
    1b7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7e:	86 89       	ldd	r24, Z+22	; 0x16
    1b80:	28 2f       	mov	r18, r24
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	c9 01       	movw	r24, r18
    1b86:	88 0f       	add	r24, r24
    1b88:	99 1f       	adc	r25, r25
    1b8a:	88 0f       	add	r24, r24
    1b8c:	99 1f       	adc	r25, r25
    1b8e:	88 0f       	add	r24, r24
    1b90:	99 1f       	adc	r25, r25
    1b92:	82 0f       	add	r24, r18
    1b94:	93 1f       	adc	r25, r19
    1b96:	ac 01       	movw	r20, r24
    1b98:	4e 5e       	subi	r20, 0xEE	; 238
    1b9a:	5b 4f       	sbci	r21, 0xFB	; 251
    1b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba0:	9c 01       	movw	r18, r24
    1ba2:	2e 5f       	subi	r18, 0xFE	; 254
    1ba4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ba6:	ca 01       	movw	r24, r20
    1ba8:	b9 01       	movw	r22, r18
    1baa:	0e 94 66 12 	call	0x24cc	; 0x24cc <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1bae:	e0 91 05 04 	lds	r30, 0x0405
    1bb2:	f0 91 06 04 	lds	r31, 0x0406
    1bb6:	80 81       	ld	r24, Z
    1bb8:	88 23       	and	r24, r24
    1bba:	09 f0       	breq	.+2      	; 0x1bbe <prvCheckDelayedList+0x130>
    1bbc:	a9 cf       	rjmp	.-174    	; 0x1b10 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    1bbe:	80 91 10 04 	lds	r24, 0x0410
    1bc2:	90 91 11 04 	lds	r25, 0x0411
    1bc6:	00 97       	sbiw	r24, 0x00	; 0
    1bc8:	09 f0       	breq	.+2      	; 0x1bcc <prvCheckDelayedList+0x13e>
    1bca:	74 cf       	rjmp	.-280    	; 0x1ab4 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    1bcc:	80 91 0c 04 	lds	r24, 0x040C
    1bd0:	90 91 0d 04 	lds	r25, 0x040D
    1bd4:	90 93 0f 04 	sts	0x040F, r25
    1bd8:	80 93 0e 04 	sts	0x040E, r24
    }
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	cf 91       	pop	r28
    1be6:	df 91       	pop	r29
    1be8:	08 95       	ret

00001bea <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    1bea:	df 93       	push	r29
    1bec:	cf 93       	push	r28
    1bee:	00 d0       	rcall	.+0      	; 0x1bf0 <vCoRoutineSchedule+0x6>
    1bf0:	cd b7       	in	r28, 0x3d	; 61
    1bf2:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    1bf4:	80 91 05 04 	lds	r24, 0x0405
    1bf8:	90 91 06 04 	lds	r25, 0x0406
    1bfc:	00 97       	sbiw	r24, 0x00	; 0
    1bfe:	09 f4       	brne	.+2      	; 0x1c02 <vCoRoutineSchedule+0x18>
    1c00:	70 c0       	rjmp	.+224    	; 0x1ce2 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1c02:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    1c06:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <prvCheckDelayedList>
    1c0a:	0a c0       	rjmp	.+20     	; 0x1c20 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    1c0c:	80 91 0b 04 	lds	r24, 0x040B
    1c10:	88 23       	and	r24, r24
    1c12:	09 f4       	brne	.+2      	; 0x1c16 <vCoRoutineSchedule+0x2c>
    1c14:	66 c0       	rjmp	.+204    	; 0x1ce2 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    1c16:	80 91 0b 04 	lds	r24, 0x040B
    1c1a:	81 50       	subi	r24, 0x01	; 1
    1c1c:	80 93 0b 04 	sts	0x040B, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1c20:	80 91 0b 04 	lds	r24, 0x040B
    1c24:	28 2f       	mov	r18, r24
    1c26:	30 e0       	ldi	r19, 0x00	; 0
    1c28:	c9 01       	movw	r24, r18
    1c2a:	88 0f       	add	r24, r24
    1c2c:	99 1f       	adc	r25, r25
    1c2e:	88 0f       	add	r24, r24
    1c30:	99 1f       	adc	r25, r25
    1c32:	88 0f       	add	r24, r24
    1c34:	99 1f       	adc	r25, r25
    1c36:	82 0f       	add	r24, r18
    1c38:	93 1f       	adc	r25, r19
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	ee 5e       	subi	r30, 0xEE	; 238
    1c3e:	fb 4f       	sbci	r31, 0xFB	; 251
    1c40:	80 81       	ld	r24, Z
    1c42:	88 23       	and	r24, r24
    1c44:	19 f3       	breq	.-58     	; 0x1c0c <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1c46:	80 91 0b 04 	lds	r24, 0x040B
    1c4a:	28 2f       	mov	r18, r24
    1c4c:	30 e0       	ldi	r19, 0x00	; 0
    1c4e:	c9 01       	movw	r24, r18
    1c50:	88 0f       	add	r24, r24
    1c52:	99 1f       	adc	r25, r25
    1c54:	88 0f       	add	r24, r24
    1c56:	99 1f       	adc	r25, r25
    1c58:	88 0f       	add	r24, r24
    1c5a:	99 1f       	adc	r25, r25
    1c5c:	82 0f       	add	r24, r18
    1c5e:	93 1f       	adc	r25, r19
    1c60:	8e 5e       	subi	r24, 0xEE	; 238
    1c62:	9b 4f       	sbci	r25, 0xFB	; 251
    1c64:	9a 83       	std	Y+2, r25	; 0x02
    1c66:	89 83       	std	Y+1, r24	; 0x01
    1c68:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6c:	01 80       	ldd	r0, Z+1	; 0x01
    1c6e:	f2 81       	ldd	r31, Z+2	; 0x02
    1c70:	e0 2d       	mov	r30, r0
    1c72:	82 81       	ldd	r24, Z+2	; 0x02
    1c74:	93 81       	ldd	r25, Z+3	; 0x03
    1c76:	e9 81       	ldd	r30, Y+1	; 0x01
    1c78:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7a:	92 83       	std	Z+2, r25	; 0x02
    1c7c:	81 83       	std	Z+1, r24	; 0x01
    1c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c80:	fa 81       	ldd	r31, Y+2	; 0x02
    1c82:	21 81       	ldd	r18, Z+1	; 0x01
    1c84:	32 81       	ldd	r19, Z+2	; 0x02
    1c86:	89 81       	ldd	r24, Y+1	; 0x01
    1c88:	9a 81       	ldd	r25, Y+2	; 0x02
    1c8a:	03 96       	adiw	r24, 0x03	; 3
    1c8c:	28 17       	cp	r18, r24
    1c8e:	39 07       	cpc	r19, r25
    1c90:	59 f4       	brne	.+22     	; 0x1ca8 <vCoRoutineSchedule+0xbe>
    1c92:	e9 81       	ldd	r30, Y+1	; 0x01
    1c94:	fa 81       	ldd	r31, Y+2	; 0x02
    1c96:	01 80       	ldd	r0, Z+1	; 0x01
    1c98:	f2 81       	ldd	r31, Z+2	; 0x02
    1c9a:	e0 2d       	mov	r30, r0
    1c9c:	82 81       	ldd	r24, Z+2	; 0x02
    1c9e:	93 81       	ldd	r25, Z+3	; 0x03
    1ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca4:	92 83       	std	Z+2, r25	; 0x02
    1ca6:	81 83       	std	Z+1, r24	; 0x01
    1ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    1caa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cac:	01 80       	ldd	r0, Z+1	; 0x01
    1cae:	f2 81       	ldd	r31, Z+2	; 0x02
    1cb0:	e0 2d       	mov	r30, r0
    1cb2:	86 81       	ldd	r24, Z+6	; 0x06
    1cb4:	97 81       	ldd	r25, Z+7	; 0x07
    1cb6:	90 93 0a 04 	sts	0x040A, r25
    1cba:	80 93 09 04 	sts	0x0409, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1cbe:	e0 91 09 04 	lds	r30, 0x0409
    1cc2:	f0 91 0a 04 	lds	r31, 0x040A
    1cc6:	40 81       	ld	r20, Z
    1cc8:	51 81       	ldd	r21, Z+1	; 0x01
    1cca:	80 91 09 04 	lds	r24, 0x0409
    1cce:	90 91 0a 04 	lds	r25, 0x040A
    1cd2:	e0 91 09 04 	lds	r30, 0x0409
    1cd6:	f0 91 0a 04 	lds	r31, 0x040A
    1cda:	27 89       	ldd	r18, Z+23	; 0x17
    1cdc:	62 2f       	mov	r22, r18
    1cde:	fa 01       	movw	r30, r20
    1ce0:	09 95       	icall
        }
    }
    1ce2:	0f 90       	pop	r0
    1ce4:	0f 90       	pop	r0
    1ce6:	cf 91       	pop	r28
    1ce8:	df 91       	pop	r29
    1cea:	08 95       	ret

00001cec <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    1cec:	df 93       	push	r29
    1cee:	cf 93       	push	r28
    1cf0:	0f 92       	push	r0
    1cf2:	cd b7       	in	r28, 0x3d	; 61
    1cf4:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1cf6:	19 82       	std	Y+1, r1	; 0x01
    1cf8:	13 c0       	rjmp	.+38     	; 0x1d20 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1cfa:	89 81       	ldd	r24, Y+1	; 0x01
    1cfc:	28 2f       	mov	r18, r24
    1cfe:	30 e0       	ldi	r19, 0x00	; 0
    1d00:	c9 01       	movw	r24, r18
    1d02:	88 0f       	add	r24, r24
    1d04:	99 1f       	adc	r25, r25
    1d06:	88 0f       	add	r24, r24
    1d08:	99 1f       	adc	r25, r25
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	82 0f       	add	r24, r18
    1d10:	93 1f       	adc	r25, r19
    1d12:	8e 5e       	subi	r24, 0xEE	; 238
    1d14:	9b 4f       	sbci	r25, 0xFB	; 251
    1d16:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1d1a:	89 81       	ldd	r24, Y+1	; 0x01
    1d1c:	8f 5f       	subi	r24, 0xFF	; 255
    1d1e:	89 83       	std	Y+1, r24	; 0x01
    1d20:	89 81       	ldd	r24, Y+1	; 0x01
    1d22:	82 30       	cpi	r24, 0x02	; 2
    1d24:	50 f3       	brcs	.-44     	; 0x1cfa <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1d26:	84 e2       	ldi	r24, 0x24	; 36
    1d28:	94 e0       	ldi	r25, 0x04	; 4
    1d2a:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1d2e:	8d e2       	ldi	r24, 0x2D	; 45
    1d30:	94 e0       	ldi	r25, 0x04	; 4
    1d32:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d36:	86 e3       	ldi	r24, 0x36	; 54
    1d38:	94 e0       	ldi	r25, 0x04	; 4
    1d3a:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d3e:	84 e2       	ldi	r24, 0x24	; 36
    1d40:	94 e0       	ldi	r25, 0x04	; 4
    1d42:	90 93 06 04 	sts	0x0406, r25
    1d46:	80 93 05 04 	sts	0x0405, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d4a:	8d e2       	ldi	r24, 0x2D	; 45
    1d4c:	94 e0       	ldi	r25, 0x04	; 4
    1d4e:	90 93 08 04 	sts	0x0408, r25
    1d52:	80 93 07 04 	sts	0x0407, r24
    }
    1d56:	0f 90       	pop	r0
    1d58:	cf 91       	pop	r28
    1d5a:	df 91       	pop	r29
    1d5c:	08 95       	ret

00001d5e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1d5e:	df 93       	push	r29
    1d60:	cf 93       	push	r28
    1d62:	00 d0       	rcall	.+0      	; 0x1d64 <xCoRoutineRemoveFromEventList+0x6>
    1d64:	00 d0       	rcall	.+0      	; 0x1d66 <xCoRoutineRemoveFromEventList+0x8>
    1d66:	0f 92       	push	r0
    1d68:	cd b7       	in	r28, 0x3d	; 61
    1d6a:	de b7       	in	r29, 0x3e	; 62
    1d6c:	9d 83       	std	Y+5, r25	; 0x05
    1d6e:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1d70:	ec 81       	ldd	r30, Y+4	; 0x04
    1d72:	fd 81       	ldd	r31, Y+5	; 0x05
    1d74:	05 80       	ldd	r0, Z+5	; 0x05
    1d76:	f6 81       	ldd	r31, Z+6	; 0x06
    1d78:	e0 2d       	mov	r30, r0
    1d7a:	86 81       	ldd	r24, Z+6	; 0x06
    1d7c:	97 81       	ldd	r25, Z+7	; 0x07
    1d7e:	9b 83       	std	Y+3, r25	; 0x03
    1d80:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1d82:	8a 81       	ldd	r24, Y+2	; 0x02
    1d84:	9b 81       	ldd	r25, Y+3	; 0x03
    1d86:	0c 96       	adiw	r24, 0x0c	; 12
    1d88:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d90:	9c 01       	movw	r18, r24
    1d92:	24 5f       	subi	r18, 0xF4	; 244
    1d94:	3f 4f       	sbci	r19, 0xFF	; 255
    1d96:	86 e3       	ldi	r24, 0x36	; 54
    1d98:	94 e0       	ldi	r25, 0x04	; 4
    1d9a:	b9 01       	movw	r22, r18
    1d9c:	0e 94 66 12 	call	0x24cc	; 0x24cc <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1da0:	ea 81       	ldd	r30, Y+2	; 0x02
    1da2:	fb 81       	ldd	r31, Y+3	; 0x03
    1da4:	96 89       	ldd	r25, Z+22	; 0x16
    1da6:	e0 91 09 04 	lds	r30, 0x0409
    1daa:	f0 91 0a 04 	lds	r31, 0x040A
    1dae:	86 89       	ldd	r24, Z+22	; 0x16
    1db0:	98 17       	cp	r25, r24
    1db2:	18 f0       	brcs	.+6      	; 0x1dba <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	89 83       	std	Y+1, r24	; 0x01
    1db8:	01 c0       	rjmp	.+2      	; 0x1dbc <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1dba:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1dbc:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	0f 90       	pop	r0
    1dc4:	0f 90       	pop	r0
    1dc6:	0f 90       	pop	r0
    1dc8:	cf 91       	pop	r28
    1dca:	df 91       	pop	r29
    1dcc:	08 95       	ret

00001dce <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1dce:	df 93       	push	r29
    1dd0:	cf 93       	push	r28
    1dd2:	00 d0       	rcall	.+0      	; 0x1dd4 <xEventGroupCreate+0x6>
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1dd8:	8b e0       	ldi	r24, 0x0B	; 11
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	0e 94 b4 08 	call	0x1168	; 0x1168 <pvPortMalloc>
    1de0:	9a 83       	std	Y+2, r25	; 0x02
    1de2:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	9a 81       	ldd	r25, Y+2	; 0x02
    1de8:	00 97       	sbiw	r24, 0x00	; 0
    1dea:	49 f0       	breq	.+18     	; 0x1dfe <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1dec:	e9 81       	ldd	r30, Y+1	; 0x01
    1dee:	fa 81       	ldd	r31, Y+2	; 0x02
    1df0:	11 82       	std	Z+1, r1	; 0x01
    1df2:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1df4:	89 81       	ldd	r24, Y+1	; 0x01
    1df6:	9a 81       	ldd	r25, Y+2	; 0x02
    1df8:	02 96       	adiw	r24, 0x02	; 2
    1dfa:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1e02:	0f 90       	pop	r0
    1e04:	0f 90       	pop	r0
    1e06:	cf 91       	pop	r28
    1e08:	df 91       	pop	r29
    1e0a:	08 95       	ret

00001e0c <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1e0c:	df 93       	push	r29
    1e0e:	cf 93       	push	r28
    1e10:	cd b7       	in	r28, 0x3d	; 61
    1e12:	de b7       	in	r29, 0x3e	; 62
    1e14:	60 97       	sbiw	r28, 0x10	; 16
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	f8 94       	cli
    1e1a:	de bf       	out	0x3e, r29	; 62
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	cd bf       	out	0x3d, r28	; 61
    1e20:	9a 87       	std	Y+10, r25	; 0x0a
    1e22:	89 87       	std	Y+9, r24	; 0x09
    1e24:	7c 87       	std	Y+12, r23	; 0x0c
    1e26:	6b 87       	std	Y+11, r22	; 0x0b
    1e28:	5e 87       	std	Y+14, r21	; 0x0e
    1e2a:	4d 87       	std	Y+13, r20	; 0x0d
    1e2c:	38 8b       	std	Y+16, r19	; 0x10
    1e2e:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1e30:	89 85       	ldd	r24, Y+9	; 0x09
    1e32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e34:	9c 83       	std	Y+4, r25	; 0x04
    1e36:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1e38:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1e3a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	80 81       	ld	r24, Z
    1e44:	91 81       	ldd	r25, Z+1	; 0x01
    1e46:	98 87       	std	Y+8, r25	; 0x08
    1e48:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1e4a:	89 85       	ldd	r24, Y+9	; 0x09
    1e4c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e4e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e50:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e52:	b9 01       	movw	r22, r18
    1e54:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1e58:	2f 81       	ldd	r18, Y+7	; 0x07
    1e5a:	38 85       	ldd	r19, Y+8	; 0x08
    1e5c:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e5e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e60:	28 2b       	or	r18, r24
    1e62:	39 2b       	or	r19, r25
    1e64:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e66:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e68:	28 23       	and	r18, r24
    1e6a:	39 23       	and	r19, r25
    1e6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e70:	28 17       	cp	r18, r24
    1e72:	39 07       	cpc	r19, r25
    1e74:	c9 f4       	brne	.+50     	; 0x1ea8 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1e76:	2f 81       	ldd	r18, Y+7	; 0x07
    1e78:	38 85       	ldd	r19, Y+8	; 0x08
    1e7a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e7c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e7e:	82 2b       	or	r24, r18
    1e80:	93 2b       	or	r25, r19
    1e82:	9e 83       	std	Y+6, r25	; 0x06
    1e84:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1e86:	eb 81       	ldd	r30, Y+3	; 0x03
    1e88:	fc 81       	ldd	r31, Y+4	; 0x04
    1e8a:	20 81       	ld	r18, Z
    1e8c:	31 81       	ldd	r19, Z+1	; 0x01
    1e8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e90:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e92:	80 95       	com	r24
    1e94:	90 95       	com	r25
    1e96:	82 23       	and	r24, r18
    1e98:	93 23       	and	r25, r19
    1e9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9e:	91 83       	std	Z+1, r25	; 0x01
    1ea0:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1ea2:	18 8a       	std	Y+16, r1	; 0x10
    1ea4:	1f 86       	std	Y+15, r1	; 0x0f
    1ea6:	1e c0       	rjmp	.+60     	; 0x1ee4 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1ea8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1eaa:	98 89       	ldd	r25, Y+16	; 0x10
    1eac:	00 97       	sbiw	r24, 0x00	; 0
    1eae:	91 f0       	breq	.+36     	; 0x1ed4 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb4:	bc 01       	movw	r22, r24
    1eb6:	6e 5f       	subi	r22, 0xFE	; 254
    1eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eba:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ebc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ebe:	9c 01       	movw	r18, r24
    1ec0:	35 60       	ori	r19, 0x05	; 5
    1ec2:	4f 85       	ldd	r20, Y+15	; 0x0f
    1ec4:	58 89       	ldd	r21, Y+16	; 0x10
    1ec6:	cb 01       	movw	r24, r22
    1ec8:	b9 01       	movw	r22, r18
    1eca:	0e 94 d1 22 	call	0x45a2	; 0x45a2 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1ece:	1e 82       	std	Y+6, r1	; 0x06
    1ed0:	1d 82       	std	Y+5, r1	; 0x05
    1ed2:	08 c0       	rjmp	.+16     	; 0x1ee4 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1ed4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ed6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ed8:	80 81       	ld	r24, Z
    1eda:	91 81       	ldd	r25, Z+1	; 0x01
    1edc:	9e 83       	std	Y+6, r25	; 0x06
    1ede:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1ee0:	81 e0       	ldi	r24, 0x01	; 1
    1ee2:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1ee4:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    1ee8:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1eea:	8f 85       	ldd	r24, Y+15	; 0x0f
    1eec:	98 89       	ldd	r25, Y+16	; 0x10
    1eee:	00 97       	sbiw	r24, 0x00	; 0
    1ef0:	09 f4       	brne	.+2      	; 0x1ef4 <xEventGroupSync+0xe8>
    1ef2:	3a c0       	rjmp	.+116    	; 0x1f68 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef6:	88 23       	and	r24, r24
    1ef8:	11 f4       	brne	.+4      	; 0x1efe <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1efa:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1efe:	0e 94 a2 26 	call	0x4d44	; 0x4d44 <uxTaskResetEventItemValue>
    1f02:	9e 83       	std	Y+6, r25	; 0x06
    1f04:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1f06:	8d 81       	ldd	r24, Y+5	; 0x05
    1f08:	9e 81       	ldd	r25, Y+6	; 0x06
    1f0a:	80 70       	andi	r24, 0x00	; 0
    1f0c:	92 70       	andi	r25, 0x02	; 2
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	31 f5       	brne	.+76     	; 0x1f5e <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1f12:	0f b6       	in	r0, 0x3f	; 63
    1f14:	f8 94       	cli
    1f16:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1f18:	eb 81       	ldd	r30, Y+3	; 0x03
    1f1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f1c:	80 81       	ld	r24, Z
    1f1e:	91 81       	ldd	r25, Z+1	; 0x01
    1f20:	9e 83       	std	Y+6, r25	; 0x06
    1f22:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1f24:	2d 81       	ldd	r18, Y+5	; 0x05
    1f26:	3e 81       	ldd	r19, Y+6	; 0x06
    1f28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f2c:	28 23       	and	r18, r24
    1f2e:	39 23       	and	r19, r25
    1f30:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f32:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f34:	28 17       	cp	r18, r24
    1f36:	39 07       	cpc	r19, r25
    1f38:	71 f4       	brne	.+28     	; 0x1f56 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f3e:	20 81       	ld	r18, Z
    1f40:	31 81       	ldd	r19, Z+1	; 0x01
    1f42:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f44:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f46:	80 95       	com	r24
    1f48:	90 95       	com	r25
    1f4a:	82 23       	and	r24, r18
    1f4c:	93 23       	and	r25, r19
    1f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f50:	fc 81       	ldd	r31, Y+4	; 0x04
    1f52:	91 83       	std	Z+1, r25	; 0x01
    1f54:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1f56:	0f 90       	pop	r0
    1f58:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1f5a:	81 e0       	ldi	r24, 0x01	; 1
    1f5c:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f60:	9e 81       	ldd	r25, Y+6	; 0x06
    1f62:	90 70       	andi	r25, 0x00	; 0
    1f64:	9e 83       	std	Y+6, r25	; 0x06
    1f66:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1f68:	8d 81       	ldd	r24, Y+5	; 0x05
    1f6a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1f6c:	60 96       	adiw	r28, 0x10	; 16
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	de bf       	out	0x3e, r29	; 62
    1f74:	0f be       	out	0x3f, r0	; 63
    1f76:	cd bf       	out	0x3d, r28	; 61
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	08 95       	ret

00001f7e <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1f7e:	0f 93       	push	r16
    1f80:	1f 93       	push	r17
    1f82:	df 93       	push	r29
    1f84:	cf 93       	push	r28
    1f86:	cd b7       	in	r28, 0x3d	; 61
    1f88:	de b7       	in	r29, 0x3e	; 62
    1f8a:	63 97       	sbiw	r28, 0x13	; 19
    1f8c:	0f b6       	in	r0, 0x3f	; 63
    1f8e:	f8 94       	cli
    1f90:	de bf       	out	0x3e, r29	; 62
    1f92:	0f be       	out	0x3f, r0	; 63
    1f94:	cd bf       	out	0x3d, r28	; 61
    1f96:	9d 87       	std	Y+13, r25	; 0x0d
    1f98:	8c 87       	std	Y+12, r24	; 0x0c
    1f9a:	7f 87       	std	Y+15, r23	; 0x0f
    1f9c:	6e 87       	std	Y+14, r22	; 0x0e
    1f9e:	48 8b       	std	Y+16, r20	; 0x10
    1fa0:	29 8b       	std	Y+17, r18	; 0x11
    1fa2:	1b 8b       	std	Y+19, r17	; 0x13
    1fa4:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1fa6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fa8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1faa:	9b 87       	std	Y+11, r25	; 0x0b
    1fac:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1fae:	1f 82       	std	Y+7, r1	; 0x07
    1fb0:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1fb2:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1fb4:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1fb8:	ea 85       	ldd	r30, Y+10	; 0x0a
    1fba:	fb 85       	ldd	r31, Y+11	; 0x0b
    1fbc:	80 81       	ld	r24, Z
    1fbe:	91 81       	ldd	r25, Z+1	; 0x01
    1fc0:	9a 83       	std	Y+2, r25	; 0x02
    1fc2:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1fc4:	89 81       	ldd	r24, Y+1	; 0x01
    1fc6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fc8:	2e 85       	ldd	r18, Y+14	; 0x0e
    1fca:	3f 85       	ldd	r19, Y+15	; 0x0f
    1fcc:	b9 01       	movw	r22, r18
    1fce:	49 89       	ldd	r20, Y+17	; 0x11
    1fd0:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <prvTestWaitCondition>
    1fd4:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    1fd8:	88 23       	and	r24, r24
    1fda:	c1 f0       	breq	.+48     	; 0x200c <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1fdc:	89 81       	ldd	r24, Y+1	; 0x01
    1fde:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe0:	99 87       	std	Y+9, r25	; 0x09
    1fe2:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1fe4:	1b 8a       	std	Y+19, r1	; 0x13
    1fe6:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1fe8:	88 89       	ldd	r24, Y+16	; 0x10
    1fea:	88 23       	and	r24, r24
    1fec:	e9 f1       	breq	.+122    	; 0x2068 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1fee:	ea 85       	ldd	r30, Y+10	; 0x0a
    1ff0:	fb 85       	ldd	r31, Y+11	; 0x0b
    1ff2:	20 81       	ld	r18, Z
    1ff4:	31 81       	ldd	r19, Z+1	; 0x01
    1ff6:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ff8:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ffa:	80 95       	com	r24
    1ffc:	90 95       	com	r25
    1ffe:	82 23       	and	r24, r18
    2000:	93 23       	and	r25, r19
    2002:	ea 85       	ldd	r30, Y+10	; 0x0a
    2004:	fb 85       	ldd	r31, Y+11	; 0x0b
    2006:	91 83       	std	Z+1, r25	; 0x01
    2008:	80 83       	st	Z, r24
    200a:	2e c0       	rjmp	.+92     	; 0x2068 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    200c:	8a 89       	ldd	r24, Y+18	; 0x12
    200e:	9b 89       	ldd	r25, Y+19	; 0x13
    2010:	00 97       	sbiw	r24, 0x00	; 0
    2012:	39 f4       	brne	.+14     	; 0x2022 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    2014:	89 81       	ldd	r24, Y+1	; 0x01
    2016:	9a 81       	ldd	r25, Y+2	; 0x02
    2018:	99 87       	std	Y+9, r25	; 0x09
    201a:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	8b 83       	std	Y+3, r24	; 0x03
    2020:	23 c0       	rjmp	.+70     	; 0x2068 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    2022:	88 89       	ldd	r24, Y+16	; 0x10
    2024:	88 23       	and	r24, r24
    2026:	29 f0       	breq	.+10     	; 0x2032 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2028:	8e 81       	ldd	r24, Y+6	; 0x06
    202a:	9f 81       	ldd	r25, Y+7	; 0x07
    202c:	91 60       	ori	r25, 0x01	; 1
    202e:	9f 83       	std	Y+7, r25	; 0x07
    2030:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    2032:	89 89       	ldd	r24, Y+17	; 0x11
    2034:	88 23       	and	r24, r24
    2036:	29 f0       	breq	.+10     	; 0x2042 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2038:	8e 81       	ldd	r24, Y+6	; 0x06
    203a:	9f 81       	ldd	r25, Y+7	; 0x07
    203c:	94 60       	ori	r25, 0x04	; 4
    203e:	9f 83       	std	Y+7, r25	; 0x07
    2040:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2042:	8a 85       	ldd	r24, Y+10	; 0x0a
    2044:	9b 85       	ldd	r25, Y+11	; 0x0b
    2046:	bc 01       	movw	r22, r24
    2048:	6e 5f       	subi	r22, 0xFE	; 254
    204a:	7f 4f       	sbci	r23, 0xFF	; 255
    204c:	2e 85       	ldd	r18, Y+14	; 0x0e
    204e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2050:	8e 81       	ldd	r24, Y+6	; 0x06
    2052:	9f 81       	ldd	r25, Y+7	; 0x07
    2054:	28 2b       	or	r18, r24
    2056:	39 2b       	or	r19, r25
    2058:	4a 89       	ldd	r20, Y+18	; 0x12
    205a:	5b 89       	ldd	r21, Y+19	; 0x13
    205c:	cb 01       	movw	r24, r22
    205e:	b9 01       	movw	r22, r18
    2060:	0e 94 d1 22 	call	0x45a2	; 0x45a2 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    2064:	19 86       	std	Y+9, r1	; 0x09
    2066:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2068:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    206c:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    206e:	8a 89       	ldd	r24, Y+18	; 0x12
    2070:	9b 89       	ldd	r25, Y+19	; 0x13
    2072:	00 97       	sbiw	r24, 0x00	; 0
    2074:	09 f4       	brne	.+2      	; 0x2078 <xEventGroupWaitBits+0xfa>
    2076:	3c c0       	rjmp	.+120    	; 0x20f0 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    2078:	8c 81       	ldd	r24, Y+4	; 0x04
    207a:	88 23       	and	r24, r24
    207c:	11 f4       	brne	.+4      	; 0x2082 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    207e:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2082:	0e 94 a2 26 	call	0x4d44	; 0x4d44 <uxTaskResetEventItemValue>
    2086:	99 87       	std	Y+9, r25	; 0x09
    2088:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    208a:	88 85       	ldd	r24, Y+8	; 0x08
    208c:	99 85       	ldd	r25, Y+9	; 0x09
    208e:	80 70       	andi	r24, 0x00	; 0
    2090:	92 70       	andi	r25, 0x02	; 2
    2092:	00 97       	sbiw	r24, 0x00	; 0
    2094:	41 f5       	brne	.+80     	; 0x20e6 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    209c:	ea 85       	ldd	r30, Y+10	; 0x0a
    209e:	fb 85       	ldd	r31, Y+11	; 0x0b
    20a0:	80 81       	ld	r24, Z
    20a2:	91 81       	ldd	r25, Z+1	; 0x01
    20a4:	99 87       	std	Y+9, r25	; 0x09
    20a6:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    20a8:	88 85       	ldd	r24, Y+8	; 0x08
    20aa:	99 85       	ldd	r25, Y+9	; 0x09
    20ac:	2e 85       	ldd	r18, Y+14	; 0x0e
    20ae:	3f 85       	ldd	r19, Y+15	; 0x0f
    20b0:	b9 01       	movw	r22, r18
    20b2:	49 89       	ldd	r20, Y+17	; 0x11
    20b4:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <prvTestWaitCondition>
    20b8:	88 23       	and	r24, r24
    20ba:	89 f0       	breq	.+34     	; 0x20de <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    20bc:	88 89       	ldd	r24, Y+16	; 0x10
    20be:	88 23       	and	r24, r24
    20c0:	71 f0       	breq	.+28     	; 0x20de <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    20c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    20c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    20c6:	20 81       	ld	r18, Z
    20c8:	31 81       	ldd	r19, Z+1	; 0x01
    20ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    20cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    20ce:	80 95       	com	r24
    20d0:	90 95       	com	r25
    20d2:	82 23       	and	r24, r18
    20d4:	93 23       	and	r25, r19
    20d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    20d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    20da:	91 83       	std	Z+1, r25	; 0x01
    20dc:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    20e2:	0f 90       	pop	r0
    20e4:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    20e6:	88 85       	ldd	r24, Y+8	; 0x08
    20e8:	99 85       	ldd	r25, Y+9	; 0x09
    20ea:	90 70       	andi	r25, 0x00	; 0
    20ec:	99 87       	std	Y+9, r25	; 0x09
    20ee:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    20f0:	88 85       	ldd	r24, Y+8	; 0x08
    20f2:	99 85       	ldd	r25, Y+9	; 0x09
}
    20f4:	63 96       	adiw	r28, 0x13	; 19
    20f6:	0f b6       	in	r0, 0x3f	; 63
    20f8:	f8 94       	cli
    20fa:	de bf       	out	0x3e, r29	; 62
    20fc:	0f be       	out	0x3f, r0	; 63
    20fe:	cd bf       	out	0x3d, r28	; 61
    2100:	cf 91       	pop	r28
    2102:	df 91       	pop	r29
    2104:	1f 91       	pop	r17
    2106:	0f 91       	pop	r16
    2108:	08 95       	ret

0000210a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	cd b7       	in	r28, 0x3d	; 61
    2110:	de b7       	in	r29, 0x3e	; 62
    2112:	28 97       	sbiw	r28, 0x08	; 8
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	f8 94       	cli
    2118:	de bf       	out	0x3e, r29	; 62
    211a:	0f be       	out	0x3f, r0	; 63
    211c:	cd bf       	out	0x3d, r28	; 61
    211e:	9e 83       	std	Y+6, r25	; 0x06
    2120:	8d 83       	std	Y+5, r24	; 0x05
    2122:	78 87       	std	Y+8, r23	; 0x08
    2124:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    2126:	8d 81       	ldd	r24, Y+5	; 0x05
    2128:	9e 81       	ldd	r25, Y+6	; 0x06
    212a:	9c 83       	std	Y+4, r25	; 0x04
    212c:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    212e:	0f b6       	in	r0, 0x3f	; 63
    2130:	f8 94       	cli
    2132:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    2134:	eb 81       	ldd	r30, Y+3	; 0x03
    2136:	fc 81       	ldd	r31, Y+4	; 0x04
    2138:	80 81       	ld	r24, Z
    213a:	91 81       	ldd	r25, Z+1	; 0x01
    213c:	9a 83       	std	Y+2, r25	; 0x02
    213e:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2140:	eb 81       	ldd	r30, Y+3	; 0x03
    2142:	fc 81       	ldd	r31, Y+4	; 0x04
    2144:	20 81       	ld	r18, Z
    2146:	31 81       	ldd	r19, Z+1	; 0x01
    2148:	8f 81       	ldd	r24, Y+7	; 0x07
    214a:	98 85       	ldd	r25, Y+8	; 0x08
    214c:	80 95       	com	r24
    214e:	90 95       	com	r25
    2150:	82 23       	and	r24, r18
    2152:	93 23       	and	r25, r19
    2154:	eb 81       	ldd	r30, Y+3	; 0x03
    2156:	fc 81       	ldd	r31, Y+4	; 0x04
    2158:	91 83       	std	Z+1, r25	; 0x01
    215a:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    215c:	0f 90       	pop	r0
    215e:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2160:	89 81       	ldd	r24, Y+1	; 0x01
    2162:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2164:	28 96       	adiw	r28, 0x08	; 8
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	f8 94       	cli
    216a:	de bf       	out	0x3e, r29	; 62
    216c:	0f be       	out	0x3f, r0	; 63
    216e:	cd bf       	out	0x3d, r28	; 61
    2170:	cf 91       	pop	r28
    2172:	df 91       	pop	r29
    2174:	08 95       	ret

00002176 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2176:	df 93       	push	r29
    2178:	cf 93       	push	r28
    217a:	cd b7       	in	r28, 0x3d	; 61
    217c:	de b7       	in	r29, 0x3e	; 62
    217e:	27 97       	sbiw	r28, 0x07	; 7
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	de bf       	out	0x3e, r29	; 62
    2186:	0f be       	out	0x3f, r0	; 63
    2188:	cd bf       	out	0x3d, r28	; 61
    218a:	9f 83       	std	Y+7, r25	; 0x07
    218c:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    218e:	8e 81       	ldd	r24, Y+6	; 0x06
    2190:	9f 81       	ldd	r25, Y+7	; 0x07
    2192:	9c 83       	std	Y+4, r25	; 0x04
    2194:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2196:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    2198:	eb 81       	ldd	r30, Y+3	; 0x03
    219a:	fc 81       	ldd	r31, Y+4	; 0x04
    219c:	80 81       	ld	r24, Z
    219e:	91 81       	ldd	r25, Z+1	; 0x01
    21a0:	9a 83       	std	Y+2, r25	; 0x02
    21a2:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    21a4:	89 81       	ldd	r24, Y+1	; 0x01
    21a6:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    21a8:	27 96       	adiw	r28, 0x07	; 7
    21aa:	0f b6       	in	r0, 0x3f	; 63
    21ac:	f8 94       	cli
    21ae:	de bf       	out	0x3e, r29	; 62
    21b0:	0f be       	out	0x3f, r0	; 63
    21b2:	cd bf       	out	0x3d, r28	; 61
    21b4:	cf 91       	pop	r28
    21b6:	df 91       	pop	r29
    21b8:	08 95       	ret

000021ba <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    21ba:	df 93       	push	r29
    21bc:	cf 93       	push	r28
    21be:	cd b7       	in	r28, 0x3d	; 61
    21c0:	de b7       	in	r29, 0x3e	; 62
    21c2:	65 97       	sbiw	r28, 0x15	; 21
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	f8 94       	cli
    21c8:	de bf       	out	0x3e, r29	; 62
    21ca:	0f be       	out	0x3f, r0	; 63
    21cc:	cd bf       	out	0x3d, r28	; 61
    21ce:	9b 8b       	std	Y+19, r25	; 0x13
    21d0:	8a 8b       	std	Y+18, r24	; 0x12
    21d2:	7d 8b       	std	Y+21, r23	; 0x15
    21d4:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    21d6:	19 86       	std	Y+9, r1	; 0x09
    21d8:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    21da:	8a 89       	ldd	r24, Y+18	; 0x12
    21dc:	9b 89       	ldd	r25, Y+19	; 0x13
    21de:	9b 83       	std	Y+3, r25	; 0x03
    21e0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    21e2:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    21e4:	8a 81       	ldd	r24, Y+2	; 0x02
    21e6:	9b 81       	ldd	r25, Y+3	; 0x03
    21e8:	02 96       	adiw	r24, 0x02	; 2
    21ea:	9b 87       	std	Y+11, r25	; 0x0b
    21ec:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    21ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    21f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    21f2:	03 96       	adiw	r24, 0x03	; 3
    21f4:	9d 87       	std	Y+13, r25	; 0x0d
    21f6:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    21f8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    21fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    21fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    2200:	85 81       	ldd	r24, Z+5	; 0x05
    2202:	96 81       	ldd	r25, Z+6	; 0x06
    2204:	99 8b       	std	Y+17, r25	; 0x11
    2206:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    2208:	ea 81       	ldd	r30, Y+2	; 0x02
    220a:	fb 81       	ldd	r31, Y+3	; 0x03
    220c:	20 81       	ld	r18, Z
    220e:	31 81       	ldd	r19, Z+1	; 0x01
    2210:	8c 89       	ldd	r24, Y+20	; 0x14
    2212:	9d 89       	ldd	r25, Y+21	; 0x15
    2214:	82 2b       	or	r24, r18
    2216:	93 2b       	or	r25, r19
    2218:	ea 81       	ldd	r30, Y+2	; 0x02
    221a:	fb 81       	ldd	r31, Y+3	; 0x03
    221c:	91 83       	std	Z+1, r25	; 0x01
    221e:	80 83       	st	Z, r24
    2220:	59 c0       	rjmp	.+178    	; 0x22d4 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    2222:	e8 89       	ldd	r30, Y+16	; 0x10
    2224:	f9 89       	ldd	r31, Y+17	; 0x11
    2226:	82 81       	ldd	r24, Z+2	; 0x02
    2228:	93 81       	ldd	r25, Z+3	; 0x03
    222a:	9f 87       	std	Y+15, r25	; 0x0f
    222c:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    222e:	e8 89       	ldd	r30, Y+16	; 0x10
    2230:	f9 89       	ldd	r31, Y+17	; 0x11
    2232:	80 81       	ld	r24, Z
    2234:	91 81       	ldd	r25, Z+1	; 0x01
    2236:	9f 83       	std	Y+7, r25	; 0x07
    2238:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    223a:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    223c:	8e 81       	ldd	r24, Y+6	; 0x06
    223e:	9f 81       	ldd	r25, Y+7	; 0x07
    2240:	80 70       	andi	r24, 0x00	; 0
    2242:	9d 83       	std	Y+5, r25	; 0x05
    2244:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2246:	8e 81       	ldd	r24, Y+6	; 0x06
    2248:	9f 81       	ldd	r25, Y+7	; 0x07
    224a:	90 70       	andi	r25, 0x00	; 0
    224c:	9f 83       	std	Y+7, r25	; 0x07
    224e:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2250:	8c 81       	ldd	r24, Y+4	; 0x04
    2252:	9d 81       	ldd	r25, Y+5	; 0x05
    2254:	80 70       	andi	r24, 0x00	; 0
    2256:	94 70       	andi	r25, 0x04	; 4
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	69 f4       	brne	.+26     	; 0x2276 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    225c:	ea 81       	ldd	r30, Y+2	; 0x02
    225e:	fb 81       	ldd	r31, Y+3	; 0x03
    2260:	20 81       	ld	r18, Z
    2262:	31 81       	ldd	r19, Z+1	; 0x01
    2264:	8e 81       	ldd	r24, Y+6	; 0x06
    2266:	9f 81       	ldd	r25, Y+7	; 0x07
    2268:	82 23       	and	r24, r18
    226a:	93 23       	and	r25, r19
    226c:	00 97       	sbiw	r24, 0x00	; 0
    226e:	91 f0       	breq	.+36     	; 0x2294 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    2270:	81 e0       	ldi	r24, 0x01	; 1
    2272:	89 83       	std	Y+1, r24	; 0x01
    2274:	0f c0       	rjmp	.+30     	; 0x2294 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2276:	ea 81       	ldd	r30, Y+2	; 0x02
    2278:	fb 81       	ldd	r31, Y+3	; 0x03
    227a:	20 81       	ld	r18, Z
    227c:	31 81       	ldd	r19, Z+1	; 0x01
    227e:	8e 81       	ldd	r24, Y+6	; 0x06
    2280:	9f 81       	ldd	r25, Y+7	; 0x07
    2282:	28 23       	and	r18, r24
    2284:	39 23       	and	r19, r25
    2286:	8e 81       	ldd	r24, Y+6	; 0x06
    2288:	9f 81       	ldd	r25, Y+7	; 0x07
    228a:	28 17       	cp	r18, r24
    228c:	39 07       	cpc	r19, r25
    228e:	11 f4       	brne	.+4      	; 0x2294 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    2290:	81 e0       	ldi	r24, 0x01	; 1
    2292:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    2294:	89 81       	ldd	r24, Y+1	; 0x01
    2296:	88 23       	and	r24, r24
    2298:	c9 f0       	breq	.+50     	; 0x22cc <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    229a:	8c 81       	ldd	r24, Y+4	; 0x04
    229c:	9d 81       	ldd	r25, Y+5	; 0x05
    229e:	80 70       	andi	r24, 0x00	; 0
    22a0:	91 70       	andi	r25, 0x01	; 1
    22a2:	00 97       	sbiw	r24, 0x00	; 0
    22a4:	41 f0       	breq	.+16     	; 0x22b6 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    22a6:	88 85       	ldd	r24, Y+8	; 0x08
    22a8:	99 85       	ldd	r25, Y+9	; 0x09
    22aa:	2e 81       	ldd	r18, Y+6	; 0x06
    22ac:	3f 81       	ldd	r19, Y+7	; 0x07
    22ae:	82 2b       	or	r24, r18
    22b0:	93 2b       	or	r25, r19
    22b2:	99 87       	std	Y+9, r25	; 0x09
    22b4:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    22b6:	ea 81       	ldd	r30, Y+2	; 0x02
    22b8:	fb 81       	ldd	r31, Y+3	; 0x03
    22ba:	80 81       	ld	r24, Z
    22bc:	91 81       	ldd	r25, Z+1	; 0x01
    22be:	9c 01       	movw	r18, r24
    22c0:	32 60       	ori	r19, 0x02	; 2
    22c2:	88 89       	ldd	r24, Y+16	; 0x10
    22c4:	99 89       	ldd	r25, Y+17	; 0x11
    22c6:	b9 01       	movw	r22, r18
    22c8:	0e 94 7a 24 	call	0x48f4	; 0x48f4 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    22cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    22ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    22d0:	99 8b       	std	Y+17, r25	; 0x11
    22d2:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    22d4:	28 89       	ldd	r18, Y+16	; 0x10
    22d6:	39 89       	ldd	r19, Y+17	; 0x11
    22d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    22da:	9d 85       	ldd	r25, Y+13	; 0x0d
    22dc:	28 17       	cp	r18, r24
    22de:	39 07       	cpc	r19, r25
    22e0:	09 f0       	breq	.+2      	; 0x22e4 <xEventGroupSetBits+0x12a>
    22e2:	9f cf       	rjmp	.-194    	; 0x2222 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    22e4:	ea 81       	ldd	r30, Y+2	; 0x02
    22e6:	fb 81       	ldd	r31, Y+3	; 0x03
    22e8:	20 81       	ld	r18, Z
    22ea:	31 81       	ldd	r19, Z+1	; 0x01
    22ec:	88 85       	ldd	r24, Y+8	; 0x08
    22ee:	99 85       	ldd	r25, Y+9	; 0x09
    22f0:	80 95       	com	r24
    22f2:	90 95       	com	r25
    22f4:	82 23       	and	r24, r18
    22f6:	93 23       	and	r25, r19
    22f8:	ea 81       	ldd	r30, Y+2	; 0x02
    22fa:	fb 81       	ldd	r31, Y+3	; 0x03
    22fc:	91 83       	std	Z+1, r25	; 0x01
    22fe:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    2300:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2304:	ea 81       	ldd	r30, Y+2	; 0x02
    2306:	fb 81       	ldd	r31, Y+3	; 0x03
    2308:	80 81       	ld	r24, Z
    230a:	91 81       	ldd	r25, Z+1	; 0x01
}
    230c:	65 96       	adiw	r28, 0x15	; 21
    230e:	0f b6       	in	r0, 0x3f	; 63
    2310:	f8 94       	cli
    2312:	de bf       	out	0x3e, r29	; 62
    2314:	0f be       	out	0x3f, r0	; 63
    2316:	cd bf       	out	0x3d, r28	; 61
    2318:	cf 91       	pop	r28
    231a:	df 91       	pop	r29
    231c:	08 95       	ret

0000231e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    231e:	df 93       	push	r29
    2320:	cf 93       	push	r28
    2322:	00 d0       	rcall	.+0      	; 0x2324 <vEventGroupDelete+0x6>
    2324:	00 d0       	rcall	.+0      	; 0x2326 <vEventGroupDelete+0x8>
    2326:	00 d0       	rcall	.+0      	; 0x2328 <vEventGroupDelete+0xa>
    2328:	cd b7       	in	r28, 0x3d	; 61
    232a:	de b7       	in	r29, 0x3e	; 62
    232c:	9e 83       	std	Y+6, r25	; 0x06
    232e:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    2330:	8d 81       	ldd	r24, Y+5	; 0x05
    2332:	9e 81       	ldd	r25, Y+6	; 0x06
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2338:	8b 81       	ldd	r24, Y+3	; 0x03
    233a:	9c 81       	ldd	r25, Y+4	; 0x04
    233c:	02 96       	adiw	r24, 0x02	; 2
    233e:	9a 83       	std	Y+2, r25	; 0x02
    2340:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2342:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    2346:	08 c0       	rjmp	.+16     	; 0x2358 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2348:	e9 81       	ldd	r30, Y+1	; 0x01
    234a:	fa 81       	ldd	r31, Y+2	; 0x02
    234c:	85 81       	ldd	r24, Z+5	; 0x05
    234e:	96 81       	ldd	r25, Z+6	; 0x06
    2350:	60 e0       	ldi	r22, 0x00	; 0
    2352:	72 e0       	ldi	r23, 0x02	; 2
    2354:	0e 94 7a 24 	call	0x48f4	; 0x48f4 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2358:	e9 81       	ldd	r30, Y+1	; 0x01
    235a:	fa 81       	ldd	r31, Y+2	; 0x02
    235c:	80 81       	ld	r24, Z
    235e:	88 23       	and	r24, r24
    2360:	99 f7       	brne	.-26     	; 0x2348 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2362:	8b 81       	ldd	r24, Y+3	; 0x03
    2364:	9c 81       	ldd	r25, Y+4	; 0x04
    2366:	0e 94 0e 09 	call	0x121c	; 0x121c <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    236a:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
}
    236e:	26 96       	adiw	r28, 0x06	; 6
    2370:	0f b6       	in	r0, 0x3f	; 63
    2372:	f8 94       	cli
    2374:	de bf       	out	0x3e, r29	; 62
    2376:	0f be       	out	0x3f, r0	; 63
    2378:	cd bf       	out	0x3d, r28	; 61
    237a:	cf 91       	pop	r28
    237c:	df 91       	pop	r29
    237e:	08 95       	ret

00002380 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2380:	df 93       	push	r29
    2382:	cf 93       	push	r28
    2384:	00 d0       	rcall	.+0      	; 0x2386 <vEventGroupSetBitsCallback+0x6>
    2386:	00 d0       	rcall	.+0      	; 0x2388 <vEventGroupSetBitsCallback+0x8>
    2388:	00 d0       	rcall	.+0      	; 0x238a <vEventGroupSetBitsCallback+0xa>
    238a:	cd b7       	in	r28, 0x3d	; 61
    238c:	de b7       	in	r29, 0x3e	; 62
    238e:	9a 83       	std	Y+2, r25	; 0x02
    2390:	89 83       	std	Y+1, r24	; 0x01
    2392:	4b 83       	std	Y+3, r20	; 0x03
    2394:	5c 83       	std	Y+4, r21	; 0x04
    2396:	6d 83       	std	Y+5, r22	; 0x05
    2398:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    239a:	89 81       	ldd	r24, Y+1	; 0x01
    239c:	9a 81       	ldd	r25, Y+2	; 0x02
    239e:	2b 81       	ldd	r18, Y+3	; 0x03
    23a0:	3c 81       	ldd	r19, Y+4	; 0x04
    23a2:	b9 01       	movw	r22, r18
    23a4:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xEventGroupSetBits>
}
    23a8:	26 96       	adiw	r28, 0x06	; 6
    23aa:	0f b6       	in	r0, 0x3f	; 63
    23ac:	f8 94       	cli
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	0f be       	out	0x3f, r0	; 63
    23b2:	cd bf       	out	0x3d, r28	; 61
    23b4:	cf 91       	pop	r28
    23b6:	df 91       	pop	r29
    23b8:	08 95       	ret

000023ba <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    23ba:	df 93       	push	r29
    23bc:	cf 93       	push	r28
    23be:	00 d0       	rcall	.+0      	; 0x23c0 <vEventGroupClearBitsCallback+0x6>
    23c0:	00 d0       	rcall	.+0      	; 0x23c2 <vEventGroupClearBitsCallback+0x8>
    23c2:	00 d0       	rcall	.+0      	; 0x23c4 <vEventGroupClearBitsCallback+0xa>
    23c4:	cd b7       	in	r28, 0x3d	; 61
    23c6:	de b7       	in	r29, 0x3e	; 62
    23c8:	9a 83       	std	Y+2, r25	; 0x02
    23ca:	89 83       	std	Y+1, r24	; 0x01
    23cc:	4b 83       	std	Y+3, r20	; 0x03
    23ce:	5c 83       	std	Y+4, r21	; 0x04
    23d0:	6d 83       	std	Y+5, r22	; 0x05
    23d2:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    23d4:	89 81       	ldd	r24, Y+1	; 0x01
    23d6:	9a 81       	ldd	r25, Y+2	; 0x02
    23d8:	2b 81       	ldd	r18, Y+3	; 0x03
    23da:	3c 81       	ldd	r19, Y+4	; 0x04
    23dc:	b9 01       	movw	r22, r18
    23de:	0e 94 85 10 	call	0x210a	; 0x210a <xEventGroupClearBits>
}
    23e2:	26 96       	adiw	r28, 0x06	; 6
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	f8 94       	cli
    23e8:	de bf       	out	0x3e, r29	; 62
    23ea:	0f be       	out	0x3f, r0	; 63
    23ec:	cd bf       	out	0x3d, r28	; 61
    23ee:	cf 91       	pop	r28
    23f0:	df 91       	pop	r29
    23f2:	08 95       	ret

000023f4 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    23f4:	df 93       	push	r29
    23f6:	cf 93       	push	r28
    23f8:	00 d0       	rcall	.+0      	; 0x23fa <prvTestWaitCondition+0x6>
    23fa:	00 d0       	rcall	.+0      	; 0x23fc <prvTestWaitCondition+0x8>
    23fc:	00 d0       	rcall	.+0      	; 0x23fe <prvTestWaitCondition+0xa>
    23fe:	cd b7       	in	r28, 0x3d	; 61
    2400:	de b7       	in	r29, 0x3e	; 62
    2402:	9b 83       	std	Y+3, r25	; 0x03
    2404:	8a 83       	std	Y+2, r24	; 0x02
    2406:	7d 83       	std	Y+5, r23	; 0x05
    2408:	6c 83       	std	Y+4, r22	; 0x04
    240a:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    240c:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    240e:	8e 81       	ldd	r24, Y+6	; 0x06
    2410:	88 23       	and	r24, r24
    2412:	59 f4       	brne	.+22     	; 0x242a <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2414:	8a 81       	ldd	r24, Y+2	; 0x02
    2416:	9b 81       	ldd	r25, Y+3	; 0x03
    2418:	2c 81       	ldd	r18, Y+4	; 0x04
    241a:	3d 81       	ldd	r19, Y+5	; 0x05
    241c:	82 23       	and	r24, r18
    241e:	93 23       	and	r25, r19
    2420:	00 97       	sbiw	r24, 0x00	; 0
    2422:	81 f0       	breq	.+32     	; 0x2444 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	89 83       	std	Y+1, r24	; 0x01
    2428:	0d c0       	rjmp	.+26     	; 0x2444 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    242a:	2a 81       	ldd	r18, Y+2	; 0x02
    242c:	3b 81       	ldd	r19, Y+3	; 0x03
    242e:	8c 81       	ldd	r24, Y+4	; 0x04
    2430:	9d 81       	ldd	r25, Y+5	; 0x05
    2432:	28 23       	and	r18, r24
    2434:	39 23       	and	r19, r25
    2436:	8c 81       	ldd	r24, Y+4	; 0x04
    2438:	9d 81       	ldd	r25, Y+5	; 0x05
    243a:	28 17       	cp	r18, r24
    243c:	39 07       	cpc	r19, r25
    243e:	11 f4       	brne	.+4      	; 0x2444 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2444:	89 81       	ldd	r24, Y+1	; 0x01
}
    2446:	26 96       	adiw	r28, 0x06	; 6
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	de bf       	out	0x3e, r29	; 62
    244e:	0f be       	out	0x3f, r0	; 63
    2450:	cd bf       	out	0x3d, r28	; 61
    2452:	cf 91       	pop	r28
    2454:	df 91       	pop	r29
    2456:	08 95       	ret

00002458 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2458:	df 93       	push	r29
    245a:	cf 93       	push	r28
    245c:	00 d0       	rcall	.+0      	; 0x245e <vListInitialise+0x6>
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	9a 83       	std	Y+2, r25	; 0x02
    2464:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2466:	89 81       	ldd	r24, Y+1	; 0x01
    2468:	9a 81       	ldd	r25, Y+2	; 0x02
    246a:	03 96       	adiw	r24, 0x03	; 3
    246c:	e9 81       	ldd	r30, Y+1	; 0x01
    246e:	fa 81       	ldd	r31, Y+2	; 0x02
    2470:	92 83       	std	Z+2, r25	; 0x02
    2472:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	8f ef       	ldi	r24, 0xFF	; 255
    247a:	9f ef       	ldi	r25, 0xFF	; 255
    247c:	94 83       	std	Z+4, r25	; 0x04
    247e:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2480:	89 81       	ldd	r24, Y+1	; 0x01
    2482:	9a 81       	ldd	r25, Y+2	; 0x02
    2484:	03 96       	adiw	r24, 0x03	; 3
    2486:	e9 81       	ldd	r30, Y+1	; 0x01
    2488:	fa 81       	ldd	r31, Y+2	; 0x02
    248a:	96 83       	std	Z+6, r25	; 0x06
    248c:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    248e:	89 81       	ldd	r24, Y+1	; 0x01
    2490:	9a 81       	ldd	r25, Y+2	; 0x02
    2492:	03 96       	adiw	r24, 0x03	; 3
    2494:	e9 81       	ldd	r30, Y+1	; 0x01
    2496:	fa 81       	ldd	r31, Y+2	; 0x02
    2498:	90 87       	std	Z+8, r25	; 0x08
    249a:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    249c:	e9 81       	ldd	r30, Y+1	; 0x01
    249e:	fa 81       	ldd	r31, Y+2	; 0x02
    24a0:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    24a2:	0f 90       	pop	r0
    24a4:	0f 90       	pop	r0
    24a6:	cf 91       	pop	r28
    24a8:	df 91       	pop	r29
    24aa:	08 95       	ret

000024ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    24ac:	df 93       	push	r29
    24ae:	cf 93       	push	r28
    24b0:	00 d0       	rcall	.+0      	; 0x24b2 <vListInitialiseItem+0x6>
    24b2:	cd b7       	in	r28, 0x3d	; 61
    24b4:	de b7       	in	r29, 0x3e	; 62
    24b6:	9a 83       	std	Y+2, r25	; 0x02
    24b8:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    24ba:	e9 81       	ldd	r30, Y+1	; 0x01
    24bc:	fa 81       	ldd	r31, Y+2	; 0x02
    24be:	11 86       	std	Z+9, r1	; 0x09
    24c0:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	cf 91       	pop	r28
    24c8:	df 91       	pop	r29
    24ca:	08 95       	ret

000024cc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    24cc:	df 93       	push	r29
    24ce:	cf 93       	push	r28
    24d0:	00 d0       	rcall	.+0      	; 0x24d2 <vListInsertEnd+0x6>
    24d2:	00 d0       	rcall	.+0      	; 0x24d4 <vListInsertEnd+0x8>
    24d4:	00 d0       	rcall	.+0      	; 0x24d6 <vListInsertEnd+0xa>
    24d6:	cd b7       	in	r28, 0x3d	; 61
    24d8:	de b7       	in	r29, 0x3e	; 62
    24da:	9c 83       	std	Y+4, r25	; 0x04
    24dc:	8b 83       	std	Y+3, r24	; 0x03
    24de:	7e 83       	std	Y+6, r23	; 0x06
    24e0:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    24e2:	eb 81       	ldd	r30, Y+3	; 0x03
    24e4:	fc 81       	ldd	r31, Y+4	; 0x04
    24e6:	81 81       	ldd	r24, Z+1	; 0x01
    24e8:	92 81       	ldd	r25, Z+2	; 0x02
    24ea:	9a 83       	std	Y+2, r25	; 0x02
    24ec:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    24ee:	ed 81       	ldd	r30, Y+5	; 0x05
    24f0:	fe 81       	ldd	r31, Y+6	; 0x06
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	9a 81       	ldd	r25, Y+2	; 0x02
    24f6:	93 83       	std	Z+3, r25	; 0x03
    24f8:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    24fa:	e9 81       	ldd	r30, Y+1	; 0x01
    24fc:	fa 81       	ldd	r31, Y+2	; 0x02
    24fe:	84 81       	ldd	r24, Z+4	; 0x04
    2500:	95 81       	ldd	r25, Z+5	; 0x05
    2502:	ed 81       	ldd	r30, Y+5	; 0x05
    2504:	fe 81       	ldd	r31, Y+6	; 0x06
    2506:	95 83       	std	Z+5, r25	; 0x05
    2508:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    250a:	e9 81       	ldd	r30, Y+1	; 0x01
    250c:	fa 81       	ldd	r31, Y+2	; 0x02
    250e:	04 80       	ldd	r0, Z+4	; 0x04
    2510:	f5 81       	ldd	r31, Z+5	; 0x05
    2512:	e0 2d       	mov	r30, r0
    2514:	8d 81       	ldd	r24, Y+5	; 0x05
    2516:	9e 81       	ldd	r25, Y+6	; 0x06
    2518:	93 83       	std	Z+3, r25	; 0x03
    251a:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    251c:	e9 81       	ldd	r30, Y+1	; 0x01
    251e:	fa 81       	ldd	r31, Y+2	; 0x02
    2520:	8d 81       	ldd	r24, Y+5	; 0x05
    2522:	9e 81       	ldd	r25, Y+6	; 0x06
    2524:	95 83       	std	Z+5, r25	; 0x05
    2526:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2528:	ed 81       	ldd	r30, Y+5	; 0x05
    252a:	fe 81       	ldd	r31, Y+6	; 0x06
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
    252e:	9c 81       	ldd	r25, Y+4	; 0x04
    2530:	91 87       	std	Z+9, r25	; 0x09
    2532:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2534:	eb 81       	ldd	r30, Y+3	; 0x03
    2536:	fc 81       	ldd	r31, Y+4	; 0x04
    2538:	80 81       	ld	r24, Z
    253a:	8f 5f       	subi	r24, 0xFF	; 255
    253c:	eb 81       	ldd	r30, Y+3	; 0x03
    253e:	fc 81       	ldd	r31, Y+4	; 0x04
    2540:	80 83       	st	Z, r24
}
    2542:	26 96       	adiw	r28, 0x06	; 6
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	de bf       	out	0x3e, r29	; 62
    254a:	0f be       	out	0x3f, r0	; 63
    254c:	cd bf       	out	0x3d, r28	; 61
    254e:	cf 91       	pop	r28
    2550:	df 91       	pop	r29
    2552:	08 95       	ret

00002554 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2554:	df 93       	push	r29
    2556:	cf 93       	push	r28
    2558:	cd b7       	in	r28, 0x3d	; 61
    255a:	de b7       	in	r29, 0x3e	; 62
    255c:	28 97       	sbiw	r28, 0x08	; 8
    255e:	0f b6       	in	r0, 0x3f	; 63
    2560:	f8 94       	cli
    2562:	de bf       	out	0x3e, r29	; 62
    2564:	0f be       	out	0x3f, r0	; 63
    2566:	cd bf       	out	0x3d, r28	; 61
    2568:	9e 83       	std	Y+6, r25	; 0x06
    256a:	8d 83       	std	Y+5, r24	; 0x05
    256c:	78 87       	std	Y+8, r23	; 0x08
    256e:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2570:	ef 81       	ldd	r30, Y+7	; 0x07
    2572:	f8 85       	ldd	r31, Y+8	; 0x08
    2574:	80 81       	ld	r24, Z
    2576:	91 81       	ldd	r25, Z+1	; 0x01
    2578:	9a 83       	std	Y+2, r25	; 0x02
    257a:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    257c:	89 81       	ldd	r24, Y+1	; 0x01
    257e:	9a 81       	ldd	r25, Y+2	; 0x02
    2580:	2f ef       	ldi	r18, 0xFF	; 255
    2582:	8f 3f       	cpi	r24, 0xFF	; 255
    2584:	92 07       	cpc	r25, r18
    2586:	39 f4       	brne	.+14     	; 0x2596 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2588:	ed 81       	ldd	r30, Y+5	; 0x05
    258a:	fe 81       	ldd	r31, Y+6	; 0x06
    258c:	87 81       	ldd	r24, Z+7	; 0x07
    258e:	90 85       	ldd	r25, Z+8	; 0x08
    2590:	9c 83       	std	Y+4, r25	; 0x04
    2592:	8b 83       	std	Y+3, r24	; 0x03
    2594:	18 c0       	rjmp	.+48     	; 0x25c6 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2596:	8d 81       	ldd	r24, Y+5	; 0x05
    2598:	9e 81       	ldd	r25, Y+6	; 0x06
    259a:	03 96       	adiw	r24, 0x03	; 3
    259c:	9c 83       	std	Y+4, r25	; 0x04
    259e:	8b 83       	std	Y+3, r24	; 0x03
    25a0:	06 c0       	rjmp	.+12     	; 0x25ae <vListInsert+0x5a>
    25a2:	eb 81       	ldd	r30, Y+3	; 0x03
    25a4:	fc 81       	ldd	r31, Y+4	; 0x04
    25a6:	82 81       	ldd	r24, Z+2	; 0x02
    25a8:	93 81       	ldd	r25, Z+3	; 0x03
    25aa:	9c 83       	std	Y+4, r25	; 0x04
    25ac:	8b 83       	std	Y+3, r24	; 0x03
    25ae:	eb 81       	ldd	r30, Y+3	; 0x03
    25b0:	fc 81       	ldd	r31, Y+4	; 0x04
    25b2:	02 80       	ldd	r0, Z+2	; 0x02
    25b4:	f3 81       	ldd	r31, Z+3	; 0x03
    25b6:	e0 2d       	mov	r30, r0
    25b8:	20 81       	ld	r18, Z
    25ba:	31 81       	ldd	r19, Z+1	; 0x01
    25bc:	89 81       	ldd	r24, Y+1	; 0x01
    25be:	9a 81       	ldd	r25, Y+2	; 0x02
    25c0:	82 17       	cp	r24, r18
    25c2:	93 07       	cpc	r25, r19
    25c4:	70 f7       	brcc	.-36     	; 0x25a2 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    25c6:	eb 81       	ldd	r30, Y+3	; 0x03
    25c8:	fc 81       	ldd	r31, Y+4	; 0x04
    25ca:	82 81       	ldd	r24, Z+2	; 0x02
    25cc:	93 81       	ldd	r25, Z+3	; 0x03
    25ce:	ef 81       	ldd	r30, Y+7	; 0x07
    25d0:	f8 85       	ldd	r31, Y+8	; 0x08
    25d2:	93 83       	std	Z+3, r25	; 0x03
    25d4:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    25d6:	ef 81       	ldd	r30, Y+7	; 0x07
    25d8:	f8 85       	ldd	r31, Y+8	; 0x08
    25da:	02 80       	ldd	r0, Z+2	; 0x02
    25dc:	f3 81       	ldd	r31, Z+3	; 0x03
    25de:	e0 2d       	mov	r30, r0
    25e0:	8f 81       	ldd	r24, Y+7	; 0x07
    25e2:	98 85       	ldd	r25, Y+8	; 0x08
    25e4:	95 83       	std	Z+5, r25	; 0x05
    25e6:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    25e8:	ef 81       	ldd	r30, Y+7	; 0x07
    25ea:	f8 85       	ldd	r31, Y+8	; 0x08
    25ec:	8b 81       	ldd	r24, Y+3	; 0x03
    25ee:	9c 81       	ldd	r25, Y+4	; 0x04
    25f0:	95 83       	std	Z+5, r25	; 0x05
    25f2:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    25f4:	eb 81       	ldd	r30, Y+3	; 0x03
    25f6:	fc 81       	ldd	r31, Y+4	; 0x04
    25f8:	8f 81       	ldd	r24, Y+7	; 0x07
    25fa:	98 85       	ldd	r25, Y+8	; 0x08
    25fc:	93 83       	std	Z+3, r25	; 0x03
    25fe:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    2600:	ef 81       	ldd	r30, Y+7	; 0x07
    2602:	f8 85       	ldd	r31, Y+8	; 0x08
    2604:	8d 81       	ldd	r24, Y+5	; 0x05
    2606:	9e 81       	ldd	r25, Y+6	; 0x06
    2608:	91 87       	std	Z+9, r25	; 0x09
    260a:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    260c:	ed 81       	ldd	r30, Y+5	; 0x05
    260e:	fe 81       	ldd	r31, Y+6	; 0x06
    2610:	80 81       	ld	r24, Z
    2612:	8f 5f       	subi	r24, 0xFF	; 255
    2614:	ed 81       	ldd	r30, Y+5	; 0x05
    2616:	fe 81       	ldd	r31, Y+6	; 0x06
    2618:	80 83       	st	Z, r24
}
    261a:	28 96       	adiw	r28, 0x08	; 8
    261c:	0f b6       	in	r0, 0x3f	; 63
    261e:	f8 94       	cli
    2620:	de bf       	out	0x3e, r29	; 62
    2622:	0f be       	out	0x3f, r0	; 63
    2624:	cd bf       	out	0x3d, r28	; 61
    2626:	cf 91       	pop	r28
    2628:	df 91       	pop	r29
    262a:	08 95       	ret

0000262c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    262c:	df 93       	push	r29
    262e:	cf 93       	push	r28
    2630:	00 d0       	rcall	.+0      	; 0x2632 <uxListRemove+0x6>
    2632:	00 d0       	rcall	.+0      	; 0x2634 <uxListRemove+0x8>
    2634:	cd b7       	in	r28, 0x3d	; 61
    2636:	de b7       	in	r29, 0x3e	; 62
    2638:	9c 83       	std	Y+4, r25	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    263c:	eb 81       	ldd	r30, Y+3	; 0x03
    263e:	fc 81       	ldd	r31, Y+4	; 0x04
    2640:	80 85       	ldd	r24, Z+8	; 0x08
    2642:	91 85       	ldd	r25, Z+9	; 0x09
    2644:	9a 83       	std	Y+2, r25	; 0x02
    2646:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2648:	eb 81       	ldd	r30, Y+3	; 0x03
    264a:	fc 81       	ldd	r31, Y+4	; 0x04
    264c:	a2 81       	ldd	r26, Z+2	; 0x02
    264e:	b3 81       	ldd	r27, Z+3	; 0x03
    2650:	eb 81       	ldd	r30, Y+3	; 0x03
    2652:	fc 81       	ldd	r31, Y+4	; 0x04
    2654:	84 81       	ldd	r24, Z+4	; 0x04
    2656:	95 81       	ldd	r25, Z+5	; 0x05
    2658:	15 96       	adiw	r26, 0x05	; 5
    265a:	9c 93       	st	X, r25
    265c:	8e 93       	st	-X, r24
    265e:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2660:	eb 81       	ldd	r30, Y+3	; 0x03
    2662:	fc 81       	ldd	r31, Y+4	; 0x04
    2664:	a4 81       	ldd	r26, Z+4	; 0x04
    2666:	b5 81       	ldd	r27, Z+5	; 0x05
    2668:	eb 81       	ldd	r30, Y+3	; 0x03
    266a:	fc 81       	ldd	r31, Y+4	; 0x04
    266c:	82 81       	ldd	r24, Z+2	; 0x02
    266e:	93 81       	ldd	r25, Z+3	; 0x03
    2670:	13 96       	adiw	r26, 0x03	; 3
    2672:	9c 93       	st	X, r25
    2674:	8e 93       	st	-X, r24
    2676:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2678:	e9 81       	ldd	r30, Y+1	; 0x01
    267a:	fa 81       	ldd	r31, Y+2	; 0x02
    267c:	21 81       	ldd	r18, Z+1	; 0x01
    267e:	32 81       	ldd	r19, Z+2	; 0x02
    2680:	8b 81       	ldd	r24, Y+3	; 0x03
    2682:	9c 81       	ldd	r25, Y+4	; 0x04
    2684:	28 17       	cp	r18, r24
    2686:	39 07       	cpc	r19, r25
    2688:	41 f4       	brne	.+16     	; 0x269a <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    268a:	eb 81       	ldd	r30, Y+3	; 0x03
    268c:	fc 81       	ldd	r31, Y+4	; 0x04
    268e:	84 81       	ldd	r24, Z+4	; 0x04
    2690:	95 81       	ldd	r25, Z+5	; 0x05
    2692:	e9 81       	ldd	r30, Y+1	; 0x01
    2694:	fa 81       	ldd	r31, Y+2	; 0x02
    2696:	92 83       	std	Z+2, r25	; 0x02
    2698:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    269a:	eb 81       	ldd	r30, Y+3	; 0x03
    269c:	fc 81       	ldd	r31, Y+4	; 0x04
    269e:	11 86       	std	Z+9, r1	; 0x09
    26a0:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    26a2:	e9 81       	ldd	r30, Y+1	; 0x01
    26a4:	fa 81       	ldd	r31, Y+2	; 0x02
    26a6:	80 81       	ld	r24, Z
    26a8:	81 50       	subi	r24, 0x01	; 1
    26aa:	e9 81       	ldd	r30, Y+1	; 0x01
    26ac:	fa 81       	ldd	r31, Y+2	; 0x02
    26ae:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    26b0:	e9 81       	ldd	r30, Y+1	; 0x01
    26b2:	fa 81       	ldd	r31, Y+2	; 0x02
    26b4:	80 81       	ld	r24, Z
}
    26b6:	0f 90       	pop	r0
    26b8:	0f 90       	pop	r0
    26ba:	0f 90       	pop	r0
    26bc:	0f 90       	pop	r0
    26be:	cf 91       	pop	r28
    26c0:	df 91       	pop	r29
    26c2:	08 95       	ret

000026c4 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    26c4:	df 93       	push	r29
    26c6:	cf 93       	push	r28
    26c8:	00 d0       	rcall	.+0      	; 0x26ca <xQueueGenericReset+0x6>
    26ca:	00 d0       	rcall	.+0      	; 0x26cc <xQueueGenericReset+0x8>
    26cc:	00 d0       	rcall	.+0      	; 0x26ce <xQueueGenericReset+0xa>
    26ce:	cd b7       	in	r28, 0x3d	; 61
    26d0:	de b7       	in	r29, 0x3e	; 62
    26d2:	9d 83       	std	Y+5, r25	; 0x05
    26d4:	8c 83       	std	Y+4, r24	; 0x04
    26d6:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    26d8:	81 e0       	ldi	r24, 0x01	; 1
    26da:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    26dc:	8c 81       	ldd	r24, Y+4	; 0x04
    26de:	9d 81       	ldd	r25, Y+5	; 0x05
    26e0:	9a 83       	std	Y+2, r25	; 0x02
    26e2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    26e4:	89 81       	ldd	r24, Y+1	; 0x01
    26e6:	9a 81       	ldd	r25, Y+2	; 0x02
    26e8:	00 97       	sbiw	r24, 0x00	; 0
    26ea:	09 f4       	brne	.+2      	; 0x26ee <xQueueGenericReset+0x2a>
    26ec:	8b c0       	rjmp	.+278    	; 0x2804 <xQueueGenericReset+0x140>
    26ee:	e9 81       	ldd	r30, Y+1	; 0x01
    26f0:	fa 81       	ldd	r31, Y+2	; 0x02
    26f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    26f4:	88 23       	and	r24, r24
    26f6:	09 f4       	brne	.+2      	; 0x26fa <xQueueGenericReset+0x36>
    26f8:	85 c0       	rjmp	.+266    	; 0x2804 <xQueueGenericReset+0x140>
    26fa:	e9 81       	ldd	r30, Y+1	; 0x01
    26fc:	fa 81       	ldd	r31, Y+2	; 0x02
    26fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    2700:	28 2f       	mov	r18, r24
    2702:	30 e0       	ldi	r19, 0x00	; 0
    2704:	8f ef       	ldi	r24, 0xFF	; 255
    2706:	9f e7       	ldi	r25, 0x7F	; 127
    2708:	b9 01       	movw	r22, r18
    270a:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <__udivmodhi4>
    270e:	cb 01       	movw	r24, r22
    2710:	9c 01       	movw	r18, r24
    2712:	e9 81       	ldd	r30, Y+1	; 0x01
    2714:	fa 81       	ldd	r31, Y+2	; 0x02
    2716:	84 8d       	ldd	r24, Z+28	; 0x1c
    2718:	88 2f       	mov	r24, r24
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	28 17       	cp	r18, r24
    271e:	39 07       	cpc	r19, r25
    2720:	08 f4       	brcc	.+2      	; 0x2724 <xQueueGenericReset+0x60>
    2722:	70 c0       	rjmp	.+224    	; 0x2804 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2724:	0f b6       	in	r0, 0x3f	; 63
    2726:	f8 94       	cli
    2728:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    272a:	e9 81       	ldd	r30, Y+1	; 0x01
    272c:	fa 81       	ldd	r31, Y+2	; 0x02
    272e:	40 81       	ld	r20, Z
    2730:	51 81       	ldd	r21, Z+1	; 0x01
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	83 8d       	ldd	r24, Z+27	; 0x1b
    2738:	28 2f       	mov	r18, r24
    273a:	30 e0       	ldi	r19, 0x00	; 0
    273c:	e9 81       	ldd	r30, Y+1	; 0x01
    273e:	fa 81       	ldd	r31, Y+2	; 0x02
    2740:	84 8d       	ldd	r24, Z+28	; 0x1c
    2742:	88 2f       	mov	r24, r24
    2744:	90 e0       	ldi	r25, 0x00	; 0
    2746:	bc 01       	movw	r22, r24
    2748:	26 9f       	mul	r18, r22
    274a:	c0 01       	movw	r24, r0
    274c:	27 9f       	mul	r18, r23
    274e:	90 0d       	add	r25, r0
    2750:	36 9f       	mul	r19, r22
    2752:	90 0d       	add	r25, r0
    2754:	11 24       	eor	r1, r1
    2756:	84 0f       	add	r24, r20
    2758:	95 1f       	adc	r25, r21
    275a:	e9 81       	ldd	r30, Y+1	; 0x01
    275c:	fa 81       	ldd	r31, Y+2	; 0x02
    275e:	95 83       	std	Z+5, r25	; 0x05
    2760:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2762:	e9 81       	ldd	r30, Y+1	; 0x01
    2764:	fa 81       	ldd	r31, Y+2	; 0x02
    2766:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2768:	e9 81       	ldd	r30, Y+1	; 0x01
    276a:	fa 81       	ldd	r31, Y+2	; 0x02
    276c:	80 81       	ld	r24, Z
    276e:	91 81       	ldd	r25, Z+1	; 0x01
    2770:	e9 81       	ldd	r30, Y+1	; 0x01
    2772:	fa 81       	ldd	r31, Y+2	; 0x02
    2774:	93 83       	std	Z+3, r25	; 0x03
    2776:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2778:	e9 81       	ldd	r30, Y+1	; 0x01
    277a:	fa 81       	ldd	r31, Y+2	; 0x02
    277c:	40 81       	ld	r20, Z
    277e:	51 81       	ldd	r21, Z+1	; 0x01
    2780:	e9 81       	ldd	r30, Y+1	; 0x01
    2782:	fa 81       	ldd	r31, Y+2	; 0x02
    2784:	83 8d       	ldd	r24, Z+27	; 0x1b
    2786:	88 2f       	mov	r24, r24
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	9c 01       	movw	r18, r24
    278c:	21 50       	subi	r18, 0x01	; 1
    278e:	30 40       	sbci	r19, 0x00	; 0
    2790:	e9 81       	ldd	r30, Y+1	; 0x01
    2792:	fa 81       	ldd	r31, Y+2	; 0x02
    2794:	84 8d       	ldd	r24, Z+28	; 0x1c
    2796:	88 2f       	mov	r24, r24
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	bc 01       	movw	r22, r24
    279c:	26 9f       	mul	r18, r22
    279e:	c0 01       	movw	r24, r0
    27a0:	27 9f       	mul	r18, r23
    27a2:	90 0d       	add	r25, r0
    27a4:	36 9f       	mul	r19, r22
    27a6:	90 0d       	add	r25, r0
    27a8:	11 24       	eor	r1, r1
    27aa:	84 0f       	add	r24, r20
    27ac:	95 1f       	adc	r25, r21
    27ae:	e9 81       	ldd	r30, Y+1	; 0x01
    27b0:	fa 81       	ldd	r31, Y+2	; 0x02
    27b2:	97 83       	std	Z+7, r25	; 0x07
    27b4:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    27b6:	e9 81       	ldd	r30, Y+1	; 0x01
    27b8:	fa 81       	ldd	r31, Y+2	; 0x02
    27ba:	8f ef       	ldi	r24, 0xFF	; 255
    27bc:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    27be:	e9 81       	ldd	r30, Y+1	; 0x01
    27c0:	fa 81       	ldd	r31, Y+2	; 0x02
    27c2:	8f ef       	ldi	r24, 0xFF	; 255
    27c4:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    27c6:	8e 81       	ldd	r24, Y+6	; 0x06
    27c8:	88 23       	and	r24, r24
    27ca:	79 f4       	brne	.+30     	; 0x27ea <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27cc:	e9 81       	ldd	r30, Y+1	; 0x01
    27ce:	fa 81       	ldd	r31, Y+2	; 0x02
    27d0:	80 85       	ldd	r24, Z+8	; 0x08
    27d2:	88 23       	and	r24, r24
    27d4:	a1 f0       	breq	.+40     	; 0x27fe <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    27d6:	89 81       	ldd	r24, Y+1	; 0x01
    27d8:	9a 81       	ldd	r25, Y+2	; 0x02
    27da:	08 96       	adiw	r24, 0x08	; 8
    27dc:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    27e0:	88 23       	and	r24, r24
    27e2:	69 f0       	breq	.+26     	; 0x27fe <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    27e4:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    27e8:	0a c0       	rjmp	.+20     	; 0x27fe <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	9a 81       	ldd	r25, Y+2	; 0x02
    27ee:	08 96       	adiw	r24, 0x08	; 8
    27f0:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    27f4:	89 81       	ldd	r24, Y+1	; 0x01
    27f6:	9a 81       	ldd	r25, Y+2	; 0x02
    27f8:	41 96       	adiw	r24, 0x11	; 17
    27fa:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    27fe:	0f 90       	pop	r0
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    2804:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2806:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2808:	26 96       	adiw	r28, 0x06	; 6
    280a:	0f b6       	in	r0, 0x3f	; 63
    280c:	f8 94       	cli
    280e:	de bf       	out	0x3e, r29	; 62
    2810:	0f be       	out	0x3f, r0	; 63
    2812:	cd bf       	out	0x3d, r28	; 61
    2814:	cf 91       	pop	r28
    2816:	df 91       	pop	r29
    2818:	08 95       	ret

0000281a <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    281a:	0f 93       	push	r16
    281c:	1f 93       	push	r17
    281e:	df 93       	push	r29
    2820:	cf 93       	push	r28
    2822:	cd b7       	in	r28, 0x3d	; 61
    2824:	de b7       	in	r29, 0x3e	; 62
    2826:	29 97       	sbiw	r28, 0x09	; 9
    2828:	0f b6       	in	r0, 0x3f	; 63
    282a:	f8 94       	cli
    282c:	de bf       	out	0x3e, r29	; 62
    282e:	0f be       	out	0x3f, r0	; 63
    2830:	cd bf       	out	0x3d, r28	; 61
    2832:	8f 83       	std	Y+7, r24	; 0x07
    2834:	68 87       	std	Y+8, r22	; 0x08
    2836:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    2838:	1e 82       	std	Y+6, r1	; 0x06
    283a:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    283c:	8f 81       	ldd	r24, Y+7	; 0x07
    283e:	88 23       	and	r24, r24
    2840:	09 f4       	brne	.+2      	; 0x2844 <xQueueGenericCreate+0x2a>
    2842:	52 c0       	rjmp	.+164    	; 0x28e8 <xQueueGenericCreate+0xce>
    2844:	8f 81       	ldd	r24, Y+7	; 0x07
    2846:	28 2f       	mov	r18, r24
    2848:	30 e0       	ldi	r19, 0x00	; 0
    284a:	8f ef       	ldi	r24, 0xFF	; 255
    284c:	9f e7       	ldi	r25, 0x7F	; 127
    284e:	b9 01       	movw	r22, r18
    2850:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <__udivmodhi4>
    2854:	cb 01       	movw	r24, r22
    2856:	9c 01       	movw	r18, r24
    2858:	88 85       	ldd	r24, Y+8	; 0x08
    285a:	88 2f       	mov	r24, r24
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	28 17       	cp	r18, r24
    2860:	39 07       	cpc	r19, r25
    2862:	08 f4       	brcc	.+2      	; 0x2866 <xQueueGenericCreate+0x4c>
    2864:	41 c0       	rjmp	.+130    	; 0x28e8 <xQueueGenericCreate+0xce>
    2866:	8f 81       	ldd	r24, Y+7	; 0x07
    2868:	28 2f       	mov	r18, r24
    286a:	30 e0       	ldi	r19, 0x00	; 0
    286c:	88 85       	ldd	r24, Y+8	; 0x08
    286e:	88 2f       	mov	r24, r24
    2870:	90 e0       	ldi	r25, 0x00	; 0
    2872:	ac 01       	movw	r20, r24
    2874:	24 9f       	mul	r18, r20
    2876:	c0 01       	movw	r24, r0
    2878:	25 9f       	mul	r18, r21
    287a:	90 0d       	add	r25, r0
    287c:	34 9f       	mul	r19, r20
    287e:	90 0d       	add	r25, r0
    2880:	11 24       	eor	r1, r1
    2882:	5f e7       	ldi	r21, 0x7F	; 127
    2884:	81 3e       	cpi	r24, 0xE1	; 225
    2886:	95 07       	cpc	r25, r21
    2888:	78 f5       	brcc	.+94     	; 0x28e8 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    288a:	8f 81       	ldd	r24, Y+7	; 0x07
    288c:	28 2f       	mov	r18, r24
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	88 85       	ldd	r24, Y+8	; 0x08
    2892:	88 2f       	mov	r24, r24
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	ac 01       	movw	r20, r24
    2898:	24 9f       	mul	r18, r20
    289a:	c0 01       	movw	r24, r0
    289c:	25 9f       	mul	r18, r21
    289e:	90 0d       	add	r25, r0
    28a0:	34 9f       	mul	r19, r20
    28a2:	90 0d       	add	r25, r0
    28a4:	11 24       	eor	r1, r1
    28a6:	9c 83       	std	Y+4, r25	; 0x04
    28a8:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	4f 96       	adiw	r24, 0x1f	; 31
    28b0:	0e 94 b4 08 	call	0x1168	; 0x1168 <pvPortMalloc>
    28b4:	9e 83       	std	Y+6, r25	; 0x06
    28b6:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    28b8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ba:	9e 81       	ldd	r25, Y+6	; 0x06
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	a1 f0       	breq	.+40     	; 0x28e8 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    28c0:	8d 81       	ldd	r24, Y+5	; 0x05
    28c2:	9e 81       	ldd	r25, Y+6	; 0x06
    28c4:	9a 83       	std	Y+2, r25	; 0x02
    28c6:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    28c8:	89 81       	ldd	r24, Y+1	; 0x01
    28ca:	9a 81       	ldd	r25, Y+2	; 0x02
    28cc:	4f 96       	adiw	r24, 0x1f	; 31
    28ce:	9a 83       	std	Y+2, r25	; 0x02
    28d0:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    28d2:	29 81       	ldd	r18, Y+1	; 0x01
    28d4:	3a 81       	ldd	r19, Y+2	; 0x02
    28d6:	ed 81       	ldd	r30, Y+5	; 0x05
    28d8:	fe 81       	ldd	r31, Y+6	; 0x06
    28da:	8f 81       	ldd	r24, Y+7	; 0x07
    28dc:	68 85       	ldd	r22, Y+8	; 0x08
    28de:	a9 01       	movw	r20, r18
    28e0:	29 85       	ldd	r18, Y+9	; 0x09
    28e2:	8f 01       	movw	r16, r30
    28e4:	0e 94 81 14 	call	0x2902	; 0x2902 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    28e8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ea:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    28ec:	29 96       	adiw	r28, 0x09	; 9
    28ee:	0f b6       	in	r0, 0x3f	; 63
    28f0:	f8 94       	cli
    28f2:	de bf       	out	0x3e, r29	; 62
    28f4:	0f be       	out	0x3f, r0	; 63
    28f6:	cd bf       	out	0x3d, r28	; 61
    28f8:	cf 91       	pop	r28
    28fa:	df 91       	pop	r29
    28fc:	1f 91       	pop	r17
    28fe:	0f 91       	pop	r16
    2900:	08 95       	ret

00002902 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2902:	0f 93       	push	r16
    2904:	1f 93       	push	r17
    2906:	df 93       	push	r29
    2908:	cf 93       	push	r28
    290a:	cd b7       	in	r28, 0x3d	; 61
    290c:	de b7       	in	r29, 0x3e	; 62
    290e:	27 97       	sbiw	r28, 0x07	; 7
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	de bf       	out	0x3e, r29	; 62
    2916:	0f be       	out	0x3f, r0	; 63
    2918:	cd bf       	out	0x3d, r28	; 61
    291a:	89 83       	std	Y+1, r24	; 0x01
    291c:	6a 83       	std	Y+2, r22	; 0x02
    291e:	5c 83       	std	Y+4, r21	; 0x04
    2920:	4b 83       	std	Y+3, r20	; 0x03
    2922:	2d 83       	std	Y+5, r18	; 0x05
    2924:	1f 83       	std	Y+7, r17	; 0x07
    2926:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2928:	8a 81       	ldd	r24, Y+2	; 0x02
    292a:	88 23       	and	r24, r24
    292c:	39 f4       	brne	.+14     	; 0x293c <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    292e:	8e 81       	ldd	r24, Y+6	; 0x06
    2930:	9f 81       	ldd	r25, Y+7	; 0x07
    2932:	ee 81       	ldd	r30, Y+6	; 0x06
    2934:	ff 81       	ldd	r31, Y+7	; 0x07
    2936:	91 83       	std	Z+1, r25	; 0x01
    2938:	80 83       	st	Z, r24
    293a:	06 c0       	rjmp	.+12     	; 0x2948 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    293c:	8b 81       	ldd	r24, Y+3	; 0x03
    293e:	9c 81       	ldd	r25, Y+4	; 0x04
    2940:	ee 81       	ldd	r30, Y+6	; 0x06
    2942:	ff 81       	ldd	r31, Y+7	; 0x07
    2944:	91 83       	std	Z+1, r25	; 0x01
    2946:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2948:	ee 81       	ldd	r30, Y+6	; 0x06
    294a:	ff 81       	ldd	r31, Y+7	; 0x07
    294c:	89 81       	ldd	r24, Y+1	; 0x01
    294e:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2950:	ee 81       	ldd	r30, Y+6	; 0x06
    2952:	ff 81       	ldd	r31, Y+7	; 0x07
    2954:	8a 81       	ldd	r24, Y+2	; 0x02
    2956:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2958:	8e 81       	ldd	r24, Y+6	; 0x06
    295a:	9f 81       	ldd	r25, Y+7	; 0x07
    295c:	61 e0       	ldi	r22, 0x01	; 1
    295e:	0e 94 62 13 	call	0x26c4	; 0x26c4 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2962:	27 96       	adiw	r28, 0x07	; 7
    2964:	0f b6       	in	r0, 0x3f	; 63
    2966:	f8 94       	cli
    2968:	de bf       	out	0x3e, r29	; 62
    296a:	0f be       	out	0x3f, r0	; 63
    296c:	cd bf       	out	0x3d, r28	; 61
    296e:	cf 91       	pop	r28
    2970:	df 91       	pop	r29
    2972:	1f 91       	pop	r17
    2974:	0f 91       	pop	r16
    2976:	08 95       	ret

00002978 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2978:	df 93       	push	r29
    297a:	cf 93       	push	r28
    297c:	cd b7       	in	r28, 0x3d	; 61
    297e:	de b7       	in	r29, 0x3e	; 62
    2980:	2f 97       	sbiw	r28, 0x0f	; 15
    2982:	0f b6       	in	r0, 0x3f	; 63
    2984:	f8 94       	cli
    2986:	de bf       	out	0x3e, r29	; 62
    2988:	0f be       	out	0x3f, r0	; 63
    298a:	cd bf       	out	0x3d, r28	; 61
    298c:	99 87       	std	Y+9, r25	; 0x09
    298e:	88 87       	std	Y+8, r24	; 0x08
    2990:	7b 87       	std	Y+11, r23	; 0x0b
    2992:	6a 87       	std	Y+10, r22	; 0x0a
    2994:	5d 87       	std	Y+13, r21	; 0x0d
    2996:	4c 87       	std	Y+12, r20	; 0x0c
    2998:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    299a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    299c:	88 85       	ldd	r24, Y+8	; 0x08
    299e:	99 85       	ldd	r25, Y+9	; 0x09
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	f8 94       	cli
    29a8:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    29aa:	e9 81       	ldd	r30, Y+1	; 0x01
    29ac:	fa 81       	ldd	r31, Y+2	; 0x02
    29ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    29b0:	e9 81       	ldd	r30, Y+1	; 0x01
    29b2:	fa 81       	ldd	r31, Y+2	; 0x02
    29b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    29b6:	98 17       	cp	r25, r24
    29b8:	18 f0       	brcs	.+6      	; 0x29c0 <xQueueGenericSend+0x48>
    29ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    29bc:	82 30       	cpi	r24, 0x02	; 2
    29be:	11 f5       	brne	.+68     	; 0x2a04 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    29c0:	89 81       	ldd	r24, Y+1	; 0x01
    29c2:	9a 81       	ldd	r25, Y+2	; 0x02
    29c4:	2a 85       	ldd	r18, Y+10	; 0x0a
    29c6:	3b 85       	ldd	r19, Y+11	; 0x0b
    29c8:	b9 01       	movw	r22, r18
    29ca:	4e 85       	ldd	r20, Y+14	; 0x0e
    29cc:	0e 94 12 19 	call	0x3224	; 0x3224 <prvCopyDataToQueue>
    29d0:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29d2:	e9 81       	ldd	r30, Y+1	; 0x01
    29d4:	fa 81       	ldd	r31, Y+2	; 0x02
    29d6:	81 89       	ldd	r24, Z+17	; 0x11
    29d8:	88 23       	and	r24, r24
    29da:	51 f0       	breq	.+20     	; 0x29f0 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29dc:	89 81       	ldd	r24, Y+1	; 0x01
    29de:	9a 81       	ldd	r25, Y+2	; 0x02
    29e0:	41 96       	adiw	r24, 0x11	; 17
    29e2:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    29e6:	88 23       	and	r24, r24
    29e8:	41 f0       	breq	.+16     	; 0x29fa <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    29ea:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    29ee:	05 c0       	rjmp	.+10     	; 0x29fa <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    29f0:	8b 81       	ldd	r24, Y+3	; 0x03
    29f2:	88 23       	and	r24, r24
    29f4:	11 f0       	breq	.+4      	; 0x29fa <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    29f6:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    29fa:	0f 90       	pop	r0
    29fc:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    29fe:	81 e0       	ldi	r24, 0x01	; 1
    2a00:	8f 87       	std	Y+15, r24	; 0x0f
    2a02:	5c c0       	rjmp	.+184    	; 0x2abc <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2a04:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a06:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a08:	00 97       	sbiw	r24, 0x00	; 0
    2a0a:	21 f4       	brne	.+8      	; 0x2a14 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2a0c:	0f 90       	pop	r0
    2a0e:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2a10:	1f 86       	std	Y+15, r1	; 0x0f
    2a12:	54 c0       	rjmp	.+168    	; 0x2abc <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    2a14:	8c 81       	ldd	r24, Y+4	; 0x04
    2a16:	88 23       	and	r24, r24
    2a18:	31 f4       	brne	.+12     	; 0x2a26 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2a1a:	ce 01       	movw	r24, r28
    2a1c:	05 96       	adiw	r24, 0x05	; 5
    2a1e:	0e 94 a6 25 	call	0x4b4c	; 0x4b4c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2a26:	0f 90       	pop	r0
    2a28:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2a2a:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2a2e:	0f b6       	in	r0, 0x3f	; 63
    2a30:	f8 94       	cli
    2a32:	0f 92       	push	r0
    2a34:	e9 81       	ldd	r30, Y+1	; 0x01
    2a36:	fa 81       	ldd	r31, Y+2	; 0x02
    2a38:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a3a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a3c:	19 f4       	brne	.+6      	; 0x2a44 <xQueueGenericSend+0xcc>
    2a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a40:	fa 81       	ldd	r31, Y+2	; 0x02
    2a42:	15 8e       	std	Z+29, r1	; 0x1d
    2a44:	e9 81       	ldd	r30, Y+1	; 0x01
    2a46:	fa 81       	ldd	r31, Y+2	; 0x02
    2a48:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a4a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a4c:	19 f4       	brne	.+6      	; 0x2a54 <xQueueGenericSend+0xdc>
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	16 8e       	std	Z+30, r1	; 0x1e
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2a58:	ce 01       	movw	r24, r28
    2a5a:	05 96       	adiw	r24, 0x05	; 5
    2a5c:	9e 01       	movw	r18, r28
    2a5e:	24 5f       	subi	r18, 0xF4	; 244
    2a60:	3f 4f       	sbci	r19, 0xFF	; 255
    2a62:	b9 01       	movw	r22, r18
    2a64:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <xTaskCheckForTimeOut>
    2a68:	88 23       	and	r24, r24
    2a6a:	09 f5       	brne	.+66     	; 0x2aae <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2a6c:	89 81       	ldd	r24, Y+1	; 0x01
    2a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a70:	0e 94 8e 1a 	call	0x351c	; 0x351c <prvIsQueueFull>
    2a74:	88 23       	and	r24, r24
    2a76:	a1 f0       	breq	.+40     	; 0x2aa0 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2a78:	89 81       	ldd	r24, Y+1	; 0x01
    2a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7c:	08 96       	adiw	r24, 0x08	; 8
    2a7e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2a80:	3d 85       	ldd	r19, Y+13	; 0x0d
    2a82:	b9 01       	movw	r22, r18
    2a84:	0e 94 af 22 	call	0x455e	; 0x455e <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2a88:	89 81       	ldd	r24, Y+1	; 0x01
    2a8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8c:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2a90:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2a94:	88 23       	and	r24, r24
    2a96:	09 f0       	breq	.+2      	; 0x2a9a <xQueueGenericSend+0x122>
    2a98:	85 cf       	rjmp	.-246    	; 0x29a4 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2a9a:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    2a9e:	82 cf       	rjmp	.-252    	; 0x29a4 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2aa0:	89 81       	ldd	r24, Y+1	; 0x01
    2aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2aa8:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2aac:	7b cf       	rjmp	.-266    	; 0x29a4 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2aae:	89 81       	ldd	r24, Y+1	; 0x01
    2ab0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab2:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2ab6:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2aba:	1f 86       	std	Y+15, r1	; 0x0f
    2abc:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2abe:	2f 96       	adiw	r28, 0x0f	; 15
    2ac0:	0f b6       	in	r0, 0x3f	; 63
    2ac2:	f8 94       	cli
    2ac4:	de bf       	out	0x3e, r29	; 62
    2ac6:	0f be       	out	0x3f, r0	; 63
    2ac8:	cd bf       	out	0x3d, r28	; 61
    2aca:	cf 91       	pop	r28
    2acc:	df 91       	pop	r29
    2ace:	08 95       	ret

00002ad0 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2ad0:	df 93       	push	r29
    2ad2:	cf 93       	push	r28
    2ad4:	cd b7       	in	r28, 0x3d	; 61
    2ad6:	de b7       	in	r29, 0x3e	; 62
    2ad8:	2d 97       	sbiw	r28, 0x0d	; 13
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	de bf       	out	0x3e, r29	; 62
    2ae0:	0f be       	out	0x3f, r0	; 63
    2ae2:	cd bf       	out	0x3d, r28	; 61
    2ae4:	98 87       	std	Y+8, r25	; 0x08
    2ae6:	8f 83       	std	Y+7, r24	; 0x07
    2ae8:	7a 87       	std	Y+10, r23	; 0x0a
    2aea:	69 87       	std	Y+9, r22	; 0x09
    2aec:	5c 87       	std	Y+12, r21	; 0x0c
    2aee:	4b 87       	std	Y+11, r20	; 0x0b
    2af0:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2af2:	8f 81       	ldd	r24, Y+7	; 0x07
    2af4:	98 85       	ldd	r25, Y+8	; 0x08
    2af6:	9c 83       	std	Y+4, r25	; 0x04
    2af8:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2afa:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2afc:	eb 81       	ldd	r30, Y+3	; 0x03
    2afe:	fc 81       	ldd	r31, Y+4	; 0x04
    2b00:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b02:	eb 81       	ldd	r30, Y+3	; 0x03
    2b04:	fc 81       	ldd	r31, Y+4	; 0x04
    2b06:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b08:	98 17       	cp	r25, r24
    2b0a:	18 f0       	brcs	.+6      	; 0x2b12 <xQueueGenericSendFromISR+0x42>
    2b0c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b0e:	82 30       	cpi	r24, 0x02	; 2
    2b10:	81 f5       	brne	.+96     	; 0x2b72 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2b12:	eb 81       	ldd	r30, Y+3	; 0x03
    2b14:	fc 81       	ldd	r31, Y+4	; 0x04
    2b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b18:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b20:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2b22:	8b 81       	ldd	r24, Y+3	; 0x03
    2b24:	9c 81       	ldd	r25, Y+4	; 0x04
    2b26:	29 85       	ldd	r18, Y+9	; 0x09
    2b28:	3a 85       	ldd	r19, Y+10	; 0x0a
    2b2a:	b9 01       	movw	r22, r18
    2b2c:	4d 85       	ldd	r20, Y+13	; 0x0d
    2b2e:	0e 94 12 19 	call	0x3224	; 0x3224 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2b32:	8a 81       	ldd	r24, Y+2	; 0x02
    2b34:	8f 3f       	cpi	r24, 0xFF	; 255
    2b36:	a9 f4       	brne	.+42     	; 0x2b62 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b38:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b3c:	81 89       	ldd	r24, Z+17	; 0x11
    2b3e:	88 23       	and	r24, r24
    2b40:	a9 f0       	breq	.+42     	; 0x2b6c <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b42:	8b 81       	ldd	r24, Y+3	; 0x03
    2b44:	9c 81       	ldd	r25, Y+4	; 0x04
    2b46:	41 96       	adiw	r24, 0x11	; 17
    2b48:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    2b4c:	88 23       	and	r24, r24
    2b4e:	71 f0       	breq	.+28     	; 0x2b6c <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2b50:	8b 85       	ldd	r24, Y+11	; 0x0b
    2b52:	9c 85       	ldd	r25, Y+12	; 0x0c
    2b54:	00 97       	sbiw	r24, 0x00	; 0
    2b56:	51 f0       	breq	.+20     	; 0x2b6c <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2b58:	eb 85       	ldd	r30, Y+11	; 0x0b
    2b5a:	fc 85       	ldd	r31, Y+12	; 0x0c
    2b5c:	81 e0       	ldi	r24, 0x01	; 1
    2b5e:	80 83       	st	Z, r24
    2b60:	05 c0       	rjmp	.+10     	; 0x2b6c <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2b62:	8a 81       	ldd	r24, Y+2	; 0x02
    2b64:	8f 5f       	subi	r24, 0xFF	; 255
    2b66:	eb 81       	ldd	r30, Y+3	; 0x03
    2b68:	fc 81       	ldd	r31, Y+4	; 0x04
    2b6a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2b6c:	81 e0       	ldi	r24, 0x01	; 1
    2b6e:	8e 83       	std	Y+6, r24	; 0x06
    2b70:	01 c0       	rjmp	.+2      	; 0x2b74 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2b72:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2b74:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2b76:	2d 96       	adiw	r28, 0x0d	; 13
    2b78:	0f b6       	in	r0, 0x3f	; 63
    2b7a:	f8 94       	cli
    2b7c:	de bf       	out	0x3e, r29	; 62
    2b7e:	0f be       	out	0x3f, r0	; 63
    2b80:	cd bf       	out	0x3d, r28	; 61
    2b82:	cf 91       	pop	r28
    2b84:	df 91       	pop	r29
    2b86:	08 95       	ret

00002b88 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2b88:	df 93       	push	r29
    2b8a:	cf 93       	push	r28
    2b8c:	cd b7       	in	r28, 0x3d	; 61
    2b8e:	de b7       	in	r29, 0x3e	; 62
    2b90:	2a 97       	sbiw	r28, 0x0a	; 10
    2b92:	0f b6       	in	r0, 0x3f	; 63
    2b94:	f8 94       	cli
    2b96:	de bf       	out	0x3e, r29	; 62
    2b98:	0f be       	out	0x3f, r0	; 63
    2b9a:	cd bf       	out	0x3d, r28	; 61
    2b9c:	98 87       	std	Y+8, r25	; 0x08
    2b9e:	8f 83       	std	Y+7, r24	; 0x07
    2ba0:	7a 87       	std	Y+10, r23	; 0x0a
    2ba2:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2ba4:	8f 81       	ldd	r24, Y+7	; 0x07
    2ba6:	98 85       	ldd	r25, Y+8	; 0x08
    2ba8:	9c 83       	std	Y+4, r25	; 0x04
    2baa:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2bac:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bae:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bb4:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2bb6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bba:	93 8d       	ldd	r25, Z+27	; 0x1b
    2bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bbe:	89 17       	cp	r24, r25
    2bc0:	48 f5       	brcc	.+82     	; 0x2c14 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2bc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc6:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bc8:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2bca:	8a 81       	ldd	r24, Y+2	; 0x02
    2bcc:	8f 5f       	subi	r24, 0xFF	; 255
    2bce:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd2:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2bd4:	89 81       	ldd	r24, Y+1	; 0x01
    2bd6:	8f 3f       	cpi	r24, 0xFF	; 255
    2bd8:	a9 f4       	brne	.+42     	; 0x2c04 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bda:	eb 81       	ldd	r30, Y+3	; 0x03
    2bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    2bde:	81 89       	ldd	r24, Z+17	; 0x11
    2be0:	88 23       	and	r24, r24
    2be2:	a9 f0       	breq	.+42     	; 0x2c0e <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2be4:	8b 81       	ldd	r24, Y+3	; 0x03
    2be6:	9c 81       	ldd	r25, Y+4	; 0x04
    2be8:	41 96       	adiw	r24, 0x11	; 17
    2bea:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    2bee:	88 23       	and	r24, r24
    2bf0:	71 f0       	breq	.+28     	; 0x2c0e <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2bf2:	89 85       	ldd	r24, Y+9	; 0x09
    2bf4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf6:	00 97       	sbiw	r24, 0x00	; 0
    2bf8:	51 f0       	breq	.+20     	; 0x2c0e <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2bfa:	e9 85       	ldd	r30, Y+9	; 0x09
    2bfc:	fa 85       	ldd	r31, Y+10	; 0x0a
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	80 83       	st	Z, r24
    2c02:	05 c0       	rjmp	.+10     	; 0x2c0e <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2c04:	89 81       	ldd	r24, Y+1	; 0x01
    2c06:	8f 5f       	subi	r24, 0xFF	; 255
    2c08:	eb 81       	ldd	r30, Y+3	; 0x03
    2c0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c0c:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	8e 83       	std	Y+6, r24	; 0x06
    2c12:	01 c0       	rjmp	.+2      	; 0x2c16 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2c14:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2c16:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2c18:	2a 96       	adiw	r28, 0x0a	; 10
    2c1a:	0f b6       	in	r0, 0x3f	; 63
    2c1c:	f8 94       	cli
    2c1e:	de bf       	out	0x3e, r29	; 62
    2c20:	0f be       	out	0x3f, r0	; 63
    2c22:	cd bf       	out	0x3d, r28	; 61
    2c24:	cf 91       	pop	r28
    2c26:	df 91       	pop	r29
    2c28:	08 95       	ret

00002c2a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2c2a:	df 93       	push	r29
    2c2c:	cf 93       	push	r28
    2c2e:	cd b7       	in	r28, 0x3d	; 61
    2c30:	de b7       	in	r29, 0x3e	; 62
    2c32:	2e 97       	sbiw	r28, 0x0e	; 14
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	f8 94       	cli
    2c38:	de bf       	out	0x3e, r29	; 62
    2c3a:	0f be       	out	0x3f, r0	; 63
    2c3c:	cd bf       	out	0x3d, r28	; 61
    2c3e:	99 87       	std	Y+9, r25	; 0x09
    2c40:	88 87       	std	Y+8, r24	; 0x08
    2c42:	7b 87       	std	Y+11, r23	; 0x0b
    2c44:	6a 87       	std	Y+10, r22	; 0x0a
    2c46:	5d 87       	std	Y+13, r21	; 0x0d
    2c48:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2c4a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2c4c:	88 85       	ldd	r24, Y+8	; 0x08
    2c4e:	99 85       	ldd	r25, Y+9	; 0x09
    2c50:	9b 83       	std	Y+3, r25	; 0x03
    2c52:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2c54:	0f b6       	in	r0, 0x3f	; 63
    2c56:	f8 94       	cli
    2c58:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c60:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2c62:	89 81       	ldd	r24, Y+1	; 0x01
    2c64:	88 23       	and	r24, r24
    2c66:	f9 f0       	breq	.+62     	; 0x2ca6 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2c68:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c6c:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c6e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2c70:	b9 01       	movw	r22, r18
    2c72:	0e 94 b8 19 	call	0x3370	; 0x3370 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2c76:	89 81       	ldd	r24, Y+1	; 0x01
    2c78:	81 50       	subi	r24, 0x01	; 1
    2c7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c7e:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c80:	ea 81       	ldd	r30, Y+2	; 0x02
    2c82:	fb 81       	ldd	r31, Y+3	; 0x03
    2c84:	80 85       	ldd	r24, Z+8	; 0x08
    2c86:	88 23       	and	r24, r24
    2c88:	49 f0       	breq	.+18     	; 0x2c9c <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8e:	08 96       	adiw	r24, 0x08	; 8
    2c90:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    2c94:	88 23       	and	r24, r24
    2c96:	11 f0       	breq	.+4      	; 0x2c9c <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2c98:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2c9c:	0f 90       	pop	r0
    2c9e:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2ca0:	81 e0       	ldi	r24, 0x01	; 1
    2ca2:	8e 87       	std	Y+14, r24	; 0x0e
    2ca4:	63 c0       	rjmp	.+198    	; 0x2d6c <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ca6:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ca8:	9d 85       	ldd	r25, Y+13	; 0x0d
    2caa:	00 97       	sbiw	r24, 0x00	; 0
    2cac:	21 f4       	brne	.+8      	; 0x2cb6 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2cae:	0f 90       	pop	r0
    2cb0:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2cb2:	1e 86       	std	Y+14, r1	; 0x0e
    2cb4:	5b c0       	rjmp	.+182    	; 0x2d6c <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    2cb6:	8c 81       	ldd	r24, Y+4	; 0x04
    2cb8:	88 23       	and	r24, r24
    2cba:	31 f4       	brne	.+12     	; 0x2cc8 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2cbc:	ce 01       	movw	r24, r28
    2cbe:	05 96       	adiw	r24, 0x05	; 5
    2cc0:	0e 94 a6 25 	call	0x4b4c	; 0x4b4c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2cc8:	0f 90       	pop	r0
    2cca:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2ccc:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2cd0:	0f b6       	in	r0, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	0f 92       	push	r0
    2cd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cda:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cdc:	8f 3f       	cpi	r24, 0xFF	; 255
    2cde:	19 f4       	brne	.+6      	; 0x2ce6 <xQueueReceive+0xbc>
    2ce0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ce2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ce4:	15 8e       	std	Z+29, r1	; 0x1d
    2ce6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ce8:	fb 81       	ldd	r31, Y+3	; 0x03
    2cea:	86 8d       	ldd	r24, Z+30	; 0x1e
    2cec:	8f 3f       	cpi	r24, 0xFF	; 255
    2cee:	19 f4       	brne	.+6      	; 0x2cf6 <xQueueReceive+0xcc>
    2cf0:	ea 81       	ldd	r30, Y+2	; 0x02
    2cf2:	fb 81       	ldd	r31, Y+3	; 0x03
    2cf4:	16 8e       	std	Z+30, r1	; 0x1e
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2cfa:	ce 01       	movw	r24, r28
    2cfc:	05 96       	adiw	r24, 0x05	; 5
    2cfe:	9e 01       	movw	r18, r28
    2d00:	24 5f       	subi	r18, 0xF4	; 244
    2d02:	3f 4f       	sbci	r19, 0xFF	; 255
    2d04:	b9 01       	movw	r22, r18
    2d06:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <xTaskCheckForTimeOut>
    2d0a:	88 23       	and	r24, r24
    2d0c:	09 f5       	brne	.+66     	; 0x2d50 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d10:	9b 81       	ldd	r25, Y+3	; 0x03
    2d12:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    2d16:	88 23       	and	r24, r24
    2d18:	a1 f0       	breq	.+40     	; 0x2d42 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2d1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d1e:	41 96       	adiw	r24, 0x11	; 17
    2d20:	2c 85       	ldd	r18, Y+12	; 0x0c
    2d22:	3d 85       	ldd	r19, Y+13	; 0x0d
    2d24:	b9 01       	movw	r22, r18
    2d26:	0e 94 af 22 	call	0x455e	; 0x455e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2d2a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d2e:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2d32:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2d36:	88 23       	and	r24, r24
    2d38:	09 f0       	breq	.+2      	; 0x2d3c <xQueueReceive+0x112>
    2d3a:	8c cf       	rjmp	.-232    	; 0x2c54 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2d3c:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    2d40:	89 cf       	rjmp	.-238    	; 0x2c54 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2d42:	8a 81       	ldd	r24, Y+2	; 0x02
    2d44:	9b 81       	ldd	r25, Y+3	; 0x03
    2d46:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2d4a:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2d4e:	82 cf       	rjmp	.-252    	; 0x2c54 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2d50:	8a 81       	ldd	r24, Y+2	; 0x02
    2d52:	9b 81       	ldd	r25, Y+3	; 0x03
    2d54:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2d58:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d60:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    2d64:	88 23       	and	r24, r24
    2d66:	09 f4       	brne	.+2      	; 0x2d6a <xQueueReceive+0x140>
    2d68:	75 cf       	rjmp	.-278    	; 0x2c54 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2d6a:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2d6c:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2d6e:	2e 96       	adiw	r28, 0x0e	; 14
    2d70:	0f b6       	in	r0, 0x3f	; 63
    2d72:	f8 94       	cli
    2d74:	de bf       	out	0x3e, r29	; 62
    2d76:	0f be       	out	0x3f, r0	; 63
    2d78:	cd bf       	out	0x3d, r28	; 61
    2d7a:	cf 91       	pop	r28
    2d7c:	df 91       	pop	r29
    2d7e:	08 95       	ret

00002d80 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2d80:	df 93       	push	r29
    2d82:	cf 93       	push	r28
    2d84:	cd b7       	in	r28, 0x3d	; 61
    2d86:	de b7       	in	r29, 0x3e	; 62
    2d88:	2c 97       	sbiw	r28, 0x0c	; 12
    2d8a:	0f b6       	in	r0, 0x3f	; 63
    2d8c:	f8 94       	cli
    2d8e:	de bf       	out	0x3e, r29	; 62
    2d90:	0f be       	out	0x3f, r0	; 63
    2d92:	cd bf       	out	0x3d, r28	; 61
    2d94:	99 87       	std	Y+9, r25	; 0x09
    2d96:	88 87       	std	Y+8, r24	; 0x08
    2d98:	7b 87       	std	Y+11, r23	; 0x0b
    2d9a:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2d9c:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2d9e:	88 85       	ldd	r24, Y+8	; 0x08
    2da0:	99 85       	ldd	r25, Y+9	; 0x09
    2da2:	9b 83       	std	Y+3, r25	; 0x03
    2da4:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2dac:	ea 81       	ldd	r30, Y+2	; 0x02
    2dae:	fb 81       	ldd	r31, Y+3	; 0x03
    2db0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2db2:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2db4:	89 81       	ldd	r24, Y+1	; 0x01
    2db6:	88 23       	and	r24, r24
    2db8:	c1 f0       	breq	.+48     	; 0x2dea <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2dba:	89 81       	ldd	r24, Y+1	; 0x01
    2dbc:	81 50       	subi	r24, 0x01	; 1
    2dbe:	ea 81       	ldd	r30, Y+2	; 0x02
    2dc0:	fb 81       	ldd	r31, Y+3	; 0x03
    2dc2:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2dc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2dc8:	80 85       	ldd	r24, Z+8	; 0x08
    2dca:	88 23       	and	r24, r24
    2dcc:	49 f0       	breq	.+18     	; 0x2de0 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2dce:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd0:	9b 81       	ldd	r25, Y+3	; 0x03
    2dd2:	08 96       	adiw	r24, 0x08	; 8
    2dd4:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    2dd8:	88 23       	and	r24, r24
    2dda:	11 f0       	breq	.+4      	; 0x2de0 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2ddc:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2de0:	0f 90       	pop	r0
    2de2:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2de4:	81 e0       	ldi	r24, 0x01	; 1
    2de6:	8c 87       	std	Y+12, r24	; 0x0c
    2de8:	63 c0       	rjmp	.+198    	; 0x2eb0 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2dea:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dec:	9b 85       	ldd	r25, Y+11	; 0x0b
    2dee:	00 97       	sbiw	r24, 0x00	; 0
    2df0:	21 f4       	brne	.+8      	; 0x2dfa <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2df2:	0f 90       	pop	r0
    2df4:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2df6:	1c 86       	std	Y+12, r1	; 0x0c
    2df8:	5b c0       	rjmp	.+182    	; 0x2eb0 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    2dfc:	88 23       	and	r24, r24
    2dfe:	31 f4       	brne	.+12     	; 0x2e0c <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2e00:	ce 01       	movw	r24, r28
    2e02:	05 96       	adiw	r24, 0x05	; 5
    2e04:	0e 94 a6 25 	call	0x4b4c	; 0x4b4c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2e0c:	0f 90       	pop	r0
    2e0e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2e10:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2e14:	0f b6       	in	r0, 0x3f	; 63
    2e16:	f8 94       	cli
    2e18:	0f 92       	push	r0
    2e1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e20:	8f 3f       	cpi	r24, 0xFF	; 255
    2e22:	19 f4       	brne	.+6      	; 0x2e2a <xQueueSemaphoreTake+0xaa>
    2e24:	ea 81       	ldd	r30, Y+2	; 0x02
    2e26:	fb 81       	ldd	r31, Y+3	; 0x03
    2e28:	15 8e       	std	Z+29, r1	; 0x1d
    2e2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e30:	8f 3f       	cpi	r24, 0xFF	; 255
    2e32:	19 f4       	brne	.+6      	; 0x2e3a <xQueueSemaphoreTake+0xba>
    2e34:	ea 81       	ldd	r30, Y+2	; 0x02
    2e36:	fb 81       	ldd	r31, Y+3	; 0x03
    2e38:	16 8e       	std	Z+30, r1	; 0x1e
    2e3a:	0f 90       	pop	r0
    2e3c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e3e:	ce 01       	movw	r24, r28
    2e40:	05 96       	adiw	r24, 0x05	; 5
    2e42:	9e 01       	movw	r18, r28
    2e44:	26 5f       	subi	r18, 0xF6	; 246
    2e46:	3f 4f       	sbci	r19, 0xFF	; 255
    2e48:	b9 01       	movw	r22, r18
    2e4a:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <xTaskCheckForTimeOut>
    2e4e:	88 23       	and	r24, r24
    2e50:	09 f5       	brne	.+66     	; 0x2e94 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e52:	8a 81       	ldd	r24, Y+2	; 0x02
    2e54:	9b 81       	ldd	r25, Y+3	; 0x03
    2e56:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    2e5a:	88 23       	and	r24, r24
    2e5c:	a1 f0       	breq	.+40     	; 0x2e86 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	9b 81       	ldd	r25, Y+3	; 0x03
    2e62:	41 96       	adiw	r24, 0x11	; 17
    2e64:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e66:	3b 85       	ldd	r19, Y+11	; 0x0b
    2e68:	b9 01       	movw	r22, r18
    2e6a:	0e 94 af 22 	call	0x455e	; 0x455e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e70:	9b 81       	ldd	r25, Y+3	; 0x03
    2e72:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2e76:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2e7a:	88 23       	and	r24, r24
    2e7c:	09 f0       	breq	.+2      	; 0x2e80 <xQueueSemaphoreTake+0x100>
    2e7e:	93 cf       	rjmp	.-218    	; 0x2da6 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2e80:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    2e84:	90 cf       	rjmp	.-224    	; 0x2da6 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2e86:	8a 81       	ldd	r24, Y+2	; 0x02
    2e88:	9b 81       	ldd	r25, Y+3	; 0x03
    2e8a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2e8e:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2e92:	89 cf       	rjmp	.-238    	; 0x2da6 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2e94:	8a 81       	ldd	r24, Y+2	; 0x02
    2e96:	9b 81       	ldd	r25, Y+3	; 0x03
    2e98:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2e9c:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea4:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    2ea8:	88 23       	and	r24, r24
    2eaa:	09 f4       	brne	.+2      	; 0x2eae <xQueueSemaphoreTake+0x12e>
    2eac:	7c cf       	rjmp	.-264    	; 0x2da6 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2eae:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2eb0:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2eb2:	2c 96       	adiw	r28, 0x0c	; 12
    2eb4:	0f b6       	in	r0, 0x3f	; 63
    2eb6:	f8 94       	cli
    2eb8:	de bf       	out	0x3e, r29	; 62
    2eba:	0f be       	out	0x3f, r0	; 63
    2ebc:	cd bf       	out	0x3d, r28	; 61
    2ebe:	cf 91       	pop	r28
    2ec0:	df 91       	pop	r29
    2ec2:	08 95       	ret

00002ec4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2ec4:	df 93       	push	r29
    2ec6:	cf 93       	push	r28
    2ec8:	cd b7       	in	r28, 0x3d	; 61
    2eca:	de b7       	in	r29, 0x3e	; 62
    2ecc:	60 97       	sbiw	r28, 0x10	; 16
    2ece:	0f b6       	in	r0, 0x3f	; 63
    2ed0:	f8 94       	cli
    2ed2:	de bf       	out	0x3e, r29	; 62
    2ed4:	0f be       	out	0x3f, r0	; 63
    2ed6:	cd bf       	out	0x3d, r28	; 61
    2ed8:	9b 87       	std	Y+11, r25	; 0x0b
    2eda:	8a 87       	std	Y+10, r24	; 0x0a
    2edc:	7d 87       	std	Y+13, r23	; 0x0d
    2ede:	6c 87       	std	Y+12, r22	; 0x0c
    2ee0:	5f 87       	std	Y+15, r21	; 0x0f
    2ee2:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2ee4:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2ee6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ee8:	9b 85       	ldd	r25, Y+11	; 0x0b
    2eea:	9b 83       	std	Y+3, r25	; 0x03
    2eec:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2eee:	0f b6       	in	r0, 0x3f	; 63
    2ef0:	f8 94       	cli
    2ef2:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2efa:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2efc:	89 81       	ldd	r24, Y+1	; 0x01
    2efe:	88 23       	and	r24, r24
    2f00:	31 f1       	breq	.+76     	; 0x2f4e <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2f02:	ea 81       	ldd	r30, Y+2	; 0x02
    2f04:	fb 81       	ldd	r31, Y+3	; 0x03
    2f06:	86 81       	ldd	r24, Z+6	; 0x06
    2f08:	97 81       	ldd	r25, Z+7	; 0x07
    2f0a:	9d 83       	std	Y+5, r25	; 0x05
    2f0c:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f10:	9b 81       	ldd	r25, Y+3	; 0x03
    2f12:	2c 85       	ldd	r18, Y+12	; 0x0c
    2f14:	3d 85       	ldd	r19, Y+13	; 0x0d
    2f16:	b9 01       	movw	r22, r18
    2f18:	0e 94 b8 19 	call	0x3370	; 0x3370 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2f1c:	ea 81       	ldd	r30, Y+2	; 0x02
    2f1e:	fb 81       	ldd	r31, Y+3	; 0x03
    2f20:	8c 81       	ldd	r24, Y+4	; 0x04
    2f22:	9d 81       	ldd	r25, Y+5	; 0x05
    2f24:	97 83       	std	Z+7, r25	; 0x07
    2f26:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f28:	ea 81       	ldd	r30, Y+2	; 0x02
    2f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f2c:	81 89       	ldd	r24, Z+17	; 0x11
    2f2e:	88 23       	and	r24, r24
    2f30:	49 f0       	breq	.+18     	; 0x2f44 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f32:	8a 81       	ldd	r24, Y+2	; 0x02
    2f34:	9b 81       	ldd	r25, Y+3	; 0x03
    2f36:	41 96       	adiw	r24, 0x11	; 17
    2f38:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    2f3c:	88 23       	and	r24, r24
    2f3e:	11 f0       	breq	.+4      	; 0x2f44 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2f40:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2f44:	0f 90       	pop	r0
    2f46:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2f48:	81 e0       	ldi	r24, 0x01	; 1
    2f4a:	88 8b       	std	Y+16, r24	; 0x10
    2f4c:	63 c0       	rjmp	.+198    	; 0x3014 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2f4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f50:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f52:	00 97       	sbiw	r24, 0x00	; 0
    2f54:	21 f4       	brne	.+8      	; 0x2f5e <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2f56:	0f 90       	pop	r0
    2f58:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2f5a:	18 8a       	std	Y+16, r1	; 0x10
    2f5c:	5b c0       	rjmp	.+182    	; 0x3014 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2f5e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f60:	88 23       	and	r24, r24
    2f62:	31 f4       	brne	.+12     	; 0x2f70 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2f64:	ce 01       	movw	r24, r28
    2f66:	07 96       	adiw	r24, 0x07	; 7
    2f68:	0e 94 a6 25 	call	0x4b4c	; 0x4b4c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2f6c:	81 e0       	ldi	r24, 0x01	; 1
    2f6e:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2f70:	0f 90       	pop	r0
    2f72:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2f74:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2f78:	0f b6       	in	r0, 0x3f	; 63
    2f7a:	f8 94       	cli
    2f7c:	0f 92       	push	r0
    2f7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f80:	fb 81       	ldd	r31, Y+3	; 0x03
    2f82:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f84:	8f 3f       	cpi	r24, 0xFF	; 255
    2f86:	19 f4       	brne	.+6      	; 0x2f8e <xQueuePeek+0xca>
    2f88:	ea 81       	ldd	r30, Y+2	; 0x02
    2f8a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f8c:	15 8e       	std	Z+29, r1	; 0x1d
    2f8e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f90:	fb 81       	ldd	r31, Y+3	; 0x03
    2f92:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f94:	8f 3f       	cpi	r24, 0xFF	; 255
    2f96:	19 f4       	brne	.+6      	; 0x2f9e <xQueuePeek+0xda>
    2f98:	ea 81       	ldd	r30, Y+2	; 0x02
    2f9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f9c:	16 8e       	std	Z+30, r1	; 0x1e
    2f9e:	0f 90       	pop	r0
    2fa0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2fa2:	ce 01       	movw	r24, r28
    2fa4:	07 96       	adiw	r24, 0x07	; 7
    2fa6:	9e 01       	movw	r18, r28
    2fa8:	22 5f       	subi	r18, 0xF2	; 242
    2faa:	3f 4f       	sbci	r19, 0xFF	; 255
    2fac:	b9 01       	movw	r22, r18
    2fae:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <xTaskCheckForTimeOut>
    2fb2:	88 23       	and	r24, r24
    2fb4:	09 f5       	brne	.+66     	; 0x2ff8 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb8:	9b 81       	ldd	r25, Y+3	; 0x03
    2fba:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    2fbe:	88 23       	and	r24, r24
    2fc0:	a1 f0       	breq	.+40     	; 0x2fea <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fc4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fc6:	41 96       	adiw	r24, 0x11	; 17
    2fc8:	2e 85       	ldd	r18, Y+14	; 0x0e
    2fca:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fcc:	b9 01       	movw	r22, r18
    2fce:	0e 94 af 22 	call	0x455e	; 0x455e <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fd6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2fda:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2fde:	88 23       	and	r24, r24
    2fe0:	09 f0       	breq	.+2      	; 0x2fe4 <xQueuePeek+0x120>
    2fe2:	85 cf       	rjmp	.-246    	; 0x2eee <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2fe4:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    2fe8:	82 cf       	rjmp	.-252    	; 0x2eee <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2fea:	8a 81       	ldd	r24, Y+2	; 0x02
    2fec:	9b 81       	ldd	r25, Y+3	; 0x03
    2fee:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2ff2:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    2ff6:	7b cf       	rjmp	.-266    	; 0x2eee <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    2ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    2ffc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3000:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3004:	8a 81       	ldd	r24, Y+2	; 0x02
    3006:	9b 81       	ldd	r25, Y+3	; 0x03
    3008:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <prvIsQueueEmpty>
    300c:	88 23       	and	r24, r24
    300e:	09 f4       	brne	.+2      	; 0x3012 <xQueuePeek+0x14e>
    3010:	6e cf       	rjmp	.-292    	; 0x2eee <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3012:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3014:	88 89       	ldd	r24, Y+16	; 0x10
}
    3016:	60 96       	adiw	r28, 0x10	; 16
    3018:	0f b6       	in	r0, 0x3f	; 63
    301a:	f8 94       	cli
    301c:	de bf       	out	0x3e, r29	; 62
    301e:	0f be       	out	0x3f, r0	; 63
    3020:	cd bf       	out	0x3d, r28	; 61
    3022:	cf 91       	pop	r28
    3024:	df 91       	pop	r29
    3026:	08 95       	ret

00003028 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3028:	df 93       	push	r29
    302a:	cf 93       	push	r28
    302c:	cd b7       	in	r28, 0x3d	; 61
    302e:	de b7       	in	r29, 0x3e	; 62
    3030:	2c 97       	sbiw	r28, 0x0c	; 12
    3032:	0f b6       	in	r0, 0x3f	; 63
    3034:	f8 94       	cli
    3036:	de bf       	out	0x3e, r29	; 62
    3038:	0f be       	out	0x3f, r0	; 63
    303a:	cd bf       	out	0x3d, r28	; 61
    303c:	98 87       	std	Y+8, r25	; 0x08
    303e:	8f 83       	std	Y+7, r24	; 0x07
    3040:	7a 87       	std	Y+10, r23	; 0x0a
    3042:	69 87       	std	Y+9, r22	; 0x09
    3044:	5c 87       	std	Y+12, r21	; 0x0c
    3046:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3048:	8f 81       	ldd	r24, Y+7	; 0x07
    304a:	98 85       	ldd	r25, Y+8	; 0x08
    304c:	9c 83       	std	Y+4, r25	; 0x04
    304e:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3050:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3052:	eb 81       	ldd	r30, Y+3	; 0x03
    3054:	fc 81       	ldd	r31, Y+4	; 0x04
    3056:	82 8d       	ldd	r24, Z+26	; 0x1a
    3058:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    305a:	8a 81       	ldd	r24, Y+2	; 0x02
    305c:	88 23       	and	r24, r24
    305e:	81 f1       	breq	.+96     	; 0x30c0 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3060:	eb 81       	ldd	r30, Y+3	; 0x03
    3062:	fc 81       	ldd	r31, Y+4	; 0x04
    3064:	85 8d       	ldd	r24, Z+29	; 0x1d
    3066:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3068:	8b 81       	ldd	r24, Y+3	; 0x03
    306a:	9c 81       	ldd	r25, Y+4	; 0x04
    306c:	29 85       	ldd	r18, Y+9	; 0x09
    306e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3070:	b9 01       	movw	r22, r18
    3072:	0e 94 b8 19 	call	0x3370	; 0x3370 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3076:	8a 81       	ldd	r24, Y+2	; 0x02
    3078:	81 50       	subi	r24, 0x01	; 1
    307a:	eb 81       	ldd	r30, Y+3	; 0x03
    307c:	fc 81       	ldd	r31, Y+4	; 0x04
    307e:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3080:	89 81       	ldd	r24, Y+1	; 0x01
    3082:	8f 3f       	cpi	r24, 0xFF	; 255
    3084:	a9 f4       	brne	.+42     	; 0x30b0 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3086:	eb 81       	ldd	r30, Y+3	; 0x03
    3088:	fc 81       	ldd	r31, Y+4	; 0x04
    308a:	80 85       	ldd	r24, Z+8	; 0x08
    308c:	88 23       	and	r24, r24
    308e:	a9 f0       	breq	.+42     	; 0x30ba <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3090:	8b 81       	ldd	r24, Y+3	; 0x03
    3092:	9c 81       	ldd	r25, Y+4	; 0x04
    3094:	08 96       	adiw	r24, 0x08	; 8
    3096:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    309a:	88 23       	and	r24, r24
    309c:	71 f0       	breq	.+28     	; 0x30ba <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    309e:	8b 85       	ldd	r24, Y+11	; 0x0b
    30a0:	9c 85       	ldd	r25, Y+12	; 0x0c
    30a2:	00 97       	sbiw	r24, 0x00	; 0
    30a4:	51 f0       	breq	.+20     	; 0x30ba <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    30a6:	eb 85       	ldd	r30, Y+11	; 0x0b
    30a8:	fc 85       	ldd	r31, Y+12	; 0x0c
    30aa:	81 e0       	ldi	r24, 0x01	; 1
    30ac:	80 83       	st	Z, r24
    30ae:	05 c0       	rjmp	.+10     	; 0x30ba <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    30b0:	89 81       	ldd	r24, Y+1	; 0x01
    30b2:	8f 5f       	subi	r24, 0xFF	; 255
    30b4:	eb 81       	ldd	r30, Y+3	; 0x03
    30b6:	fc 81       	ldd	r31, Y+4	; 0x04
    30b8:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    30ba:	81 e0       	ldi	r24, 0x01	; 1
    30bc:	8e 83       	std	Y+6, r24	; 0x06
    30be:	01 c0       	rjmp	.+2      	; 0x30c2 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    30c0:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    30c2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    30c4:	2c 96       	adiw	r28, 0x0c	; 12
    30c6:	0f b6       	in	r0, 0x3f	; 63
    30c8:	f8 94       	cli
    30ca:	de bf       	out	0x3e, r29	; 62
    30cc:	0f be       	out	0x3f, r0	; 63
    30ce:	cd bf       	out	0x3d, r28	; 61
    30d0:	cf 91       	pop	r28
    30d2:	df 91       	pop	r29
    30d4:	08 95       	ret

000030d6 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    30d6:	df 93       	push	r29
    30d8:	cf 93       	push	r28
    30da:	cd b7       	in	r28, 0x3d	; 61
    30dc:	de b7       	in	r29, 0x3e	; 62
    30de:	2a 97       	sbiw	r28, 0x0a	; 10
    30e0:	0f b6       	in	r0, 0x3f	; 63
    30e2:	f8 94       	cli
    30e4:	de bf       	out	0x3e, r29	; 62
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	98 87       	std	Y+8, r25	; 0x08
    30ec:	8f 83       	std	Y+7, r24	; 0x07
    30ee:	7a 87       	std	Y+10, r23	; 0x0a
    30f0:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    30f2:	8f 81       	ldd	r24, Y+7	; 0x07
    30f4:	98 85       	ldd	r25, Y+8	; 0x08
    30f6:	9a 83       	std	Y+2, r25	; 0x02
    30f8:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30fa:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30fc:	e9 81       	ldd	r30, Y+1	; 0x01
    30fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3100:	82 8d       	ldd	r24, Z+26	; 0x1a
    3102:	88 23       	and	r24, r24
    3104:	b1 f0       	breq	.+44     	; 0x3132 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3106:	e9 81       	ldd	r30, Y+1	; 0x01
    3108:	fa 81       	ldd	r31, Y+2	; 0x02
    310a:	86 81       	ldd	r24, Z+6	; 0x06
    310c:	97 81       	ldd	r25, Z+7	; 0x07
    310e:	9c 83       	std	Y+4, r25	; 0x04
    3110:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	9a 81       	ldd	r25, Y+2	; 0x02
    3116:	29 85       	ldd	r18, Y+9	; 0x09
    3118:	3a 85       	ldd	r19, Y+10	; 0x0a
    311a:	b9 01       	movw	r22, r18
    311c:	0e 94 b8 19 	call	0x3370	; 0x3370 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3120:	e9 81       	ldd	r30, Y+1	; 0x01
    3122:	fa 81       	ldd	r31, Y+2	; 0x02
    3124:	8b 81       	ldd	r24, Y+3	; 0x03
    3126:	9c 81       	ldd	r25, Y+4	; 0x04
    3128:	97 83       	std	Z+7, r25	; 0x07
    312a:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	8e 83       	std	Y+6, r24	; 0x06
    3130:	01 c0       	rjmp	.+2      	; 0x3134 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    3132:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3134:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3136:	2a 96       	adiw	r28, 0x0a	; 10
    3138:	0f b6       	in	r0, 0x3f	; 63
    313a:	f8 94       	cli
    313c:	de bf       	out	0x3e, r29	; 62
    313e:	0f be       	out	0x3f, r0	; 63
    3140:	cd bf       	out	0x3d, r28	; 61
    3142:	cf 91       	pop	r28
    3144:	df 91       	pop	r29
    3146:	08 95       	ret

00003148 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3148:	df 93       	push	r29
    314a:	cf 93       	push	r28
    314c:	00 d0       	rcall	.+0      	; 0x314e <uxQueueMessagesWaiting+0x6>
    314e:	0f 92       	push	r0
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	9b 83       	std	Y+3, r25	; 0x03
    3156:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    3158:	0f b6       	in	r0, 0x3f	; 63
    315a:	f8 94       	cli
    315c:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    315e:	ea 81       	ldd	r30, Y+2	; 0x02
    3160:	fb 81       	ldd	r31, Y+3	; 0x03
    3162:	82 8d       	ldd	r24, Z+26	; 0x1a
    3164:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3166:	0f 90       	pop	r0
    3168:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    316a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    316c:	0f 90       	pop	r0
    316e:	0f 90       	pop	r0
    3170:	0f 90       	pop	r0
    3172:	cf 91       	pop	r28
    3174:	df 91       	pop	r29
    3176:	08 95       	ret

00003178 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3178:	df 93       	push	r29
    317a:	cf 93       	push	r28
    317c:	00 d0       	rcall	.+0      	; 0x317e <uxQueueSpacesAvailable+0x6>
    317e:	00 d0       	rcall	.+0      	; 0x3180 <uxQueueSpacesAvailable+0x8>
    3180:	0f 92       	push	r0
    3182:	cd b7       	in	r28, 0x3d	; 61
    3184:	de b7       	in	r29, 0x3e	; 62
    3186:	9d 83       	std	Y+5, r25	; 0x05
    3188:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    318a:	8c 81       	ldd	r24, Y+4	; 0x04
    318c:	9d 81       	ldd	r25, Y+5	; 0x05
    318e:	9a 83       	std	Y+2, r25	; 0x02
    3190:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	f8 94       	cli
    3196:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3198:	e9 81       	ldd	r30, Y+1	; 0x01
    319a:	fa 81       	ldd	r31, Y+2	; 0x02
    319c:	93 8d       	ldd	r25, Z+27	; 0x1b
    319e:	e9 81       	ldd	r30, Y+1	; 0x01
    31a0:	fa 81       	ldd	r31, Y+2	; 0x02
    31a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a4:	29 2f       	mov	r18, r25
    31a6:	28 1b       	sub	r18, r24
    31a8:	82 2f       	mov	r24, r18
    31aa:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    31ac:	0f 90       	pop	r0
    31ae:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    31b0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    31b2:	0f 90       	pop	r0
    31b4:	0f 90       	pop	r0
    31b6:	0f 90       	pop	r0
    31b8:	0f 90       	pop	r0
    31ba:	0f 90       	pop	r0
    31bc:	cf 91       	pop	r28
    31be:	df 91       	pop	r29
    31c0:	08 95       	ret

000031c2 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    31c2:	df 93       	push	r29
    31c4:	cf 93       	push	r28
    31c6:	00 d0       	rcall	.+0      	; 0x31c8 <uxQueueMessagesWaitingFromISR+0x6>
    31c8:	00 d0       	rcall	.+0      	; 0x31ca <uxQueueMessagesWaitingFromISR+0x8>
    31ca:	0f 92       	push	r0
    31cc:	cd b7       	in	r28, 0x3d	; 61
    31ce:	de b7       	in	r29, 0x3e	; 62
    31d0:	9d 83       	std	Y+5, r25	; 0x05
    31d2:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    31d4:	8c 81       	ldd	r24, Y+4	; 0x04
    31d6:	9d 81       	ldd	r25, Y+5	; 0x05
    31d8:	9a 83       	std	Y+2, r25	; 0x02
    31da:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    31dc:	e9 81       	ldd	r30, Y+1	; 0x01
    31de:	fa 81       	ldd	r31, Y+2	; 0x02
    31e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    31e2:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    31e4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    31e6:	0f 90       	pop	r0
    31e8:	0f 90       	pop	r0
    31ea:	0f 90       	pop	r0
    31ec:	0f 90       	pop	r0
    31ee:	0f 90       	pop	r0
    31f0:	cf 91       	pop	r28
    31f2:	df 91       	pop	r29
    31f4:	08 95       	ret

000031f6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    31f6:	df 93       	push	r29
    31f8:	cf 93       	push	r28
    31fa:	00 d0       	rcall	.+0      	; 0x31fc <vQueueDelete+0x6>
    31fc:	00 d0       	rcall	.+0      	; 0x31fe <vQueueDelete+0x8>
    31fe:	cd b7       	in	r28, 0x3d	; 61
    3200:	de b7       	in	r29, 0x3e	; 62
    3202:	9c 83       	std	Y+4, r25	; 0x04
    3204:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    3206:	8b 81       	ldd	r24, Y+3	; 0x03
    3208:	9c 81       	ldd	r25, Y+4	; 0x04
    320a:	9a 83       	std	Y+2, r25	; 0x02
    320c:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	9a 81       	ldd	r25, Y+2	; 0x02
    3212:	0e 94 0e 09 	call	0x121c	; 0x121c <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	cf 91       	pop	r28
    3220:	df 91       	pop	r29
    3222:	08 95       	ret

00003224 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3224:	df 93       	push	r29
    3226:	cf 93       	push	r28
    3228:	cd b7       	in	r28, 0x3d	; 61
    322a:	de b7       	in	r29, 0x3e	; 62
    322c:	27 97       	sbiw	r28, 0x07	; 7
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	9c 83       	std	Y+4, r25	; 0x04
    323a:	8b 83       	std	Y+3, r24	; 0x03
    323c:	7e 83       	std	Y+6, r23	; 0x06
    323e:	6d 83       	std	Y+5, r22	; 0x05
    3240:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    3242:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3244:	eb 81       	ldd	r30, Y+3	; 0x03
    3246:	fc 81       	ldd	r31, Y+4	; 0x04
    3248:	82 8d       	ldd	r24, Z+26	; 0x1a
    324a:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    324c:	eb 81       	ldd	r30, Y+3	; 0x03
    324e:	fc 81       	ldd	r31, Y+4	; 0x04
    3250:	84 8d       	ldd	r24, Z+28	; 0x1c
    3252:	88 23       	and	r24, r24
    3254:	09 f4       	brne	.+2      	; 0x3258 <prvCopyDataToQueue+0x34>
    3256:	7d c0       	rjmp	.+250    	; 0x3352 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3258:	8f 81       	ldd	r24, Y+7	; 0x07
    325a:	88 23       	and	r24, r24
    325c:	99 f5       	brne	.+102    	; 0x32c4 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    325e:	eb 81       	ldd	r30, Y+3	; 0x03
    3260:	fc 81       	ldd	r31, Y+4	; 0x04
    3262:	62 81       	ldd	r22, Z+2	; 0x02
    3264:	73 81       	ldd	r23, Z+3	; 0x03
    3266:	eb 81       	ldd	r30, Y+3	; 0x03
    3268:	fc 81       	ldd	r31, Y+4	; 0x04
    326a:	84 8d       	ldd	r24, Z+28	; 0x1c
    326c:	48 2f       	mov	r20, r24
    326e:	50 e0       	ldi	r21, 0x00	; 0
    3270:	2d 81       	ldd	r18, Y+5	; 0x05
    3272:	3e 81       	ldd	r19, Y+6	; 0x06
    3274:	cb 01       	movw	r24, r22
    3276:	b9 01       	movw	r22, r18
    3278:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    327c:	eb 81       	ldd	r30, Y+3	; 0x03
    327e:	fc 81       	ldd	r31, Y+4	; 0x04
    3280:	22 81       	ldd	r18, Z+2	; 0x02
    3282:	33 81       	ldd	r19, Z+3	; 0x03
    3284:	eb 81       	ldd	r30, Y+3	; 0x03
    3286:	fc 81       	ldd	r31, Y+4	; 0x04
    3288:	84 8d       	ldd	r24, Z+28	; 0x1c
    328a:	88 2f       	mov	r24, r24
    328c:	90 e0       	ldi	r25, 0x00	; 0
    328e:	82 0f       	add	r24, r18
    3290:	93 1f       	adc	r25, r19
    3292:	eb 81       	ldd	r30, Y+3	; 0x03
    3294:	fc 81       	ldd	r31, Y+4	; 0x04
    3296:	93 83       	std	Z+3, r25	; 0x03
    3298:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    329a:	eb 81       	ldd	r30, Y+3	; 0x03
    329c:	fc 81       	ldd	r31, Y+4	; 0x04
    329e:	22 81       	ldd	r18, Z+2	; 0x02
    32a0:	33 81       	ldd	r19, Z+3	; 0x03
    32a2:	eb 81       	ldd	r30, Y+3	; 0x03
    32a4:	fc 81       	ldd	r31, Y+4	; 0x04
    32a6:	84 81       	ldd	r24, Z+4	; 0x04
    32a8:	95 81       	ldd	r25, Z+5	; 0x05
    32aa:	28 17       	cp	r18, r24
    32ac:	39 07       	cpc	r19, r25
    32ae:	08 f4       	brcc	.+2      	; 0x32b2 <prvCopyDataToQueue+0x8e>
    32b0:	50 c0       	rjmp	.+160    	; 0x3352 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    32b2:	eb 81       	ldd	r30, Y+3	; 0x03
    32b4:	fc 81       	ldd	r31, Y+4	; 0x04
    32b6:	80 81       	ld	r24, Z
    32b8:	91 81       	ldd	r25, Z+1	; 0x01
    32ba:	eb 81       	ldd	r30, Y+3	; 0x03
    32bc:	fc 81       	ldd	r31, Y+4	; 0x04
    32be:	93 83       	std	Z+3, r25	; 0x03
    32c0:	82 83       	std	Z+2, r24	; 0x02
    32c2:	47 c0       	rjmp	.+142    	; 0x3352 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    32c4:	eb 81       	ldd	r30, Y+3	; 0x03
    32c6:	fc 81       	ldd	r31, Y+4	; 0x04
    32c8:	66 81       	ldd	r22, Z+6	; 0x06
    32ca:	77 81       	ldd	r23, Z+7	; 0x07
    32cc:	eb 81       	ldd	r30, Y+3	; 0x03
    32ce:	fc 81       	ldd	r31, Y+4	; 0x04
    32d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    32d2:	48 2f       	mov	r20, r24
    32d4:	50 e0       	ldi	r21, 0x00	; 0
    32d6:	2d 81       	ldd	r18, Y+5	; 0x05
    32d8:	3e 81       	ldd	r19, Y+6	; 0x06
    32da:	cb 01       	movw	r24, r22
    32dc:	b9 01       	movw	r22, r18
    32de:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    32e2:	eb 81       	ldd	r30, Y+3	; 0x03
    32e4:	fc 81       	ldd	r31, Y+4	; 0x04
    32e6:	26 81       	ldd	r18, Z+6	; 0x06
    32e8:	37 81       	ldd	r19, Z+7	; 0x07
    32ea:	eb 81       	ldd	r30, Y+3	; 0x03
    32ec:	fc 81       	ldd	r31, Y+4	; 0x04
    32ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    32f0:	88 2f       	mov	r24, r24
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	90 95       	com	r25
    32f6:	81 95       	neg	r24
    32f8:	9f 4f       	sbci	r25, 0xFF	; 255
    32fa:	82 0f       	add	r24, r18
    32fc:	93 1f       	adc	r25, r19
    32fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3300:	fc 81       	ldd	r31, Y+4	; 0x04
    3302:	97 83       	std	Z+7, r25	; 0x07
    3304:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3306:	eb 81       	ldd	r30, Y+3	; 0x03
    3308:	fc 81       	ldd	r31, Y+4	; 0x04
    330a:	26 81       	ldd	r18, Z+6	; 0x06
    330c:	37 81       	ldd	r19, Z+7	; 0x07
    330e:	eb 81       	ldd	r30, Y+3	; 0x03
    3310:	fc 81       	ldd	r31, Y+4	; 0x04
    3312:	80 81       	ld	r24, Z
    3314:	91 81       	ldd	r25, Z+1	; 0x01
    3316:	28 17       	cp	r18, r24
    3318:	39 07       	cpc	r19, r25
    331a:	90 f4       	brcc	.+36     	; 0x3340 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    331c:	eb 81       	ldd	r30, Y+3	; 0x03
    331e:	fc 81       	ldd	r31, Y+4	; 0x04
    3320:	24 81       	ldd	r18, Z+4	; 0x04
    3322:	35 81       	ldd	r19, Z+5	; 0x05
    3324:	eb 81       	ldd	r30, Y+3	; 0x03
    3326:	fc 81       	ldd	r31, Y+4	; 0x04
    3328:	84 8d       	ldd	r24, Z+28	; 0x1c
    332a:	88 2f       	mov	r24, r24
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	90 95       	com	r25
    3330:	81 95       	neg	r24
    3332:	9f 4f       	sbci	r25, 0xFF	; 255
    3334:	82 0f       	add	r24, r18
    3336:	93 1f       	adc	r25, r19
    3338:	eb 81       	ldd	r30, Y+3	; 0x03
    333a:	fc 81       	ldd	r31, Y+4	; 0x04
    333c:	97 83       	std	Z+7, r25	; 0x07
    333e:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3340:	8f 81       	ldd	r24, Y+7	; 0x07
    3342:	82 30       	cpi	r24, 0x02	; 2
    3344:	31 f4       	brne	.+12     	; 0x3352 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3346:	89 81       	ldd	r24, Y+1	; 0x01
    3348:	88 23       	and	r24, r24
    334a:	19 f0       	breq	.+6      	; 0x3352 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    334c:	89 81       	ldd	r24, Y+1	; 0x01
    334e:	81 50       	subi	r24, 0x01	; 1
    3350:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3352:	89 81       	ldd	r24, Y+1	; 0x01
    3354:	8f 5f       	subi	r24, 0xFF	; 255
    3356:	eb 81       	ldd	r30, Y+3	; 0x03
    3358:	fc 81       	ldd	r31, Y+4	; 0x04
    335a:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    335c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    335e:	27 96       	adiw	r28, 0x07	; 7
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	f8 94       	cli
    3364:	de bf       	out	0x3e, r29	; 62
    3366:	0f be       	out	0x3f, r0	; 63
    3368:	cd bf       	out	0x3d, r28	; 61
    336a:	cf 91       	pop	r28
    336c:	df 91       	pop	r29
    336e:	08 95       	ret

00003370 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3370:	df 93       	push	r29
    3372:	cf 93       	push	r28
    3374:	00 d0       	rcall	.+0      	; 0x3376 <prvCopyDataFromQueue+0x6>
    3376:	00 d0       	rcall	.+0      	; 0x3378 <prvCopyDataFromQueue+0x8>
    3378:	cd b7       	in	r28, 0x3d	; 61
    337a:	de b7       	in	r29, 0x3e	; 62
    337c:	9a 83       	std	Y+2, r25	; 0x02
    337e:	89 83       	std	Y+1, r24	; 0x01
    3380:	7c 83       	std	Y+4, r23	; 0x04
    3382:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3384:	e9 81       	ldd	r30, Y+1	; 0x01
    3386:	fa 81       	ldd	r31, Y+2	; 0x02
    3388:	84 8d       	ldd	r24, Z+28	; 0x1c
    338a:	88 23       	and	r24, r24
    338c:	89 f1       	breq	.+98     	; 0x33f0 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    338e:	e9 81       	ldd	r30, Y+1	; 0x01
    3390:	fa 81       	ldd	r31, Y+2	; 0x02
    3392:	26 81       	ldd	r18, Z+6	; 0x06
    3394:	37 81       	ldd	r19, Z+7	; 0x07
    3396:	e9 81       	ldd	r30, Y+1	; 0x01
    3398:	fa 81       	ldd	r31, Y+2	; 0x02
    339a:	84 8d       	ldd	r24, Z+28	; 0x1c
    339c:	88 2f       	mov	r24, r24
    339e:	90 e0       	ldi	r25, 0x00	; 0
    33a0:	82 0f       	add	r24, r18
    33a2:	93 1f       	adc	r25, r19
    33a4:	e9 81       	ldd	r30, Y+1	; 0x01
    33a6:	fa 81       	ldd	r31, Y+2	; 0x02
    33a8:	97 83       	std	Z+7, r25	; 0x07
    33aa:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    33ac:	e9 81       	ldd	r30, Y+1	; 0x01
    33ae:	fa 81       	ldd	r31, Y+2	; 0x02
    33b0:	26 81       	ldd	r18, Z+6	; 0x06
    33b2:	37 81       	ldd	r19, Z+7	; 0x07
    33b4:	e9 81       	ldd	r30, Y+1	; 0x01
    33b6:	fa 81       	ldd	r31, Y+2	; 0x02
    33b8:	84 81       	ldd	r24, Z+4	; 0x04
    33ba:	95 81       	ldd	r25, Z+5	; 0x05
    33bc:	28 17       	cp	r18, r24
    33be:	39 07       	cpc	r19, r25
    33c0:	40 f0       	brcs	.+16     	; 0x33d2 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    33c2:	e9 81       	ldd	r30, Y+1	; 0x01
    33c4:	fa 81       	ldd	r31, Y+2	; 0x02
    33c6:	80 81       	ld	r24, Z
    33c8:	91 81       	ldd	r25, Z+1	; 0x01
    33ca:	e9 81       	ldd	r30, Y+1	; 0x01
    33cc:	fa 81       	ldd	r31, Y+2	; 0x02
    33ce:	97 83       	std	Z+7, r25	; 0x07
    33d0:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    33d2:	e9 81       	ldd	r30, Y+1	; 0x01
    33d4:	fa 81       	ldd	r31, Y+2	; 0x02
    33d6:	46 81       	ldd	r20, Z+6	; 0x06
    33d8:	57 81       	ldd	r21, Z+7	; 0x07
    33da:	e9 81       	ldd	r30, Y+1	; 0x01
    33dc:	fa 81       	ldd	r31, Y+2	; 0x02
    33de:	84 8d       	ldd	r24, Z+28	; 0x1c
    33e0:	28 2f       	mov	r18, r24
    33e2:	30 e0       	ldi	r19, 0x00	; 0
    33e4:	8b 81       	ldd	r24, Y+3	; 0x03
    33e6:	9c 81       	ldd	r25, Y+4	; 0x04
    33e8:	ba 01       	movw	r22, r20
    33ea:	a9 01       	movw	r20, r18
    33ec:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <memcpy>
    }
}
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	0f 90       	pop	r0
    33f6:	0f 90       	pop	r0
    33f8:	cf 91       	pop	r28
    33fa:	df 91       	pop	r29
    33fc:	08 95       	ret

000033fe <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    33fe:	df 93       	push	r29
    3400:	cf 93       	push	r28
    3402:	00 d0       	rcall	.+0      	; 0x3404 <prvUnlockQueue+0x6>
    3404:	00 d0       	rcall	.+0      	; 0x3406 <prvUnlockQueue+0x8>
    3406:	cd b7       	in	r28, 0x3d	; 61
    3408:	de b7       	in	r29, 0x3e	; 62
    340a:	9c 83       	std	Y+4, r25	; 0x04
    340c:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    340e:	0f b6       	in	r0, 0x3f	; 63
    3410:	f8 94       	cli
    3412:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3414:	eb 81       	ldd	r30, Y+3	; 0x03
    3416:	fc 81       	ldd	r31, Y+4	; 0x04
    3418:	86 8d       	ldd	r24, Z+30	; 0x1e
    341a:	8a 83       	std	Y+2, r24	; 0x02
    341c:	11 c0       	rjmp	.+34     	; 0x3440 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    341e:	eb 81       	ldd	r30, Y+3	; 0x03
    3420:	fc 81       	ldd	r31, Y+4	; 0x04
    3422:	81 89       	ldd	r24, Z+17	; 0x11
    3424:	88 23       	and	r24, r24
    3426:	79 f0       	breq	.+30     	; 0x3446 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3428:	8b 81       	ldd	r24, Y+3	; 0x03
    342a:	9c 81       	ldd	r25, Y+4	; 0x04
    342c:	41 96       	adiw	r24, 0x11	; 17
    342e:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    3432:	88 23       	and	r24, r24
    3434:	11 f0       	breq	.+4      	; 0x343a <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3436:	0e 94 26 26 	call	0x4c4c	; 0x4c4c <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    343a:	8a 81       	ldd	r24, Y+2	; 0x02
    343c:	81 50       	subi	r24, 0x01	; 1
    343e:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3440:	8a 81       	ldd	r24, Y+2	; 0x02
    3442:	18 16       	cp	r1, r24
    3444:	64 f3       	brlt	.-40     	; 0x341e <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3446:	eb 81       	ldd	r30, Y+3	; 0x03
    3448:	fc 81       	ldd	r31, Y+4	; 0x04
    344a:	8f ef       	ldi	r24, 0xFF	; 255
    344c:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    344e:	0f 90       	pop	r0
    3450:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3452:	0f b6       	in	r0, 0x3f	; 63
    3454:	f8 94       	cli
    3456:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3458:	eb 81       	ldd	r30, Y+3	; 0x03
    345a:	fc 81       	ldd	r31, Y+4	; 0x04
    345c:	85 8d       	ldd	r24, Z+29	; 0x1d
    345e:	89 83       	std	Y+1, r24	; 0x01
    3460:	11 c0       	rjmp	.+34     	; 0x3484 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3462:	eb 81       	ldd	r30, Y+3	; 0x03
    3464:	fc 81       	ldd	r31, Y+4	; 0x04
    3466:	80 85       	ldd	r24, Z+8	; 0x08
    3468:	88 23       	and	r24, r24
    346a:	79 f0       	breq	.+30     	; 0x348a <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    346c:	8b 81       	ldd	r24, Y+3	; 0x03
    346e:	9c 81       	ldd	r25, Y+4	; 0x04
    3470:	08 96       	adiw	r24, 0x08	; 8
    3472:	0e 94 36 23 	call	0x466c	; 0x466c <xTaskRemoveFromEventList>
    3476:	88 23       	and	r24, r24
    3478:	11 f0       	breq	.+4      	; 0x347e <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    347a:	0e 94 26 26 	call	0x4c4c	; 0x4c4c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    347e:	89 81       	ldd	r24, Y+1	; 0x01
    3480:	81 50       	subi	r24, 0x01	; 1
    3482:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3484:	89 81       	ldd	r24, Y+1	; 0x01
    3486:	18 16       	cp	r1, r24
    3488:	64 f3       	brlt	.-40     	; 0x3462 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    348a:	eb 81       	ldd	r30, Y+3	; 0x03
    348c:	fc 81       	ldd	r31, Y+4	; 0x04
    348e:	8f ef       	ldi	r24, 0xFF	; 255
    3490:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3492:	0f 90       	pop	r0
    3494:	0f be       	out	0x3f, r0	; 63
}
    3496:	0f 90       	pop	r0
    3498:	0f 90       	pop	r0
    349a:	0f 90       	pop	r0
    349c:	0f 90       	pop	r0
    349e:	cf 91       	pop	r28
    34a0:	df 91       	pop	r29
    34a2:	08 95       	ret

000034a4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    34a4:	df 93       	push	r29
    34a6:	cf 93       	push	r28
    34a8:	00 d0       	rcall	.+0      	; 0x34aa <prvIsQueueEmpty+0x6>
    34aa:	0f 92       	push	r0
    34ac:	cd b7       	in	r28, 0x3d	; 61
    34ae:	de b7       	in	r29, 0x3e	; 62
    34b0:	9b 83       	std	Y+3, r25	; 0x03
    34b2:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    34b4:	0f b6       	in	r0, 0x3f	; 63
    34b6:	f8 94       	cli
    34b8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    34ba:	ea 81       	ldd	r30, Y+2	; 0x02
    34bc:	fb 81       	ldd	r31, Y+3	; 0x03
    34be:	82 8d       	ldd	r24, Z+26	; 0x1a
    34c0:	88 23       	and	r24, r24
    34c2:	19 f4       	brne	.+6      	; 0x34ca <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    34c4:	81 e0       	ldi	r24, 0x01	; 1
    34c6:	89 83       	std	Y+1, r24	; 0x01
    34c8:	01 c0       	rjmp	.+2      	; 0x34cc <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    34ca:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    34cc:	0f 90       	pop	r0
    34ce:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    34d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	0f 90       	pop	r0
    34d8:	cf 91       	pop	r28
    34da:	df 91       	pop	r29
    34dc:	08 95       	ret

000034de <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    34de:	df 93       	push	r29
    34e0:	cf 93       	push	r28
    34e2:	00 d0       	rcall	.+0      	; 0x34e4 <xQueueIsQueueEmptyFromISR+0x6>
    34e4:	00 d0       	rcall	.+0      	; 0x34e6 <xQueueIsQueueEmptyFromISR+0x8>
    34e6:	0f 92       	push	r0
    34e8:	cd b7       	in	r28, 0x3d	; 61
    34ea:	de b7       	in	r29, 0x3e	; 62
    34ec:	9d 83       	std	Y+5, r25	; 0x05
    34ee:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    34f0:	8c 81       	ldd	r24, Y+4	; 0x04
    34f2:	9d 81       	ldd	r25, Y+5	; 0x05
    34f4:	9a 83       	std	Y+2, r25	; 0x02
    34f6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    34f8:	e9 81       	ldd	r30, Y+1	; 0x01
    34fa:	fa 81       	ldd	r31, Y+2	; 0x02
    34fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    34fe:	88 23       	and	r24, r24
    3500:	19 f4       	brne	.+6      	; 0x3508 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    3502:	81 e0       	ldi	r24, 0x01	; 1
    3504:	8b 83       	std	Y+3, r24	; 0x03
    3506:	01 c0       	rjmp	.+2      	; 0x350a <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    3508:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    350a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    350c:	0f 90       	pop	r0
    350e:	0f 90       	pop	r0
    3510:	0f 90       	pop	r0
    3512:	0f 90       	pop	r0
    3514:	0f 90       	pop	r0
    3516:	cf 91       	pop	r28
    3518:	df 91       	pop	r29
    351a:	08 95       	ret

0000351c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    351c:	df 93       	push	r29
    351e:	cf 93       	push	r28
    3520:	00 d0       	rcall	.+0      	; 0x3522 <prvIsQueueFull+0x6>
    3522:	0f 92       	push	r0
    3524:	cd b7       	in	r28, 0x3d	; 61
    3526:	de b7       	in	r29, 0x3e	; 62
    3528:	9b 83       	std	Y+3, r25	; 0x03
    352a:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    352c:	0f b6       	in	r0, 0x3f	; 63
    352e:	f8 94       	cli
    3530:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3532:	ea 81       	ldd	r30, Y+2	; 0x02
    3534:	fb 81       	ldd	r31, Y+3	; 0x03
    3536:	92 8d       	ldd	r25, Z+26	; 0x1a
    3538:	ea 81       	ldd	r30, Y+2	; 0x02
    353a:	fb 81       	ldd	r31, Y+3	; 0x03
    353c:	83 8d       	ldd	r24, Z+27	; 0x1b
    353e:	98 17       	cp	r25, r24
    3540:	19 f4       	brne	.+6      	; 0x3548 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	89 83       	std	Y+1, r24	; 0x01
    3546:	01 c0       	rjmp	.+2      	; 0x354a <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    3548:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    354a:	0f 90       	pop	r0
    354c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    354e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3550:	0f 90       	pop	r0
    3552:	0f 90       	pop	r0
    3554:	0f 90       	pop	r0
    3556:	cf 91       	pop	r28
    3558:	df 91       	pop	r29
    355a:	08 95       	ret

0000355c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    355c:	df 93       	push	r29
    355e:	cf 93       	push	r28
    3560:	00 d0       	rcall	.+0      	; 0x3562 <xQueueIsQueueFullFromISR+0x6>
    3562:	00 d0       	rcall	.+0      	; 0x3564 <xQueueIsQueueFullFromISR+0x8>
    3564:	0f 92       	push	r0
    3566:	cd b7       	in	r28, 0x3d	; 61
    3568:	de b7       	in	r29, 0x3e	; 62
    356a:	9d 83       	std	Y+5, r25	; 0x05
    356c:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    356e:	8c 81       	ldd	r24, Y+4	; 0x04
    3570:	9d 81       	ldd	r25, Y+5	; 0x05
    3572:	9a 83       	std	Y+2, r25	; 0x02
    3574:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3576:	e9 81       	ldd	r30, Y+1	; 0x01
    3578:	fa 81       	ldd	r31, Y+2	; 0x02
    357a:	92 8d       	ldd	r25, Z+26	; 0x1a
    357c:	e9 81       	ldd	r30, Y+1	; 0x01
    357e:	fa 81       	ldd	r31, Y+2	; 0x02
    3580:	83 8d       	ldd	r24, Z+27	; 0x1b
    3582:	98 17       	cp	r25, r24
    3584:	19 f4       	brne	.+6      	; 0x358c <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    3586:	81 e0       	ldi	r24, 0x01	; 1
    3588:	8b 83       	std	Y+3, r24	; 0x03
    358a:	01 c0       	rjmp	.+2      	; 0x358e <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    358c:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    358e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3590:	0f 90       	pop	r0
    3592:	0f 90       	pop	r0
    3594:	0f 90       	pop	r0
    3596:	0f 90       	pop	r0
    3598:	0f 90       	pop	r0
    359a:	cf 91       	pop	r28
    359c:	df 91       	pop	r29
    359e:	08 95       	ret

000035a0 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    35a0:	df 93       	push	r29
    35a2:	cf 93       	push	r28
    35a4:	cd b7       	in	r28, 0x3d	; 61
    35a6:	de b7       	in	r29, 0x3e	; 62
    35a8:	2a 97       	sbiw	r28, 0x0a	; 10
    35aa:	0f b6       	in	r0, 0x3f	; 63
    35ac:	f8 94       	cli
    35ae:	de bf       	out	0x3e, r29	; 62
    35b0:	0f be       	out	0x3f, r0	; 63
    35b2:	cd bf       	out	0x3d, r28	; 61
    35b4:	9d 83       	std	Y+5, r25	; 0x05
    35b6:	8c 83       	std	Y+4, r24	; 0x04
    35b8:	7f 83       	std	Y+7, r23	; 0x07
    35ba:	6e 83       	std	Y+6, r22	; 0x06
    35bc:	59 87       	std	Y+9, r21	; 0x09
    35be:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    35c0:	8c 81       	ldd	r24, Y+4	; 0x04
    35c2:	9d 81       	ldd	r25, Y+5	; 0x05
    35c4:	9a 83       	std	Y+2, r25	; 0x02
    35c6:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    35c8:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	9a 81       	ldd	r25, Y+2	; 0x02
    35ce:	0e 94 8e 1a 	call	0x351c	; 0x351c <prvIsQueueFull>
    35d2:	88 23       	and	r24, r24
    35d4:	a9 f0       	breq	.+42     	; 0x3600 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    35d6:	88 85       	ldd	r24, Y+8	; 0x08
    35d8:	99 85       	ldd	r25, Y+9	; 0x09
    35da:	00 97       	sbiw	r24, 0x00	; 0
    35dc:	71 f0       	breq	.+28     	; 0x35fa <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    35de:	89 81       	ldd	r24, Y+1	; 0x01
    35e0:	9a 81       	ldd	r25, Y+2	; 0x02
    35e2:	9c 01       	movw	r18, r24
    35e4:	28 5f       	subi	r18, 0xF8	; 248
    35e6:	3f 4f       	sbci	r19, 0xFF	; 255
    35e8:	88 85       	ldd	r24, Y+8	; 0x08
    35ea:	99 85       	ldd	r25, Y+9	; 0x09
    35ec:	b9 01       	movw	r22, r18
    35ee:	0e 94 9c 0c 	call	0x1938	; 0x1938 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    35f2:	78 94       	sei
                    return errQUEUE_BLOCKED;
    35f4:	8c ef       	ldi	r24, 0xFC	; 252
    35f6:	8a 87       	std	Y+10, r24	; 0x0a
    35f8:	2a c0       	rjmp	.+84     	; 0x364e <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    35fa:	78 94       	sei
                    return errQUEUE_FULL;
    35fc:	1a 86       	std	Y+10, r1	; 0x0a
    35fe:	27 c0       	rjmp	.+78     	; 0x364e <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    3600:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3602:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3604:	e9 81       	ldd	r30, Y+1	; 0x01
    3606:	fa 81       	ldd	r31, Y+2	; 0x02
    3608:	92 8d       	ldd	r25, Z+26	; 0x1a
    360a:	e9 81       	ldd	r30, Y+1	; 0x01
    360c:	fa 81       	ldd	r31, Y+2	; 0x02
    360e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3610:	98 17       	cp	r25, r24
    3612:	c8 f4       	brcc	.+50     	; 0x3646 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3614:	89 81       	ldd	r24, Y+1	; 0x01
    3616:	9a 81       	ldd	r25, Y+2	; 0x02
    3618:	2e 81       	ldd	r18, Y+6	; 0x06
    361a:	3f 81       	ldd	r19, Y+7	; 0x07
    361c:	b9 01       	movw	r22, r18
    361e:	40 e0       	ldi	r20, 0x00	; 0
    3620:	0e 94 12 19 	call	0x3224	; 0x3224 <prvCopyDataToQueue>
                xReturn = pdPASS;
    3624:	81 e0       	ldi	r24, 0x01	; 1
    3626:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3628:	e9 81       	ldd	r30, Y+1	; 0x01
    362a:	fa 81       	ldd	r31, Y+2	; 0x02
    362c:	81 89       	ldd	r24, Z+17	; 0x11
    362e:	88 23       	and	r24, r24
    3630:	59 f0       	breq	.+22     	; 0x3648 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3632:	89 81       	ldd	r24, Y+1	; 0x01
    3634:	9a 81       	ldd	r25, Y+2	; 0x02
    3636:	41 96       	adiw	r24, 0x11	; 17
    3638:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <xCoRoutineRemoveFromEventList>
    363c:	88 23       	and	r24, r24
    363e:	21 f0       	breq	.+8      	; 0x3648 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    3640:	8b ef       	ldi	r24, 0xFB	; 251
    3642:	8b 83       	std	Y+3, r24	; 0x03
    3644:	01 c0       	rjmp	.+2      	; 0x3648 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    3646:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3648:	78 94       	sei

        return xReturn;
    364a:	8b 81       	ldd	r24, Y+3	; 0x03
    364c:	8a 87       	std	Y+10, r24	; 0x0a
    364e:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    3650:	2a 96       	adiw	r28, 0x0a	; 10
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	f8 94       	cli
    3656:	de bf       	out	0x3e, r29	; 62
    3658:	0f be       	out	0x3f, r0	; 63
    365a:	cd bf       	out	0x3d, r28	; 61
    365c:	cf 91       	pop	r28
    365e:	df 91       	pop	r29
    3660:	08 95       	ret

00003662 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    3662:	df 93       	push	r29
    3664:	cf 93       	push	r28
    3666:	cd b7       	in	r28, 0x3d	; 61
    3668:	de b7       	in	r29, 0x3e	; 62
    366a:	2a 97       	sbiw	r28, 0x0a	; 10
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	de bf       	out	0x3e, r29	; 62
    3672:	0f be       	out	0x3f, r0	; 63
    3674:	cd bf       	out	0x3d, r28	; 61
    3676:	9d 83       	std	Y+5, r25	; 0x05
    3678:	8c 83       	std	Y+4, r24	; 0x04
    367a:	7f 83       	std	Y+7, r23	; 0x07
    367c:	6e 83       	std	Y+6, r22	; 0x06
    367e:	59 87       	std	Y+9, r21	; 0x09
    3680:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3682:	8c 81       	ldd	r24, Y+4	; 0x04
    3684:	9d 81       	ldd	r25, Y+5	; 0x05
    3686:	9a 83       	std	Y+2, r25	; 0x02
    3688:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    368a:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    368c:	e9 81       	ldd	r30, Y+1	; 0x01
    368e:	fa 81       	ldd	r31, Y+2	; 0x02
    3690:	82 8d       	ldd	r24, Z+26	; 0x1a
    3692:	88 23       	and	r24, r24
    3694:	a9 f4       	brne	.+42     	; 0x36c0 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    3696:	88 85       	ldd	r24, Y+8	; 0x08
    3698:	99 85       	ldd	r25, Y+9	; 0x09
    369a:	00 97       	sbiw	r24, 0x00	; 0
    369c:	71 f0       	breq	.+28     	; 0x36ba <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    369e:	89 81       	ldd	r24, Y+1	; 0x01
    36a0:	9a 81       	ldd	r25, Y+2	; 0x02
    36a2:	9c 01       	movw	r18, r24
    36a4:	2f 5e       	subi	r18, 0xEF	; 239
    36a6:	3f 4f       	sbci	r19, 0xFF	; 255
    36a8:	88 85       	ldd	r24, Y+8	; 0x08
    36aa:	99 85       	ldd	r25, Y+9	; 0x09
    36ac:	b9 01       	movw	r22, r18
    36ae:	0e 94 9c 0c 	call	0x1938	; 0x1938 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    36b2:	78 94       	sei
                    return errQUEUE_BLOCKED;
    36b4:	8c ef       	ldi	r24, 0xFC	; 252
    36b6:	8a 87       	std	Y+10, r24	; 0x0a
    36b8:	58 c0       	rjmp	.+176    	; 0x376a <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    36ba:	78 94       	sei
                    return errQUEUE_FULL;
    36bc:	1a 86       	std	Y+10, r1	; 0x0a
    36be:	55 c0       	rjmp	.+170    	; 0x376a <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    36c0:	78 94       	sei

        portDISABLE_INTERRUPTS();
    36c2:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    36c4:	e9 81       	ldd	r30, Y+1	; 0x01
    36c6:	fa 81       	ldd	r31, Y+2	; 0x02
    36c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    36ca:	88 23       	and	r24, r24
    36cc:	09 f4       	brne	.+2      	; 0x36d0 <xQueueCRReceive+0x6e>
    36ce:	49 c0       	rjmp	.+146    	; 0x3762 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    36d0:	e9 81       	ldd	r30, Y+1	; 0x01
    36d2:	fa 81       	ldd	r31, Y+2	; 0x02
    36d4:	26 81       	ldd	r18, Z+6	; 0x06
    36d6:	37 81       	ldd	r19, Z+7	; 0x07
    36d8:	e9 81       	ldd	r30, Y+1	; 0x01
    36da:	fa 81       	ldd	r31, Y+2	; 0x02
    36dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    36de:	88 2f       	mov	r24, r24
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	82 0f       	add	r24, r18
    36e4:	93 1f       	adc	r25, r19
    36e6:	e9 81       	ldd	r30, Y+1	; 0x01
    36e8:	fa 81       	ldd	r31, Y+2	; 0x02
    36ea:	97 83       	std	Z+7, r25	; 0x07
    36ec:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    36ee:	e9 81       	ldd	r30, Y+1	; 0x01
    36f0:	fa 81       	ldd	r31, Y+2	; 0x02
    36f2:	26 81       	ldd	r18, Z+6	; 0x06
    36f4:	37 81       	ldd	r19, Z+7	; 0x07
    36f6:	e9 81       	ldd	r30, Y+1	; 0x01
    36f8:	fa 81       	ldd	r31, Y+2	; 0x02
    36fa:	84 81       	ldd	r24, Z+4	; 0x04
    36fc:	95 81       	ldd	r25, Z+5	; 0x05
    36fe:	28 17       	cp	r18, r24
    3700:	39 07       	cpc	r19, r25
    3702:	40 f0       	brcs	.+16     	; 0x3714 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3704:	e9 81       	ldd	r30, Y+1	; 0x01
    3706:	fa 81       	ldd	r31, Y+2	; 0x02
    3708:	80 81       	ld	r24, Z
    370a:	91 81       	ldd	r25, Z+1	; 0x01
    370c:	e9 81       	ldd	r30, Y+1	; 0x01
    370e:	fa 81       	ldd	r31, Y+2	; 0x02
    3710:	97 83       	std	Z+7, r25	; 0x07
    3712:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    3714:	e9 81       	ldd	r30, Y+1	; 0x01
    3716:	fa 81       	ldd	r31, Y+2	; 0x02
    3718:	82 8d       	ldd	r24, Z+26	; 0x1a
    371a:	81 50       	subi	r24, 0x01	; 1
    371c:	e9 81       	ldd	r30, Y+1	; 0x01
    371e:	fa 81       	ldd	r31, Y+2	; 0x02
    3720:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3722:	e9 81       	ldd	r30, Y+1	; 0x01
    3724:	fa 81       	ldd	r31, Y+2	; 0x02
    3726:	46 81       	ldd	r20, Z+6	; 0x06
    3728:	57 81       	ldd	r21, Z+7	; 0x07
    372a:	e9 81       	ldd	r30, Y+1	; 0x01
    372c:	fa 81       	ldd	r31, Y+2	; 0x02
    372e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3730:	28 2f       	mov	r18, r24
    3732:	30 e0       	ldi	r19, 0x00	; 0
    3734:	8e 81       	ldd	r24, Y+6	; 0x06
    3736:	9f 81       	ldd	r25, Y+7	; 0x07
    3738:	ba 01       	movw	r22, r20
    373a:	a9 01       	movw	r20, r18
    373c:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <memcpy>

                xReturn = pdPASS;
    3740:	81 e0       	ldi	r24, 0x01	; 1
    3742:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3744:	e9 81       	ldd	r30, Y+1	; 0x01
    3746:	fa 81       	ldd	r31, Y+2	; 0x02
    3748:	80 85       	ldd	r24, Z+8	; 0x08
    374a:	88 23       	and	r24, r24
    374c:	59 f0       	breq	.+22     	; 0x3764 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    374e:	89 81       	ldd	r24, Y+1	; 0x01
    3750:	9a 81       	ldd	r25, Y+2	; 0x02
    3752:	08 96       	adiw	r24, 0x08	; 8
    3754:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <xCoRoutineRemoveFromEventList>
    3758:	88 23       	and	r24, r24
    375a:	21 f0       	breq	.+8      	; 0x3764 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    375c:	8b ef       	ldi	r24, 0xFB	; 251
    375e:	8b 83       	std	Y+3, r24	; 0x03
    3760:	01 c0       	rjmp	.+2      	; 0x3764 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    3762:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3764:	78 94       	sei

        return xReturn;
    3766:	8b 81       	ldd	r24, Y+3	; 0x03
    3768:	8a 87       	std	Y+10, r24	; 0x0a
    376a:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    376c:	2a 96       	adiw	r28, 0x0a	; 10
    376e:	0f b6       	in	r0, 0x3f	; 63
    3770:	f8 94       	cli
    3772:	de bf       	out	0x3e, r29	; 62
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	cd bf       	out	0x3d, r28	; 61
    3778:	cf 91       	pop	r28
    377a:	df 91       	pop	r29
    377c:	08 95       	ret

0000377e <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    377e:	df 93       	push	r29
    3780:	cf 93       	push	r28
    3782:	cd b7       	in	r28, 0x3d	; 61
    3784:	de b7       	in	r29, 0x3e	; 62
    3786:	28 97       	sbiw	r28, 0x08	; 8
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	cd bf       	out	0x3d, r28	; 61
    3792:	9c 83       	std	Y+4, r25	; 0x04
    3794:	8b 83       	std	Y+3, r24	; 0x03
    3796:	7e 83       	std	Y+6, r23	; 0x06
    3798:	6d 83       	std	Y+5, r22	; 0x05
    379a:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    379c:	8b 81       	ldd	r24, Y+3	; 0x03
    379e:	9c 81       	ldd	r25, Y+4	; 0x04
    37a0:	9a 83       	std	Y+2, r25	; 0x02
    37a2:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    37a4:	e9 81       	ldd	r30, Y+1	; 0x01
    37a6:	fa 81       	ldd	r31, Y+2	; 0x02
    37a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    37aa:	e9 81       	ldd	r30, Y+1	; 0x01
    37ac:	fa 81       	ldd	r31, Y+2	; 0x02
    37ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    37b0:	98 17       	cp	r25, r24
    37b2:	d0 f4       	brcc	.+52     	; 0x37e8 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
    37b6:	9a 81       	ldd	r25, Y+2	; 0x02
    37b8:	2d 81       	ldd	r18, Y+5	; 0x05
    37ba:	3e 81       	ldd	r19, Y+6	; 0x06
    37bc:	b9 01       	movw	r22, r18
    37be:	40 e0       	ldi	r20, 0x00	; 0
    37c0:	0e 94 12 19 	call	0x3224	; 0x3224 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    37c4:	8f 81       	ldd	r24, Y+7	; 0x07
    37c6:	88 23       	and	r24, r24
    37c8:	79 f4       	brne	.+30     	; 0x37e8 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37ca:	e9 81       	ldd	r30, Y+1	; 0x01
    37cc:	fa 81       	ldd	r31, Y+2	; 0x02
    37ce:	81 89       	ldd	r24, Z+17	; 0x11
    37d0:	88 23       	and	r24, r24
    37d2:	51 f0       	breq	.+20     	; 0x37e8 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    37d4:	89 81       	ldd	r24, Y+1	; 0x01
    37d6:	9a 81       	ldd	r25, Y+2	; 0x02
    37d8:	41 96       	adiw	r24, 0x11	; 17
    37da:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <xCoRoutineRemoveFromEventList>
    37de:	88 23       	and	r24, r24
    37e0:	19 f0       	breq	.+6      	; 0x37e8 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    37e2:	81 e0       	ldi	r24, 0x01	; 1
    37e4:	88 87       	std	Y+8, r24	; 0x08
    37e6:	02 c0       	rjmp	.+4      	; 0x37ec <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    37e8:	8f 81       	ldd	r24, Y+7	; 0x07
    37ea:	88 87       	std	Y+8, r24	; 0x08
    37ec:	88 85       	ldd	r24, Y+8	; 0x08
    }
    37ee:	28 96       	adiw	r28, 0x08	; 8
    37f0:	0f b6       	in	r0, 0x3f	; 63
    37f2:	f8 94       	cli
    37f4:	de bf       	out	0x3e, r29	; 62
    37f6:	0f be       	out	0x3f, r0	; 63
    37f8:	cd bf       	out	0x3d, r28	; 61
    37fa:	cf 91       	pop	r28
    37fc:	df 91       	pop	r29
    37fe:	08 95       	ret

00003800 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    3800:	df 93       	push	r29
    3802:	cf 93       	push	r28
    3804:	cd b7       	in	r28, 0x3d	; 61
    3806:	de b7       	in	r29, 0x3e	; 62
    3808:	29 97       	sbiw	r28, 0x09	; 9
    380a:	0f b6       	in	r0, 0x3f	; 63
    380c:	f8 94       	cli
    380e:	de bf       	out	0x3e, r29	; 62
    3810:	0f be       	out	0x3f, r0	; 63
    3812:	cd bf       	out	0x3d, r28	; 61
    3814:	9d 83       	std	Y+5, r25	; 0x05
    3816:	8c 83       	std	Y+4, r24	; 0x04
    3818:	7f 83       	std	Y+7, r23	; 0x07
    381a:	6e 83       	std	Y+6, r22	; 0x06
    381c:	59 87       	std	Y+9, r21	; 0x09
    381e:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3820:	8c 81       	ldd	r24, Y+4	; 0x04
    3822:	9d 81       	ldd	r25, Y+5	; 0x05
    3824:	9a 83       	std	Y+2, r25	; 0x02
    3826:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3828:	e9 81       	ldd	r30, Y+1	; 0x01
    382a:	fa 81       	ldd	r31, Y+2	; 0x02
    382c:	82 8d       	ldd	r24, Z+26	; 0x1a
    382e:	88 23       	and	r24, r24
    3830:	09 f4       	brne	.+2      	; 0x3834 <xQueueCRReceiveFromISR+0x34>
    3832:	50 c0       	rjmp	.+160    	; 0x38d4 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    3834:	e9 81       	ldd	r30, Y+1	; 0x01
    3836:	fa 81       	ldd	r31, Y+2	; 0x02
    3838:	26 81       	ldd	r18, Z+6	; 0x06
    383a:	37 81       	ldd	r19, Z+7	; 0x07
    383c:	e9 81       	ldd	r30, Y+1	; 0x01
    383e:	fa 81       	ldd	r31, Y+2	; 0x02
    3840:	84 8d       	ldd	r24, Z+28	; 0x1c
    3842:	88 2f       	mov	r24, r24
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	82 0f       	add	r24, r18
    3848:	93 1f       	adc	r25, r19
    384a:	e9 81       	ldd	r30, Y+1	; 0x01
    384c:	fa 81       	ldd	r31, Y+2	; 0x02
    384e:	97 83       	std	Z+7, r25	; 0x07
    3850:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    3852:	e9 81       	ldd	r30, Y+1	; 0x01
    3854:	fa 81       	ldd	r31, Y+2	; 0x02
    3856:	26 81       	ldd	r18, Z+6	; 0x06
    3858:	37 81       	ldd	r19, Z+7	; 0x07
    385a:	e9 81       	ldd	r30, Y+1	; 0x01
    385c:	fa 81       	ldd	r31, Y+2	; 0x02
    385e:	84 81       	ldd	r24, Z+4	; 0x04
    3860:	95 81       	ldd	r25, Z+5	; 0x05
    3862:	28 17       	cp	r18, r24
    3864:	39 07       	cpc	r19, r25
    3866:	40 f0       	brcs	.+16     	; 0x3878 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3868:	e9 81       	ldd	r30, Y+1	; 0x01
    386a:	fa 81       	ldd	r31, Y+2	; 0x02
    386c:	80 81       	ld	r24, Z
    386e:	91 81       	ldd	r25, Z+1	; 0x01
    3870:	e9 81       	ldd	r30, Y+1	; 0x01
    3872:	fa 81       	ldd	r31, Y+2	; 0x02
    3874:	97 83       	std	Z+7, r25	; 0x07
    3876:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    3878:	e9 81       	ldd	r30, Y+1	; 0x01
    387a:	fa 81       	ldd	r31, Y+2	; 0x02
    387c:	82 8d       	ldd	r24, Z+26	; 0x1a
    387e:	81 50       	subi	r24, 0x01	; 1
    3880:	e9 81       	ldd	r30, Y+1	; 0x01
    3882:	fa 81       	ldd	r31, Y+2	; 0x02
    3884:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3886:	e9 81       	ldd	r30, Y+1	; 0x01
    3888:	fa 81       	ldd	r31, Y+2	; 0x02
    388a:	46 81       	ldd	r20, Z+6	; 0x06
    388c:	57 81       	ldd	r21, Z+7	; 0x07
    388e:	e9 81       	ldd	r30, Y+1	; 0x01
    3890:	fa 81       	ldd	r31, Y+2	; 0x02
    3892:	84 8d       	ldd	r24, Z+28	; 0x1c
    3894:	28 2f       	mov	r18, r24
    3896:	30 e0       	ldi	r19, 0x00	; 0
    3898:	8e 81       	ldd	r24, Y+6	; 0x06
    389a:	9f 81       	ldd	r25, Y+7	; 0x07
    389c:	ba 01       	movw	r22, r20
    389e:	a9 01       	movw	r20, r18
    38a0:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    38a4:	e8 85       	ldd	r30, Y+8	; 0x08
    38a6:	f9 85       	ldd	r31, Y+9	; 0x09
    38a8:	80 81       	ld	r24, Z
    38aa:	88 23       	and	r24, r24
    38ac:	81 f4       	brne	.+32     	; 0x38ce <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38ae:	e9 81       	ldd	r30, Y+1	; 0x01
    38b0:	fa 81       	ldd	r31, Y+2	; 0x02
    38b2:	80 85       	ldd	r24, Z+8	; 0x08
    38b4:	88 23       	and	r24, r24
    38b6:	59 f0       	breq	.+22     	; 0x38ce <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	9a 81       	ldd	r25, Y+2	; 0x02
    38bc:	08 96       	adiw	r24, 0x08	; 8
    38be:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <xCoRoutineRemoveFromEventList>
    38c2:	88 23       	and	r24, r24
    38c4:	21 f0       	breq	.+8      	; 0x38ce <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    38c6:	e8 85       	ldd	r30, Y+8	; 0x08
    38c8:	f9 85       	ldd	r31, Y+9	; 0x09
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    38ce:	81 e0       	ldi	r24, 0x01	; 1
    38d0:	8b 83       	std	Y+3, r24	; 0x03
    38d2:	01 c0       	rjmp	.+2      	; 0x38d6 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    38d4:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    38d8:	29 96       	adiw	r28, 0x09	; 9
    38da:	0f b6       	in	r0, 0x3f	; 63
    38dc:	f8 94       	cli
    38de:	de bf       	out	0x3e, r29	; 62
    38e0:	0f be       	out	0x3f, r0	; 63
    38e2:	cd bf       	out	0x3d, r28	; 61
    38e4:	cf 91       	pop	r28
    38e6:	df 91       	pop	r29
    38e8:	08 95       	ret

000038ea <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    38ea:	8f 92       	push	r8
    38ec:	9f 92       	push	r9
    38ee:	af 92       	push	r10
    38f0:	bf 92       	push	r11
    38f2:	cf 92       	push	r12
    38f4:	df 92       	push	r13
    38f6:	ef 92       	push	r14
    38f8:	ff 92       	push	r15
    38fa:	0f 93       	push	r16
    38fc:	1f 93       	push	r17
    38fe:	df 93       	push	r29
    3900:	cf 93       	push	r28
    3902:	cd b7       	in	r28, 0x3d	; 61
    3904:	de b7       	in	r29, 0x3e	; 62
    3906:	60 97       	sbiw	r28, 0x10	; 16
    3908:	0f b6       	in	r0, 0x3f	; 63
    390a:	f8 94       	cli
    390c:	de bf       	out	0x3e, r29	; 62
    390e:	0f be       	out	0x3f, r0	; 63
    3910:	cd bf       	out	0x3d, r28	; 61
    3912:	9f 83       	std	Y+7, r25	; 0x07
    3914:	8e 83       	std	Y+6, r24	; 0x06
    3916:	79 87       	std	Y+9, r23	; 0x09
    3918:	68 87       	std	Y+8, r22	; 0x08
    391a:	5b 87       	std	Y+11, r21	; 0x0b
    391c:	4a 87       	std	Y+10, r20	; 0x0a
    391e:	3d 87       	std	Y+13, r19	; 0x0d
    3920:	2c 87       	std	Y+12, r18	; 0x0c
    3922:	0e 87       	std	Y+14, r16	; 0x0e
    3924:	f8 8a       	std	Y+16, r15	; 0x10
    3926:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3928:	8a 85       	ldd	r24, Y+10	; 0x0a
    392a:	9b 85       	ldd	r25, Y+11	; 0x0b
    392c:	0e 94 b4 08 	call	0x1168	; 0x1168 <pvPortMalloc>
    3930:	9a 83       	std	Y+2, r25	; 0x02
    3932:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    3934:	89 81       	ldd	r24, Y+1	; 0x01
    3936:	9a 81       	ldd	r25, Y+2	; 0x02
    3938:	00 97       	sbiw	r24, 0x00	; 0
    393a:	b1 f0       	breq	.+44     	; 0x3968 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    393c:	86 e2       	ldi	r24, 0x26	; 38
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	0e 94 b4 08 	call	0x1168	; 0x1168 <pvPortMalloc>
    3944:	9d 83       	std	Y+5, r25	; 0x05
    3946:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    3948:	8c 81       	ldd	r24, Y+4	; 0x04
    394a:	9d 81       	ldd	r25, Y+5	; 0x05
    394c:	00 97       	sbiw	r24, 0x00	; 0
    394e:	39 f0       	breq	.+14     	; 0x395e <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    3950:	ec 81       	ldd	r30, Y+4	; 0x04
    3952:	fd 81       	ldd	r31, Y+5	; 0x05
    3954:	89 81       	ldd	r24, Y+1	; 0x01
    3956:	9a 81       	ldd	r25, Y+2	; 0x02
    3958:	90 8f       	std	Z+24, r25	; 0x18
    395a:	87 8b       	std	Z+23, r24	; 0x17
    395c:	07 c0       	rjmp	.+14     	; 0x396c <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    395e:	89 81       	ldd	r24, Y+1	; 0x01
    3960:	9a 81       	ldd	r25, Y+2	; 0x02
    3962:	0e 94 0e 09 	call	0x121c	; 0x121c <vPortFree>
    3966:	02 c0       	rjmp	.+4      	; 0x396c <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    3968:	1d 82       	std	Y+5, r1	; 0x05
    396a:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    396c:	8c 81       	ldd	r24, Y+4	; 0x04
    396e:	9d 81       	ldd	r25, Y+5	; 0x05
    3970:	00 97       	sbiw	r24, 0x00	; 0
    3972:	e9 f0       	breq	.+58     	; 0x39ae <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3974:	8a 85       	ldd	r24, Y+10	; 0x0a
    3976:	9b 85       	ldd	r25, Y+11	; 0x0b
    3978:	9c 01       	movw	r18, r24
    397a:	40 e0       	ldi	r20, 0x00	; 0
    397c:	50 e0       	ldi	r21, 0x00	; 0
    397e:	8e 81       	ldd	r24, Y+6	; 0x06
    3980:	9f 81       	ldd	r25, Y+7	; 0x07
    3982:	68 85       	ldd	r22, Y+8	; 0x08
    3984:	79 85       	ldd	r23, Y+9	; 0x09
    3986:	ec 85       	ldd	r30, Y+12	; 0x0c
    3988:	fd 85       	ldd	r31, Y+13	; 0x0d
    398a:	af 85       	ldd	r26, Y+15	; 0x0f
    398c:	b8 89       	ldd	r27, Y+16	; 0x10
    398e:	ac 80       	ldd	r10, Y+4	; 0x04
    3990:	bd 80       	ldd	r11, Y+5	; 0x05
    3992:	8f 01       	movw	r16, r30
    3994:	ee 84       	ldd	r14, Y+14	; 0x0e
    3996:	6d 01       	movw	r12, r26
    3998:	88 24       	eor	r8, r8
    399a:	99 24       	eor	r9, r9
    399c:	0e 94 ed 1c 	call	0x39da	; 0x39da <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    39a0:	8c 81       	ldd	r24, Y+4	; 0x04
    39a2:	9d 81       	ldd	r25, Y+5	; 0x05
    39a4:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	8b 83       	std	Y+3, r24	; 0x03
    39ac:	02 c0       	rjmp	.+4      	; 0x39b2 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    39ae:	8f ef       	ldi	r24, 0xFF	; 255
    39b0:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    39b2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    39b4:	60 96       	adiw	r28, 0x10	; 16
    39b6:	0f b6       	in	r0, 0x3f	; 63
    39b8:	f8 94       	cli
    39ba:	de bf       	out	0x3e, r29	; 62
    39bc:	0f be       	out	0x3f, r0	; 63
    39be:	cd bf       	out	0x3d, r28	; 61
    39c0:	cf 91       	pop	r28
    39c2:	df 91       	pop	r29
    39c4:	1f 91       	pop	r17
    39c6:	0f 91       	pop	r16
    39c8:	ff 90       	pop	r15
    39ca:	ef 90       	pop	r14
    39cc:	df 90       	pop	r13
    39ce:	cf 90       	pop	r12
    39d0:	bf 90       	pop	r11
    39d2:	af 90       	pop	r10
    39d4:	9f 90       	pop	r9
    39d6:	8f 90       	pop	r8
    39d8:	08 95       	ret

000039da <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    39da:	8f 92       	push	r8
    39dc:	9f 92       	push	r9
    39de:	af 92       	push	r10
    39e0:	bf 92       	push	r11
    39e2:	cf 92       	push	r12
    39e4:	df 92       	push	r13
    39e6:	ef 92       	push	r14
    39e8:	0f 93       	push	r16
    39ea:	1f 93       	push	r17
    39ec:	df 93       	push	r29
    39ee:	cf 93       	push	r28
    39f0:	cd b7       	in	r28, 0x3d	; 61
    39f2:	de b7       	in	r29, 0x3e	; 62
    39f4:	64 97       	sbiw	r28, 0x14	; 20
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	f8 94       	cli
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	0f be       	out	0x3f, r0	; 63
    39fe:	cd bf       	out	0x3d, r28	; 61
    3a00:	9d 83       	std	Y+5, r25	; 0x05
    3a02:	8c 83       	std	Y+4, r24	; 0x04
    3a04:	7f 83       	std	Y+7, r23	; 0x07
    3a06:	6e 83       	std	Y+6, r22	; 0x06
    3a08:	28 87       	std	Y+8, r18	; 0x08
    3a0a:	39 87       	std	Y+9, r19	; 0x09
    3a0c:	4a 87       	std	Y+10, r20	; 0x0a
    3a0e:	5b 87       	std	Y+11, r21	; 0x0b
    3a10:	1d 87       	std	Y+13, r17	; 0x0d
    3a12:	0c 87       	std	Y+12, r16	; 0x0c
    3a14:	ee 86       	std	Y+14, r14	; 0x0e
    3a16:	d8 8a       	std	Y+16, r13	; 0x10
    3a18:	cf 86       	std	Y+15, r12	; 0x0f
    3a1a:	ba 8a       	std	Y+18, r11	; 0x12
    3a1c:	a9 8a       	std	Y+17, r10	; 0x11
    3a1e:	9c 8a       	std	Y+20, r9	; 0x14
    3a20:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3a22:	e9 89       	ldd	r30, Y+17	; 0x11
    3a24:	fa 89       	ldd	r31, Y+18	; 0x12
    3a26:	27 89       	ldd	r18, Z+23	; 0x17
    3a28:	30 8d       	ldd	r19, Z+24	; 0x18
    3a2a:	88 85       	ldd	r24, Y+8	; 0x08
    3a2c:	99 85       	ldd	r25, Y+9	; 0x09
    3a2e:	01 97       	sbiw	r24, 0x01	; 1
    3a30:	82 0f       	add	r24, r18
    3a32:	93 1f       	adc	r25, r19
    3a34:	9b 83       	std	Y+3, r25	; 0x03
    3a36:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3a38:	8e 81       	ldd	r24, Y+6	; 0x06
    3a3a:	9f 81       	ldd	r25, Y+7	; 0x07
    3a3c:	00 97       	sbiw	r24, 0x00	; 0
    3a3e:	51 f1       	breq	.+84     	; 0x3a94 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3a40:	19 82       	std	Y+1, r1	; 0x01
    3a42:	21 c0       	rjmp	.+66     	; 0x3a86 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3a44:	89 81       	ldd	r24, Y+1	; 0x01
    3a46:	48 2f       	mov	r20, r24
    3a48:	50 e0       	ldi	r21, 0x00	; 0
    3a4a:	89 81       	ldd	r24, Y+1	; 0x01
    3a4c:	28 2f       	mov	r18, r24
    3a4e:	30 e0       	ldi	r19, 0x00	; 0
    3a50:	8e 81       	ldd	r24, Y+6	; 0x06
    3a52:	9f 81       	ldd	r25, Y+7	; 0x07
    3a54:	fc 01       	movw	r30, r24
    3a56:	e2 0f       	add	r30, r18
    3a58:	f3 1f       	adc	r31, r19
    3a5a:	20 81       	ld	r18, Z
    3a5c:	89 89       	ldd	r24, Y+17	; 0x11
    3a5e:	9a 89       	ldd	r25, Y+18	; 0x12
    3a60:	84 0f       	add	r24, r20
    3a62:	95 1f       	adc	r25, r21
    3a64:	fc 01       	movw	r30, r24
    3a66:	79 96       	adiw	r30, 0x19	; 25
    3a68:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3a6a:	89 81       	ldd	r24, Y+1	; 0x01
    3a6c:	28 2f       	mov	r18, r24
    3a6e:	30 e0       	ldi	r19, 0x00	; 0
    3a70:	8e 81       	ldd	r24, Y+6	; 0x06
    3a72:	9f 81       	ldd	r25, Y+7	; 0x07
    3a74:	fc 01       	movw	r30, r24
    3a76:	e2 0f       	add	r30, r18
    3a78:	f3 1f       	adc	r31, r19
    3a7a:	80 81       	ld	r24, Z
    3a7c:	88 23       	and	r24, r24
    3a7e:	31 f0       	breq	.+12     	; 0x3a8c <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3a80:	89 81       	ldd	r24, Y+1	; 0x01
    3a82:	8f 5f       	subi	r24, 0xFF	; 255
    3a84:	89 83       	std	Y+1, r24	; 0x01
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	88 30       	cpi	r24, 0x08	; 8
    3a8a:	e0 f2       	brcs	.-72     	; 0x3a44 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3a8c:	e9 89       	ldd	r30, Y+17	; 0x11
    3a8e:	fa 89       	ldd	r31, Y+18	; 0x12
    3a90:	10 a2       	std	Z+32, r1	; 0x20
    3a92:	03 c0       	rjmp	.+6      	; 0x3a9a <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3a94:	e9 89       	ldd	r30, Y+17	; 0x11
    3a96:	fa 89       	ldd	r31, Y+18	; 0x12
    3a98:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3a9a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a9c:	84 30       	cpi	r24, 0x04	; 4
    3a9e:	10 f0       	brcs	.+4      	; 0x3aa4 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3aa0:	83 e0       	ldi	r24, 0x03	; 3
    3aa2:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3aa4:	e9 89       	ldd	r30, Y+17	; 0x11
    3aa6:	fa 89       	ldd	r31, Y+18	; 0x12
    3aa8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3aaa:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3aac:	89 89       	ldd	r24, Y+17	; 0x11
    3aae:	9a 89       	ldd	r25, Y+18	; 0x12
    3ab0:	02 96       	adiw	r24, 0x02	; 2
    3ab2:	0e 94 56 12 	call	0x24ac	; 0x24ac <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3ab6:	89 89       	ldd	r24, Y+17	; 0x11
    3ab8:	9a 89       	ldd	r25, Y+18	; 0x12
    3aba:	0c 96       	adiw	r24, 0x0c	; 12
    3abc:	0e 94 56 12 	call	0x24ac	; 0x24ac <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3ac0:	e9 89       	ldd	r30, Y+17	; 0x11
    3ac2:	fa 89       	ldd	r31, Y+18	; 0x12
    3ac4:	89 89       	ldd	r24, Y+17	; 0x11
    3ac6:	9a 89       	ldd	r25, Y+18	; 0x12
    3ac8:	91 87       	std	Z+9, r25	; 0x09
    3aca:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3acc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ace:	28 2f       	mov	r18, r24
    3ad0:	30 e0       	ldi	r19, 0x00	; 0
    3ad2:	84 e0       	ldi	r24, 0x04	; 4
    3ad4:	90 e0       	ldi	r25, 0x00	; 0
    3ad6:	82 1b       	sub	r24, r18
    3ad8:	93 0b       	sbc	r25, r19
    3ada:	e9 89       	ldd	r30, Y+17	; 0x11
    3adc:	fa 89       	ldd	r31, Y+18	; 0x12
    3ade:	95 87       	std	Z+13, r25	; 0x0d
    3ae0:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3ae2:	e9 89       	ldd	r30, Y+17	; 0x11
    3ae4:	fa 89       	ldd	r31, Y+18	; 0x12
    3ae6:	89 89       	ldd	r24, Y+17	; 0x11
    3ae8:	9a 89       	ldd	r25, Y+18	; 0x12
    3aea:	93 8b       	std	Z+19, r25	; 0x13
    3aec:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3aee:	89 89       	ldd	r24, Y+17	; 0x11
    3af0:	9a 89       	ldd	r25, Y+18	; 0x12
    3af2:	81 96       	adiw	r24, 0x21	; 33
    3af4:	60 e0       	ldi	r22, 0x00	; 0
    3af6:	70 e0       	ldi	r23, 0x00	; 0
    3af8:	44 e0       	ldi	r20, 0x04	; 4
    3afa:	50 e0       	ldi	r21, 0x00	; 0
    3afc:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3b00:	89 89       	ldd	r24, Y+17	; 0x11
    3b02:	9a 89       	ldd	r25, Y+18	; 0x12
    3b04:	85 96       	adiw	r24, 0x25	; 37
    3b06:	60 e0       	ldi	r22, 0x00	; 0
    3b08:	70 e0       	ldi	r23, 0x00	; 0
    3b0a:	41 e0       	ldi	r20, 0x01	; 1
    3b0c:	50 e0       	ldi	r21, 0x00	; 0
    3b0e:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3b12:	8a 81       	ldd	r24, Y+2	; 0x02
    3b14:	9b 81       	ldd	r25, Y+3	; 0x03
    3b16:	2c 81       	ldd	r18, Y+4	; 0x04
    3b18:	3d 81       	ldd	r19, Y+5	; 0x05
    3b1a:	4c 85       	ldd	r20, Y+12	; 0x0c
    3b1c:	5d 85       	ldd	r21, Y+13	; 0x0d
    3b1e:	b9 01       	movw	r22, r18
    3b20:	0e 94 34 09 	call	0x1268	; 0x1268 <pxPortInitialiseStack>
    3b24:	e9 89       	ldd	r30, Y+17	; 0x11
    3b26:	fa 89       	ldd	r31, Y+18	; 0x12
    3b28:	91 83       	std	Z+1, r25	; 0x01
    3b2a:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3b2c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b2e:	98 89       	ldd	r25, Y+16	; 0x10
    3b30:	00 97       	sbiw	r24, 0x00	; 0
    3b32:	31 f0       	breq	.+12     	; 0x3b40 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3b34:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b36:	f8 89       	ldd	r31, Y+16	; 0x10
    3b38:	89 89       	ldd	r24, Y+17	; 0x11
    3b3a:	9a 89       	ldd	r25, Y+18	; 0x12
    3b3c:	91 83       	std	Z+1, r25	; 0x01
    3b3e:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3b40:	64 96       	adiw	r28, 0x14	; 20
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	de bf       	out	0x3e, r29	; 62
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	cd bf       	out	0x3d, r28	; 61
    3b4c:	cf 91       	pop	r28
    3b4e:	df 91       	pop	r29
    3b50:	1f 91       	pop	r17
    3b52:	0f 91       	pop	r16
    3b54:	ef 90       	pop	r14
    3b56:	df 90       	pop	r13
    3b58:	cf 90       	pop	r12
    3b5a:	bf 90       	pop	r11
    3b5c:	af 90       	pop	r10
    3b5e:	9f 90       	pop	r9
    3b60:	8f 90       	pop	r8
    3b62:	08 95       	ret

00003b64 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3b64:	df 93       	push	r29
    3b66:	cf 93       	push	r28
    3b68:	00 d0       	rcall	.+0      	; 0x3b6a <prvAddNewTaskToReadyList+0x6>
    3b6a:	00 d0       	rcall	.+0      	; 0x3b6c <prvAddNewTaskToReadyList+0x8>
    3b6c:	cd b7       	in	r28, 0x3d	; 61
    3b6e:	de b7       	in	r29, 0x3e	; 62
    3b70:	9c 83       	std	Y+4, r25	; 0x04
    3b72:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3b74:	0f b6       	in	r0, 0x3f	; 63
    3b76:	f8 94       	cli
    3b78:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3b7a:	80 91 41 04 	lds	r24, 0x0441
    3b7e:	8f 5f       	subi	r24, 0xFF	; 255
    3b80:	80 93 41 04 	sts	0x0441, r24

        if( pxCurrentTCB == NULL )
    3b84:	80 91 3f 04 	lds	r24, 0x043F
    3b88:	90 91 40 04 	lds	r25, 0x0440
    3b8c:	00 97       	sbiw	r24, 0x00	; 0
    3b8e:	69 f4       	brne	.+26     	; 0x3baa <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3b90:	8b 81       	ldd	r24, Y+3	; 0x03
    3b92:	9c 81       	ldd	r25, Y+4	; 0x04
    3b94:	90 93 40 04 	sts	0x0440, r25
    3b98:	80 93 3f 04 	sts	0x043F, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3b9c:	80 91 41 04 	lds	r24, 0x0441
    3ba0:	81 30       	cpi	r24, 0x01	; 1
    3ba2:	b9 f4       	brne	.+46     	; 0x3bd2 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3ba4:	0e 94 40 26 	call	0x4c80	; 0x4c80 <prvInitialiseTaskLists>
    3ba8:	14 c0       	rjmp	.+40     	; 0x3bd2 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3baa:	80 91 45 04 	lds	r24, 0x0445
    3bae:	88 23       	and	r24, r24
    3bb0:	81 f4       	brne	.+32     	; 0x3bd2 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3bb2:	e0 91 3f 04 	lds	r30, 0x043F
    3bb6:	f0 91 40 04 	lds	r31, 0x0440
    3bba:	96 89       	ldd	r25, Z+22	; 0x16
    3bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    3bc0:	86 89       	ldd	r24, Z+22	; 0x16
    3bc2:	89 17       	cp	r24, r25
    3bc4:	30 f0       	brcs	.+12     	; 0x3bd2 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    3bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bca:	90 93 40 04 	sts	0x0440, r25
    3bce:	80 93 3f 04 	sts	0x043F, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3bd2:	80 91 4a 04 	lds	r24, 0x044A
    3bd6:	8f 5f       	subi	r24, 0xFF	; 255
    3bd8:	80 93 4a 04 	sts	0x044A, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bde:	fc 81       	ldd	r31, Y+4	; 0x04
    3be0:	96 89       	ldd	r25, Z+22	; 0x16
    3be2:	80 91 44 04 	lds	r24, 0x0444
    3be6:	89 17       	cp	r24, r25
    3be8:	28 f4       	brcc	.+10     	; 0x3bf4 <prvAddNewTaskToReadyList+0x90>
    3bea:	eb 81       	ldd	r30, Y+3	; 0x03
    3bec:	fc 81       	ldd	r31, Y+4	; 0x04
    3bee:	86 89       	ldd	r24, Z+22	; 0x16
    3bf0:	80 93 44 04 	sts	0x0444, r24
    3bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf8:	86 89       	ldd	r24, Z+22	; 0x16
    3bfa:	28 2f       	mov	r18, r24
    3bfc:	30 e0       	ldi	r19, 0x00	; 0
    3bfe:	c9 01       	movw	r24, r18
    3c00:	88 0f       	add	r24, r24
    3c02:	99 1f       	adc	r25, r25
    3c04:	88 0f       	add	r24, r24
    3c06:	99 1f       	adc	r25, r25
    3c08:	88 0f       	add	r24, r24
    3c0a:	99 1f       	adc	r25, r25
    3c0c:	82 0f       	add	r24, r18
    3c0e:	93 1f       	adc	r25, r19
    3c10:	fc 01       	movw	r30, r24
    3c12:	e0 5b       	subi	r30, 0xB0	; 176
    3c14:	fb 4f       	sbci	r31, 0xFB	; 251
    3c16:	81 81       	ldd	r24, Z+1	; 0x01
    3c18:	92 81       	ldd	r25, Z+2	; 0x02
    3c1a:	9a 83       	std	Y+2, r25	; 0x02
    3c1c:	89 83       	std	Y+1, r24	; 0x01
    3c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c20:	fc 81       	ldd	r31, Y+4	; 0x04
    3c22:	89 81       	ldd	r24, Y+1	; 0x01
    3c24:	9a 81       	ldd	r25, Y+2	; 0x02
    3c26:	95 83       	std	Z+5, r25	; 0x05
    3c28:	84 83       	std	Z+4, r24	; 0x04
    3c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2e:	84 81       	ldd	r24, Z+4	; 0x04
    3c30:	95 81       	ldd	r25, Z+5	; 0x05
    3c32:	eb 81       	ldd	r30, Y+3	; 0x03
    3c34:	fc 81       	ldd	r31, Y+4	; 0x04
    3c36:	97 83       	std	Z+7, r25	; 0x07
    3c38:	86 83       	std	Z+6, r24	; 0x06
    3c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3e:	04 80       	ldd	r0, Z+4	; 0x04
    3c40:	f5 81       	ldd	r31, Z+5	; 0x05
    3c42:	e0 2d       	mov	r30, r0
    3c44:	8b 81       	ldd	r24, Y+3	; 0x03
    3c46:	9c 81       	ldd	r25, Y+4	; 0x04
    3c48:	02 96       	adiw	r24, 0x02	; 2
    3c4a:	93 83       	std	Z+3, r25	; 0x03
    3c4c:	82 83       	std	Z+2, r24	; 0x02
    3c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c50:	9c 81       	ldd	r25, Y+4	; 0x04
    3c52:	02 96       	adiw	r24, 0x02	; 2
    3c54:	e9 81       	ldd	r30, Y+1	; 0x01
    3c56:	fa 81       	ldd	r31, Y+2	; 0x02
    3c58:	95 83       	std	Z+5, r25	; 0x05
    3c5a:	84 83       	std	Z+4, r24	; 0x04
    3c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c60:	86 89       	ldd	r24, Z+22	; 0x16
    3c62:	28 2f       	mov	r18, r24
    3c64:	30 e0       	ldi	r19, 0x00	; 0
    3c66:	c9 01       	movw	r24, r18
    3c68:	88 0f       	add	r24, r24
    3c6a:	99 1f       	adc	r25, r25
    3c6c:	88 0f       	add	r24, r24
    3c6e:	99 1f       	adc	r25, r25
    3c70:	88 0f       	add	r24, r24
    3c72:	99 1f       	adc	r25, r25
    3c74:	82 0f       	add	r24, r18
    3c76:	93 1f       	adc	r25, r19
    3c78:	80 5b       	subi	r24, 0xB0	; 176
    3c7a:	9b 4f       	sbci	r25, 0xFB	; 251
    3c7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c80:	93 87       	std	Z+11, r25	; 0x0b
    3c82:	82 87       	std	Z+10, r24	; 0x0a
    3c84:	eb 81       	ldd	r30, Y+3	; 0x03
    3c86:	fc 81       	ldd	r31, Y+4	; 0x04
    3c88:	86 89       	ldd	r24, Z+22	; 0x16
    3c8a:	28 2f       	mov	r18, r24
    3c8c:	30 e0       	ldi	r19, 0x00	; 0
    3c8e:	c9 01       	movw	r24, r18
    3c90:	88 0f       	add	r24, r24
    3c92:	99 1f       	adc	r25, r25
    3c94:	88 0f       	add	r24, r24
    3c96:	99 1f       	adc	r25, r25
    3c98:	88 0f       	add	r24, r24
    3c9a:	99 1f       	adc	r25, r25
    3c9c:	82 0f       	add	r24, r18
    3c9e:	93 1f       	adc	r25, r19
    3ca0:	fc 01       	movw	r30, r24
    3ca2:	e0 5b       	subi	r30, 0xB0	; 176
    3ca4:	fb 4f       	sbci	r31, 0xFB	; 251
    3ca6:	80 81       	ld	r24, Z
    3ca8:	8f 5f       	subi	r24, 0xFF	; 255
    3caa:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3cac:	0f 90       	pop	r0
    3cae:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3cb0:	80 91 45 04 	lds	r24, 0x0445
    3cb4:	88 23       	and	r24, r24
    3cb6:	61 f0       	breq	.+24     	; 0x3cd0 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3cb8:	e0 91 3f 04 	lds	r30, 0x043F
    3cbc:	f0 91 40 04 	lds	r31, 0x0440
    3cc0:	96 89       	ldd	r25, Z+22	; 0x16
    3cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    3cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    3cc6:	86 89       	ldd	r24, Z+22	; 0x16
    3cc8:	98 17       	cp	r25, r24
    3cca:	10 f4       	brcc	.+4      	; 0x3cd0 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3ccc:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3cd0:	0f 90       	pop	r0
    3cd2:	0f 90       	pop	r0
    3cd4:	0f 90       	pop	r0
    3cd6:	0f 90       	pop	r0
    3cd8:	cf 91       	pop	r28
    3cda:	df 91       	pop	r29
    3cdc:	08 95       	ret

00003cde <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3cde:	df 93       	push	r29
    3ce0:	cf 93       	push	r28
    3ce2:	00 d0       	rcall	.+0      	; 0x3ce4 <vTaskDelay+0x6>
    3ce4:	0f 92       	push	r0
    3ce6:	cd b7       	in	r28, 0x3d	; 61
    3ce8:	de b7       	in	r29, 0x3e	; 62
    3cea:	9b 83       	std	Y+3, r25	; 0x03
    3cec:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3cee:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3cf0:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf2:	9b 81       	ldd	r25, Y+3	; 0x03
    3cf4:	00 97       	sbiw	r24, 0x00	; 0
    3cf6:	51 f0       	breq	.+20     	; 0x3d0c <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3cf8:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3cfe:	9b 81       	ldd	r25, Y+3	; 0x03
    3d00:	60 e0       	ldi	r22, 0x00	; 0
    3d02:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3d06:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    3d0a:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3d0c:	89 81       	ldd	r24, Y+1	; 0x01
    3d0e:	88 23       	and	r24, r24
    3d10:	11 f4       	brne	.+4      	; 0x3d16 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3d12:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3d16:	0f 90       	pop	r0
    3d18:	0f 90       	pop	r0
    3d1a:	0f 90       	pop	r0
    3d1c:	cf 91       	pop	r28
    3d1e:	df 91       	pop	r29
    3d20:	08 95       	ret

00003d22 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3d22:	ef 92       	push	r14
    3d24:	ff 92       	push	r15
    3d26:	0f 93       	push	r16
    3d28:	df 93       	push	r29
    3d2a:	cf 93       	push	r28
    3d2c:	00 d0       	rcall	.+0      	; 0x3d2e <vTaskStartScheduler+0xc>
    3d2e:	cd b7       	in	r28, 0x3d	; 61
    3d30:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3d32:	80 e3       	ldi	r24, 0x30	; 48
    3d34:	96 e2       	ldi	r25, 0x26	; 38
    3d36:	25 e9       	ldi	r18, 0x95	; 149
    3d38:	30 e0       	ldi	r19, 0x00	; 0
    3d3a:	ed e4       	ldi	r30, 0x4D	; 77
    3d3c:	f4 e0       	ldi	r31, 0x04	; 4
    3d3e:	b9 01       	movw	r22, r18
    3d40:	41 e4       	ldi	r20, 0x41	; 65
    3d42:	50 e0       	ldi	r21, 0x00	; 0
    3d44:	20 e0       	ldi	r18, 0x00	; 0
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	00 e0       	ldi	r16, 0x00	; 0
    3d4a:	7f 01       	movw	r14, r30
    3d4c:	0e 94 75 1c 	call	0x38ea	; 0x38ea <xTaskCreate>
    3d50:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3d52:	89 81       	ldd	r24, Y+1	; 0x01
    3d54:	81 30       	cpi	r24, 0x01	; 1
    3d56:	81 f4       	brne	.+32     	; 0x3d78 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3d58:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3d5a:	8f ef       	ldi	r24, 0xFF	; 255
    3d5c:	9f ef       	ldi	r25, 0xFF	; 255
    3d5e:	90 93 4c 04 	sts	0x044C, r25
    3d62:	80 93 4b 04 	sts	0x044B, r24
        xSchedulerRunning = pdTRUE;
    3d66:	81 e0       	ldi	r24, 0x01	; 1
    3d68:	80 93 45 04 	sts	0x0445, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3d6c:	10 92 43 04 	sts	0x0443, r1
    3d70:	10 92 42 04 	sts	0x0442, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3d74:	0e 94 b7 0a 	call	0x156e	; 0x156e <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3d78:	80 91 9a 00 	lds	r24, 0x009A
}
    3d7c:	0f 90       	pop	r0
    3d7e:	0f 90       	pop	r0
    3d80:	cf 91       	pop	r28
    3d82:	df 91       	pop	r29
    3d84:	0f 91       	pop	r16
    3d86:	ff 90       	pop	r15
    3d88:	ef 90       	pop	r14
    3d8a:	08 95       	ret

00003d8c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3d8c:	df 93       	push	r29
    3d8e:	cf 93       	push	r28
    3d90:	cd b7       	in	r28, 0x3d	; 61
    3d92:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3d94:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3d96:	10 92 45 04 	sts	0x0445, r1
    vPortEndScheduler();
    3d9a:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <vPortEndScheduler>
}
    3d9e:	cf 91       	pop	r28
    3da0:	df 91       	pop	r29
    3da2:	08 95       	ret

00003da4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3da4:	df 93       	push	r29
    3da6:	cf 93       	push	r28
    3da8:	cd b7       	in	r28, 0x3d	; 61
    3daa:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3dac:	80 91 4f 04 	lds	r24, 0x044F
    3db0:	8f 5f       	subi	r24, 0xFF	; 255
    3db2:	80 93 4f 04 	sts	0x044F, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3db6:	cf 91       	pop	r28
    3db8:	df 91       	pop	r29
    3dba:	08 95       	ret

00003dbc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3dbc:	df 93       	push	r29
    3dbe:	cf 93       	push	r28
    3dc0:	cd b7       	in	r28, 0x3d	; 61
    3dc2:	de b7       	in	r29, 0x3e	; 62
    3dc4:	2b 97       	sbiw	r28, 0x0b	; 11
    3dc6:	0f b6       	in	r0, 0x3f	; 63
    3dc8:	f8 94       	cli
    3dca:	de bf       	out	0x3e, r29	; 62
    3dcc:	0f be       	out	0x3f, r0	; 63
    3dce:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3dd0:	1b 86       	std	Y+11, r1	; 0x0b
    3dd2:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3dd4:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3dd6:	0f b6       	in	r0, 0x3f	; 63
    3dd8:	f8 94       	cli
    3dda:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3ddc:	80 91 4f 04 	lds	r24, 0x044F
    3de0:	81 50       	subi	r24, 0x01	; 1
    3de2:	80 93 4f 04 	sts	0x044F, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3de6:	80 91 4f 04 	lds	r24, 0x044F
    3dea:	88 23       	and	r24, r24
    3dec:	09 f0       	breq	.+2      	; 0x3df0 <xTaskResumeAll+0x34>
    3dee:	2a c1       	rjmp	.+596    	; 0x4044 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3df0:	80 91 41 04 	lds	r24, 0x0441
    3df4:	88 23       	and	r24, r24
    3df6:	09 f4       	brne	.+2      	; 0x3dfa <xTaskResumeAll+0x3e>
    3df8:	25 c1       	rjmp	.+586    	; 0x4044 <xTaskResumeAll+0x288>
    3dfa:	f3 c0       	rjmp	.+486    	; 0x3fe2 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3dfc:	e0 91 8f 04 	lds	r30, 0x048F
    3e00:	f0 91 90 04 	lds	r31, 0x0490
    3e04:	86 81       	ldd	r24, Z+6	; 0x06
    3e06:	97 81       	ldd	r25, Z+7	; 0x07
    3e08:	9b 87       	std	Y+11, r25	; 0x0b
    3e0a:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3e0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e10:	84 89       	ldd	r24, Z+20	; 0x14
    3e12:	95 89       	ldd	r25, Z+21	; 0x15
    3e14:	98 87       	std	Y+8, r25	; 0x08
    3e16:	8f 83       	std	Y+7, r24	; 0x07
    3e18:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e1c:	a6 85       	ldd	r26, Z+14	; 0x0e
    3e1e:	b7 85       	ldd	r27, Z+15	; 0x0f
    3e20:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e22:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e24:	80 89       	ldd	r24, Z+16	; 0x10
    3e26:	91 89       	ldd	r25, Z+17	; 0x11
    3e28:	15 96       	adiw	r26, 0x05	; 5
    3e2a:	9c 93       	st	X, r25
    3e2c:	8e 93       	st	-X, r24
    3e2e:	14 97       	sbiw	r26, 0x04	; 4
    3e30:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e32:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e34:	a0 89       	ldd	r26, Z+16	; 0x10
    3e36:	b1 89       	ldd	r27, Z+17	; 0x11
    3e38:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e3c:	86 85       	ldd	r24, Z+14	; 0x0e
    3e3e:	97 85       	ldd	r25, Z+15	; 0x0f
    3e40:	13 96       	adiw	r26, 0x03	; 3
    3e42:	9c 93       	st	X, r25
    3e44:	8e 93       	st	-X, r24
    3e46:	12 97       	sbiw	r26, 0x02	; 2
    3e48:	ef 81       	ldd	r30, Y+7	; 0x07
    3e4a:	f8 85       	ldd	r31, Y+8	; 0x08
    3e4c:	21 81       	ldd	r18, Z+1	; 0x01
    3e4e:	32 81       	ldd	r19, Z+2	; 0x02
    3e50:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e52:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e54:	0c 96       	adiw	r24, 0x0c	; 12
    3e56:	28 17       	cp	r18, r24
    3e58:	39 07       	cpc	r19, r25
    3e5a:	41 f4       	brne	.+16     	; 0x3e6c <xTaskResumeAll+0xb0>
    3e5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e60:	80 89       	ldd	r24, Z+16	; 0x10
    3e62:	91 89       	ldd	r25, Z+17	; 0x11
    3e64:	ef 81       	ldd	r30, Y+7	; 0x07
    3e66:	f8 85       	ldd	r31, Y+8	; 0x08
    3e68:	92 83       	std	Z+2, r25	; 0x02
    3e6a:	81 83       	std	Z+1, r24	; 0x01
    3e6c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e6e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e70:	15 8a       	std	Z+21, r1	; 0x15
    3e72:	14 8a       	std	Z+20, r1	; 0x14
    3e74:	ef 81       	ldd	r30, Y+7	; 0x07
    3e76:	f8 85       	ldd	r31, Y+8	; 0x08
    3e78:	80 81       	ld	r24, Z
    3e7a:	81 50       	subi	r24, 0x01	; 1
    3e7c:	ef 81       	ldd	r30, Y+7	; 0x07
    3e7e:	f8 85       	ldd	r31, Y+8	; 0x08
    3e80:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3e82:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e84:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e86:	82 85       	ldd	r24, Z+10	; 0x0a
    3e88:	93 85       	ldd	r25, Z+11	; 0x0b
    3e8a:	9e 83       	std	Y+6, r25	; 0x06
    3e8c:	8d 83       	std	Y+5, r24	; 0x05
    3e8e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e90:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e92:	a4 81       	ldd	r26, Z+4	; 0x04
    3e94:	b5 81       	ldd	r27, Z+5	; 0x05
    3e96:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e98:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e9a:	86 81       	ldd	r24, Z+6	; 0x06
    3e9c:	97 81       	ldd	r25, Z+7	; 0x07
    3e9e:	15 96       	adiw	r26, 0x05	; 5
    3ea0:	9c 93       	st	X, r25
    3ea2:	8e 93       	st	-X, r24
    3ea4:	14 97       	sbiw	r26, 0x04	; 4
    3ea6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ea8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eaa:	a6 81       	ldd	r26, Z+6	; 0x06
    3eac:	b7 81       	ldd	r27, Z+7	; 0x07
    3eae:	ea 85       	ldd	r30, Y+10	; 0x0a
    3eb0:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eb2:	84 81       	ldd	r24, Z+4	; 0x04
    3eb4:	95 81       	ldd	r25, Z+5	; 0x05
    3eb6:	13 96       	adiw	r26, 0x03	; 3
    3eb8:	9c 93       	st	X, r25
    3eba:	8e 93       	st	-X, r24
    3ebc:	12 97       	sbiw	r26, 0x02	; 2
    3ebe:	ed 81       	ldd	r30, Y+5	; 0x05
    3ec0:	fe 81       	ldd	r31, Y+6	; 0x06
    3ec2:	21 81       	ldd	r18, Z+1	; 0x01
    3ec4:	32 81       	ldd	r19, Z+2	; 0x02
    3ec6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ec8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3eca:	02 96       	adiw	r24, 0x02	; 2
    3ecc:	28 17       	cp	r18, r24
    3ece:	39 07       	cpc	r19, r25
    3ed0:	41 f4       	brne	.+16     	; 0x3ee2 <xTaskResumeAll+0x126>
    3ed2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ed4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ed6:	86 81       	ldd	r24, Z+6	; 0x06
    3ed8:	97 81       	ldd	r25, Z+7	; 0x07
    3eda:	ed 81       	ldd	r30, Y+5	; 0x05
    3edc:	fe 81       	ldd	r31, Y+6	; 0x06
    3ede:	92 83       	std	Z+2, r25	; 0x02
    3ee0:	81 83       	std	Z+1, r24	; 0x01
    3ee2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ee4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ee6:	13 86       	std	Z+11, r1	; 0x0b
    3ee8:	12 86       	std	Z+10, r1	; 0x0a
    3eea:	ed 81       	ldd	r30, Y+5	; 0x05
    3eec:	fe 81       	ldd	r31, Y+6	; 0x06
    3eee:	80 81       	ld	r24, Z
    3ef0:	81 50       	subi	r24, 0x01	; 1
    3ef2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ef4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ef6:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3ef8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3efa:	fb 85       	ldd	r31, Y+11	; 0x0b
    3efc:	96 89       	ldd	r25, Z+22	; 0x16
    3efe:	80 91 44 04 	lds	r24, 0x0444
    3f02:	89 17       	cp	r24, r25
    3f04:	28 f4       	brcc	.+10     	; 0x3f10 <xTaskResumeAll+0x154>
    3f06:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f08:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f0a:	86 89       	ldd	r24, Z+22	; 0x16
    3f0c:	80 93 44 04 	sts	0x0444, r24
    3f10:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f12:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f14:	86 89       	ldd	r24, Z+22	; 0x16
    3f16:	28 2f       	mov	r18, r24
    3f18:	30 e0       	ldi	r19, 0x00	; 0
    3f1a:	c9 01       	movw	r24, r18
    3f1c:	88 0f       	add	r24, r24
    3f1e:	99 1f       	adc	r25, r25
    3f20:	88 0f       	add	r24, r24
    3f22:	99 1f       	adc	r25, r25
    3f24:	88 0f       	add	r24, r24
    3f26:	99 1f       	adc	r25, r25
    3f28:	82 0f       	add	r24, r18
    3f2a:	93 1f       	adc	r25, r19
    3f2c:	fc 01       	movw	r30, r24
    3f2e:	e0 5b       	subi	r30, 0xB0	; 176
    3f30:	fb 4f       	sbci	r31, 0xFB	; 251
    3f32:	81 81       	ldd	r24, Z+1	; 0x01
    3f34:	92 81       	ldd	r25, Z+2	; 0x02
    3f36:	9c 83       	std	Y+4, r25	; 0x04
    3f38:	8b 83       	std	Y+3, r24	; 0x03
    3f3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f40:	9c 81       	ldd	r25, Y+4	; 0x04
    3f42:	95 83       	std	Z+5, r25	; 0x05
    3f44:	84 83       	std	Z+4, r24	; 0x04
    3f46:	eb 81       	ldd	r30, Y+3	; 0x03
    3f48:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4a:	84 81       	ldd	r24, Z+4	; 0x04
    3f4c:	95 81       	ldd	r25, Z+5	; 0x05
    3f4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f50:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f52:	97 83       	std	Z+7, r25	; 0x07
    3f54:	86 83       	std	Z+6, r24	; 0x06
    3f56:	eb 81       	ldd	r30, Y+3	; 0x03
    3f58:	fc 81       	ldd	r31, Y+4	; 0x04
    3f5a:	04 80       	ldd	r0, Z+4	; 0x04
    3f5c:	f5 81       	ldd	r31, Z+5	; 0x05
    3f5e:	e0 2d       	mov	r30, r0
    3f60:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f62:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f64:	02 96       	adiw	r24, 0x02	; 2
    3f66:	93 83       	std	Z+3, r25	; 0x03
    3f68:	82 83       	std	Z+2, r24	; 0x02
    3f6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f6c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f6e:	02 96       	adiw	r24, 0x02	; 2
    3f70:	eb 81       	ldd	r30, Y+3	; 0x03
    3f72:	fc 81       	ldd	r31, Y+4	; 0x04
    3f74:	95 83       	std	Z+5, r25	; 0x05
    3f76:	84 83       	std	Z+4, r24	; 0x04
    3f78:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f7a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f7c:	86 89       	ldd	r24, Z+22	; 0x16
    3f7e:	28 2f       	mov	r18, r24
    3f80:	30 e0       	ldi	r19, 0x00	; 0
    3f82:	c9 01       	movw	r24, r18
    3f84:	88 0f       	add	r24, r24
    3f86:	99 1f       	adc	r25, r25
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	88 0f       	add	r24, r24
    3f8e:	99 1f       	adc	r25, r25
    3f90:	82 0f       	add	r24, r18
    3f92:	93 1f       	adc	r25, r19
    3f94:	80 5b       	subi	r24, 0xB0	; 176
    3f96:	9b 4f       	sbci	r25, 0xFB	; 251
    3f98:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f9a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f9c:	93 87       	std	Z+11, r25	; 0x0b
    3f9e:	82 87       	std	Z+10, r24	; 0x0a
    3fa0:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fa2:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fa4:	86 89       	ldd	r24, Z+22	; 0x16
    3fa6:	28 2f       	mov	r18, r24
    3fa8:	30 e0       	ldi	r19, 0x00	; 0
    3faa:	c9 01       	movw	r24, r18
    3fac:	88 0f       	add	r24, r24
    3fae:	99 1f       	adc	r25, r25
    3fb0:	88 0f       	add	r24, r24
    3fb2:	99 1f       	adc	r25, r25
    3fb4:	88 0f       	add	r24, r24
    3fb6:	99 1f       	adc	r25, r25
    3fb8:	82 0f       	add	r24, r18
    3fba:	93 1f       	adc	r25, r19
    3fbc:	fc 01       	movw	r30, r24
    3fbe:	e0 5b       	subi	r30, 0xB0	; 176
    3fc0:	fb 4f       	sbci	r31, 0xFB	; 251
    3fc2:	80 81       	ld	r24, Z
    3fc4:	8f 5f       	subi	r24, 0xFF	; 255
    3fc6:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fca:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fcc:	96 89       	ldd	r25, Z+22	; 0x16
    3fce:	e0 91 3f 04 	lds	r30, 0x043F
    3fd2:	f0 91 40 04 	lds	r31, 0x0440
    3fd6:	86 89       	ldd	r24, Z+22	; 0x16
    3fd8:	98 17       	cp	r25, r24
    3fda:	18 f0       	brcs	.+6      	; 0x3fe2 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3fdc:	81 e0       	ldi	r24, 0x01	; 1
    3fde:	80 93 48 04 	sts	0x0448, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3fe2:	80 91 8a 04 	lds	r24, 0x048A
    3fe6:	88 23       	and	r24, r24
    3fe8:	09 f0       	breq	.+2      	; 0x3fec <xTaskResumeAll+0x230>
    3fea:	08 cf       	rjmp	.-496    	; 0x3dfc <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3fec:	8a 85       	ldd	r24, Y+10	; 0x0a
    3fee:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ff0:	00 97       	sbiw	r24, 0x00	; 0
    3ff2:	11 f0       	breq	.+4      	; 0x3ff8 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3ff4:	0e 94 80 26 	call	0x4d00	; 0x4d00 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3ff8:	80 91 46 04 	lds	r24, 0x0446
    3ffc:	90 91 47 04 	lds	r25, 0x0447
    4000:	9a 83       	std	Y+2, r25	; 0x02
    4002:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    4004:	89 81       	ldd	r24, Y+1	; 0x01
    4006:	9a 81       	ldd	r25, Y+2	; 0x02
    4008:	00 97       	sbiw	r24, 0x00	; 0
    400a:	a1 f0       	breq	.+40     	; 0x4034 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    400c:	0e 94 ab 20 	call	0x4156	; 0x4156 <xTaskIncrementTick>
    4010:	88 23       	and	r24, r24
    4012:	19 f0       	breq	.+6      	; 0x401a <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    4014:	81 e0       	ldi	r24, 0x01	; 1
    4016:	80 93 48 04 	sts	0x0448, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    401a:	89 81       	ldd	r24, Y+1	; 0x01
    401c:	9a 81       	ldd	r25, Y+2	; 0x02
    401e:	01 97       	sbiw	r24, 0x01	; 1
    4020:	9a 83       	std	Y+2, r25	; 0x02
    4022:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    4024:	89 81       	ldd	r24, Y+1	; 0x01
    4026:	9a 81       	ldd	r25, Y+2	; 0x02
    4028:	00 97       	sbiw	r24, 0x00	; 0
    402a:	81 f7       	brne	.-32     	; 0x400c <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    402c:	10 92 47 04 	sts	0x0447, r1
    4030:	10 92 46 04 	sts	0x0446, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    4034:	80 91 48 04 	lds	r24, 0x0448
    4038:	88 23       	and	r24, r24
    403a:	21 f0       	breq	.+8      	; 0x4044 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    403c:	81 e0       	ldi	r24, 0x01	; 1
    403e:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    4040:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    4044:	0f 90       	pop	r0
    4046:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    4048:	89 85       	ldd	r24, Y+9	; 0x09
}
    404a:	2b 96       	adiw	r28, 0x0b	; 11
    404c:	0f b6       	in	r0, 0x3f	; 63
    404e:	f8 94       	cli
    4050:	de bf       	out	0x3e, r29	; 62
    4052:	0f be       	out	0x3f, r0	; 63
    4054:	cd bf       	out	0x3d, r28	; 61
    4056:	cf 91       	pop	r28
    4058:	df 91       	pop	r29
    405a:	08 95       	ret

0000405c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    405c:	df 93       	push	r29
    405e:	cf 93       	push	r28
    4060:	00 d0       	rcall	.+0      	; 0x4062 <xTaskGetTickCount+0x6>
    4062:	cd b7       	in	r28, 0x3d	; 61
    4064:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4066:	0f b6       	in	r0, 0x3f	; 63
    4068:	f8 94       	cli
    406a:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    406c:	80 91 42 04 	lds	r24, 0x0442
    4070:	90 91 43 04 	lds	r25, 0x0443
    4074:	9a 83       	std	Y+2, r25	; 0x02
    4076:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4078:	0f 90       	pop	r0
    407a:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    407c:	89 81       	ldd	r24, Y+1	; 0x01
    407e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	08 95       	ret

0000408a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	00 d0       	rcall	.+0      	; 0x4090 <xTaskGetTickCountFromISR+0x6>
    4090:	0f 92       	push	r0
    4092:	cd b7       	in	r28, 0x3d	; 61
    4094:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4096:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4098:	80 91 42 04 	lds	r24, 0x0442
    409c:	90 91 43 04 	lds	r25, 0x0443
    40a0:	9b 83       	std	Y+3, r25	; 0x03
    40a2:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    40a4:	8a 81       	ldd	r24, Y+2	; 0x02
    40a6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    40a8:	0f 90       	pop	r0
    40aa:	0f 90       	pop	r0
    40ac:	0f 90       	pop	r0
    40ae:	cf 91       	pop	r28
    40b0:	df 91       	pop	r29
    40b2:	08 95       	ret

000040b4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    40b4:	df 93       	push	r29
    40b6:	cf 93       	push	r28
    40b8:	cd b7       	in	r28, 0x3d	; 61
    40ba:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    40bc:	80 91 41 04 	lds	r24, 0x0441
}
    40c0:	cf 91       	pop	r28
    40c2:	df 91       	pop	r29
    40c4:	08 95       	ret

000040c6 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    40c6:	df 93       	push	r29
    40c8:	cf 93       	push	r28
    40ca:	00 d0       	rcall	.+0      	; 0x40cc <pcTaskGetName+0x6>
    40cc:	00 d0       	rcall	.+0      	; 0x40ce <pcTaskGetName+0x8>
    40ce:	00 d0       	rcall	.+0      	; 0x40d0 <pcTaskGetName+0xa>
    40d0:	cd b7       	in	r28, 0x3d	; 61
    40d2:	de b7       	in	r29, 0x3e	; 62
    40d4:	9c 83       	std	Y+4, r25	; 0x04
    40d6:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    40d8:	8b 81       	ldd	r24, Y+3	; 0x03
    40da:	9c 81       	ldd	r25, Y+4	; 0x04
    40dc:	00 97       	sbiw	r24, 0x00	; 0
    40de:	39 f4       	brne	.+14     	; 0x40ee <pcTaskGetName+0x28>
    40e0:	80 91 3f 04 	lds	r24, 0x043F
    40e4:	90 91 40 04 	lds	r25, 0x0440
    40e8:	9e 83       	std	Y+6, r25	; 0x06
    40ea:	8d 83       	std	Y+5, r24	; 0x05
    40ec:	04 c0       	rjmp	.+8      	; 0x40f6 <pcTaskGetName+0x30>
    40ee:	8b 81       	ldd	r24, Y+3	; 0x03
    40f0:	9c 81       	ldd	r25, Y+4	; 0x04
    40f2:	9e 83       	std	Y+6, r25	; 0x06
    40f4:	8d 83       	std	Y+5, r24	; 0x05
    40f6:	8d 81       	ldd	r24, Y+5	; 0x05
    40f8:	9e 81       	ldd	r25, Y+6	; 0x06
    40fa:	9a 83       	std	Y+2, r25	; 0x02
    40fc:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    40fe:	89 81       	ldd	r24, Y+1	; 0x01
    4100:	9a 81       	ldd	r25, Y+2	; 0x02
    4102:	49 96       	adiw	r24, 0x19	; 25
}
    4104:	26 96       	adiw	r28, 0x06	; 6
    4106:	0f b6       	in	r0, 0x3f	; 63
    4108:	f8 94       	cli
    410a:	de bf       	out	0x3e, r29	; 62
    410c:	0f be       	out	0x3f, r0	; 63
    410e:	cd bf       	out	0x3d, r28	; 61
    4110:	cf 91       	pop	r28
    4112:	df 91       	pop	r29
    4114:	08 95       	ret

00004116 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4116:	df 93       	push	r29
    4118:	cf 93       	push	r28
    411a:	00 d0       	rcall	.+0      	; 0x411c <xTaskCatchUpTicks+0x6>
    411c:	0f 92       	push	r0
    411e:	cd b7       	in	r28, 0x3d	; 61
    4120:	de b7       	in	r29, 0x3e	; 62
    4122:	9b 83       	std	Y+3, r25	; 0x03
    4124:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4126:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    412a:	20 91 46 04 	lds	r18, 0x0446
    412e:	30 91 47 04 	lds	r19, 0x0447
    4132:	8a 81       	ldd	r24, Y+2	; 0x02
    4134:	9b 81       	ldd	r25, Y+3	; 0x03
    4136:	82 0f       	add	r24, r18
    4138:	93 1f       	adc	r25, r19
    413a:	90 93 47 04 	sts	0x0447, r25
    413e:	80 93 46 04 	sts	0x0446, r24
    xYieldOccurred = xTaskResumeAll();
    4142:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskResumeAll>
    4146:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    4148:	89 81       	ldd	r24, Y+1	; 0x01
}
    414a:	0f 90       	pop	r0
    414c:	0f 90       	pop	r0
    414e:	0f 90       	pop	r0
    4150:	cf 91       	pop	r28
    4152:	df 91       	pop	r29
    4154:	08 95       	ret

00004156 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4156:	df 93       	push	r29
    4158:	cf 93       	push	r28
    415a:	cd b7       	in	r28, 0x3d	; 61
    415c:	de b7       	in	r29, 0x3e	; 62
    415e:	2f 97       	sbiw	r28, 0x0f	; 15
    4160:	0f b6       	in	r0, 0x3f	; 63
    4162:	f8 94       	cli
    4164:	de bf       	out	0x3e, r29	; 62
    4166:	0f be       	out	0x3f, r0	; 63
    4168:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    416a:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    416c:	80 91 4f 04 	lds	r24, 0x044F
    4170:	88 23       	and	r24, r24
    4172:	09 f0       	breq	.+2      	; 0x4176 <xTaskIncrementTick+0x20>
    4174:	74 c1       	rjmp	.+744    	; 0x445e <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4176:	80 91 42 04 	lds	r24, 0x0442
    417a:	90 91 43 04 	lds	r25, 0x0443
    417e:	01 96       	adiw	r24, 0x01	; 1
    4180:	9a 87       	std	Y+10, r25	; 0x0a
    4182:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4184:	89 85       	ldd	r24, Y+9	; 0x09
    4186:	9a 85       	ldd	r25, Y+10	; 0x0a
    4188:	90 93 43 04 	sts	0x0443, r25
    418c:	80 93 42 04 	sts	0x0442, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4190:	89 85       	ldd	r24, Y+9	; 0x09
    4192:	9a 85       	ldd	r25, Y+10	; 0x0a
    4194:	00 97       	sbiw	r24, 0x00	; 0
    4196:	d9 f4       	brne	.+54     	; 0x41ce <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4198:	80 91 86 04 	lds	r24, 0x0486
    419c:	90 91 87 04 	lds	r25, 0x0487
    41a0:	98 87       	std	Y+8, r25	; 0x08
    41a2:	8f 83       	std	Y+7, r24	; 0x07
    41a4:	80 91 88 04 	lds	r24, 0x0488
    41a8:	90 91 89 04 	lds	r25, 0x0489
    41ac:	90 93 87 04 	sts	0x0487, r25
    41b0:	80 93 86 04 	sts	0x0486, r24
    41b4:	8f 81       	ldd	r24, Y+7	; 0x07
    41b6:	98 85       	ldd	r25, Y+8	; 0x08
    41b8:	90 93 89 04 	sts	0x0489, r25
    41bc:	80 93 88 04 	sts	0x0488, r24
    41c0:	80 91 49 04 	lds	r24, 0x0449
    41c4:	8f 5f       	subi	r24, 0xFF	; 255
    41c6:	80 93 49 04 	sts	0x0449, r24
    41ca:	0e 94 80 26 	call	0x4d00	; 0x4d00 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    41ce:	20 91 4b 04 	lds	r18, 0x044B
    41d2:	30 91 4c 04 	lds	r19, 0x044C
    41d6:	89 85       	ldd	r24, Y+9	; 0x09
    41d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    41da:	82 17       	cp	r24, r18
    41dc:	93 07       	cpc	r25, r19
    41de:	08 f4       	brcc	.+2      	; 0x41e2 <xTaskIncrementTick+0x8c>
    41e0:	1f c1       	rjmp	.+574    	; 0x4420 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    41e2:	e0 91 86 04 	lds	r30, 0x0486
    41e6:	f0 91 87 04 	lds	r31, 0x0487
    41ea:	80 81       	ld	r24, Z
    41ec:	88 23       	and	r24, r24
    41ee:	39 f4       	brne	.+14     	; 0x41fe <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    41f0:	8f ef       	ldi	r24, 0xFF	; 255
    41f2:	9f ef       	ldi	r25, 0xFF	; 255
    41f4:	90 93 4c 04 	sts	0x044C, r25
    41f8:	80 93 4b 04 	sts	0x044B, r24
    41fc:	11 c1       	rjmp	.+546    	; 0x4420 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    41fe:	e0 91 86 04 	lds	r30, 0x0486
    4202:	f0 91 87 04 	lds	r31, 0x0487
    4206:	05 80       	ldd	r0, Z+5	; 0x05
    4208:	f6 81       	ldd	r31, Z+6	; 0x06
    420a:	e0 2d       	mov	r30, r0
    420c:	86 81       	ldd	r24, Z+6	; 0x06
    420e:	97 81       	ldd	r25, Z+7	; 0x07
    4210:	9f 87       	std	Y+15, r25	; 0x0f
    4212:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4214:	ee 85       	ldd	r30, Y+14	; 0x0e
    4216:	ff 85       	ldd	r31, Y+15	; 0x0f
    4218:	82 81       	ldd	r24, Z+2	; 0x02
    421a:	93 81       	ldd	r25, Z+3	; 0x03
    421c:	9d 87       	std	Y+13, r25	; 0x0d
    421e:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    4220:	29 85       	ldd	r18, Y+9	; 0x09
    4222:	3a 85       	ldd	r19, Y+10	; 0x0a
    4224:	8c 85       	ldd	r24, Y+12	; 0x0c
    4226:	9d 85       	ldd	r25, Y+13	; 0x0d
    4228:	28 17       	cp	r18, r24
    422a:	39 07       	cpc	r19, r25
    422c:	38 f4       	brcc	.+14     	; 0x423c <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    422e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4230:	9d 85       	ldd	r25, Y+13	; 0x0d
    4232:	90 93 4c 04 	sts	0x044C, r25
    4236:	80 93 4b 04 	sts	0x044B, r24
    423a:	f2 c0       	rjmp	.+484    	; 0x4420 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    423c:	ee 85       	ldd	r30, Y+14	; 0x0e
    423e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4240:	82 85       	ldd	r24, Z+10	; 0x0a
    4242:	93 85       	ldd	r25, Z+11	; 0x0b
    4244:	9e 83       	std	Y+6, r25	; 0x06
    4246:	8d 83       	std	Y+5, r24	; 0x05
    4248:	ee 85       	ldd	r30, Y+14	; 0x0e
    424a:	ff 85       	ldd	r31, Y+15	; 0x0f
    424c:	a4 81       	ldd	r26, Z+4	; 0x04
    424e:	b5 81       	ldd	r27, Z+5	; 0x05
    4250:	ee 85       	ldd	r30, Y+14	; 0x0e
    4252:	ff 85       	ldd	r31, Y+15	; 0x0f
    4254:	86 81       	ldd	r24, Z+6	; 0x06
    4256:	97 81       	ldd	r25, Z+7	; 0x07
    4258:	15 96       	adiw	r26, 0x05	; 5
    425a:	9c 93       	st	X, r25
    425c:	8e 93       	st	-X, r24
    425e:	14 97       	sbiw	r26, 0x04	; 4
    4260:	ee 85       	ldd	r30, Y+14	; 0x0e
    4262:	ff 85       	ldd	r31, Y+15	; 0x0f
    4264:	a6 81       	ldd	r26, Z+6	; 0x06
    4266:	b7 81       	ldd	r27, Z+7	; 0x07
    4268:	ee 85       	ldd	r30, Y+14	; 0x0e
    426a:	ff 85       	ldd	r31, Y+15	; 0x0f
    426c:	84 81       	ldd	r24, Z+4	; 0x04
    426e:	95 81       	ldd	r25, Z+5	; 0x05
    4270:	13 96       	adiw	r26, 0x03	; 3
    4272:	9c 93       	st	X, r25
    4274:	8e 93       	st	-X, r24
    4276:	12 97       	sbiw	r26, 0x02	; 2
    4278:	ed 81       	ldd	r30, Y+5	; 0x05
    427a:	fe 81       	ldd	r31, Y+6	; 0x06
    427c:	21 81       	ldd	r18, Z+1	; 0x01
    427e:	32 81       	ldd	r19, Z+2	; 0x02
    4280:	8e 85       	ldd	r24, Y+14	; 0x0e
    4282:	9f 85       	ldd	r25, Y+15	; 0x0f
    4284:	02 96       	adiw	r24, 0x02	; 2
    4286:	28 17       	cp	r18, r24
    4288:	39 07       	cpc	r19, r25
    428a:	41 f4       	brne	.+16     	; 0x429c <xTaskIncrementTick+0x146>
    428c:	ee 85       	ldd	r30, Y+14	; 0x0e
    428e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4290:	86 81       	ldd	r24, Z+6	; 0x06
    4292:	97 81       	ldd	r25, Z+7	; 0x07
    4294:	ed 81       	ldd	r30, Y+5	; 0x05
    4296:	fe 81       	ldd	r31, Y+6	; 0x06
    4298:	92 83       	std	Z+2, r25	; 0x02
    429a:	81 83       	std	Z+1, r24	; 0x01
    429c:	ee 85       	ldd	r30, Y+14	; 0x0e
    429e:	ff 85       	ldd	r31, Y+15	; 0x0f
    42a0:	13 86       	std	Z+11, r1	; 0x0b
    42a2:	12 86       	std	Z+10, r1	; 0x0a
    42a4:	ed 81       	ldd	r30, Y+5	; 0x05
    42a6:	fe 81       	ldd	r31, Y+6	; 0x06
    42a8:	80 81       	ld	r24, Z
    42aa:	81 50       	subi	r24, 0x01	; 1
    42ac:	ed 81       	ldd	r30, Y+5	; 0x05
    42ae:	fe 81       	ldd	r31, Y+6	; 0x06
    42b0:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    42b2:	ee 85       	ldd	r30, Y+14	; 0x0e
    42b4:	ff 85       	ldd	r31, Y+15	; 0x0f
    42b6:	84 89       	ldd	r24, Z+20	; 0x14
    42b8:	95 89       	ldd	r25, Z+21	; 0x15
    42ba:	00 97       	sbiw	r24, 0x00	; 0
    42bc:	d9 f1       	breq	.+118    	; 0x4334 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    42be:	ee 85       	ldd	r30, Y+14	; 0x0e
    42c0:	ff 85       	ldd	r31, Y+15	; 0x0f
    42c2:	84 89       	ldd	r24, Z+20	; 0x14
    42c4:	95 89       	ldd	r25, Z+21	; 0x15
    42c6:	9c 83       	std	Y+4, r25	; 0x04
    42c8:	8b 83       	std	Y+3, r24	; 0x03
    42ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    42cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    42ce:	a6 85       	ldd	r26, Z+14	; 0x0e
    42d0:	b7 85       	ldd	r27, Z+15	; 0x0f
    42d2:	ee 85       	ldd	r30, Y+14	; 0x0e
    42d4:	ff 85       	ldd	r31, Y+15	; 0x0f
    42d6:	80 89       	ldd	r24, Z+16	; 0x10
    42d8:	91 89       	ldd	r25, Z+17	; 0x11
    42da:	15 96       	adiw	r26, 0x05	; 5
    42dc:	9c 93       	st	X, r25
    42de:	8e 93       	st	-X, r24
    42e0:	14 97       	sbiw	r26, 0x04	; 4
    42e2:	ee 85       	ldd	r30, Y+14	; 0x0e
    42e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    42e6:	a0 89       	ldd	r26, Z+16	; 0x10
    42e8:	b1 89       	ldd	r27, Z+17	; 0x11
    42ea:	ee 85       	ldd	r30, Y+14	; 0x0e
    42ec:	ff 85       	ldd	r31, Y+15	; 0x0f
    42ee:	86 85       	ldd	r24, Z+14	; 0x0e
    42f0:	97 85       	ldd	r25, Z+15	; 0x0f
    42f2:	13 96       	adiw	r26, 0x03	; 3
    42f4:	9c 93       	st	X, r25
    42f6:	8e 93       	st	-X, r24
    42f8:	12 97       	sbiw	r26, 0x02	; 2
    42fa:	eb 81       	ldd	r30, Y+3	; 0x03
    42fc:	fc 81       	ldd	r31, Y+4	; 0x04
    42fe:	21 81       	ldd	r18, Z+1	; 0x01
    4300:	32 81       	ldd	r19, Z+2	; 0x02
    4302:	8e 85       	ldd	r24, Y+14	; 0x0e
    4304:	9f 85       	ldd	r25, Y+15	; 0x0f
    4306:	0c 96       	adiw	r24, 0x0c	; 12
    4308:	28 17       	cp	r18, r24
    430a:	39 07       	cpc	r19, r25
    430c:	41 f4       	brne	.+16     	; 0x431e <xTaskIncrementTick+0x1c8>
    430e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4310:	ff 85       	ldd	r31, Y+15	; 0x0f
    4312:	80 89       	ldd	r24, Z+16	; 0x10
    4314:	91 89       	ldd	r25, Z+17	; 0x11
    4316:	eb 81       	ldd	r30, Y+3	; 0x03
    4318:	fc 81       	ldd	r31, Y+4	; 0x04
    431a:	92 83       	std	Z+2, r25	; 0x02
    431c:	81 83       	std	Z+1, r24	; 0x01
    431e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4320:	ff 85       	ldd	r31, Y+15	; 0x0f
    4322:	15 8a       	std	Z+21, r1	; 0x15
    4324:	14 8a       	std	Z+20, r1	; 0x14
    4326:	eb 81       	ldd	r30, Y+3	; 0x03
    4328:	fc 81       	ldd	r31, Y+4	; 0x04
    432a:	80 81       	ld	r24, Z
    432c:	81 50       	subi	r24, 0x01	; 1
    432e:	eb 81       	ldd	r30, Y+3	; 0x03
    4330:	fc 81       	ldd	r31, Y+4	; 0x04
    4332:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    4334:	ee 85       	ldd	r30, Y+14	; 0x0e
    4336:	ff 85       	ldd	r31, Y+15	; 0x0f
    4338:	96 89       	ldd	r25, Z+22	; 0x16
    433a:	80 91 44 04 	lds	r24, 0x0444
    433e:	89 17       	cp	r24, r25
    4340:	28 f4       	brcc	.+10     	; 0x434c <xTaskIncrementTick+0x1f6>
    4342:	ee 85       	ldd	r30, Y+14	; 0x0e
    4344:	ff 85       	ldd	r31, Y+15	; 0x0f
    4346:	86 89       	ldd	r24, Z+22	; 0x16
    4348:	80 93 44 04 	sts	0x0444, r24
    434c:	ee 85       	ldd	r30, Y+14	; 0x0e
    434e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4350:	86 89       	ldd	r24, Z+22	; 0x16
    4352:	28 2f       	mov	r18, r24
    4354:	30 e0       	ldi	r19, 0x00	; 0
    4356:	c9 01       	movw	r24, r18
    4358:	88 0f       	add	r24, r24
    435a:	99 1f       	adc	r25, r25
    435c:	88 0f       	add	r24, r24
    435e:	99 1f       	adc	r25, r25
    4360:	88 0f       	add	r24, r24
    4362:	99 1f       	adc	r25, r25
    4364:	82 0f       	add	r24, r18
    4366:	93 1f       	adc	r25, r19
    4368:	fc 01       	movw	r30, r24
    436a:	e0 5b       	subi	r30, 0xB0	; 176
    436c:	fb 4f       	sbci	r31, 0xFB	; 251
    436e:	81 81       	ldd	r24, Z+1	; 0x01
    4370:	92 81       	ldd	r25, Z+2	; 0x02
    4372:	9a 83       	std	Y+2, r25	; 0x02
    4374:	89 83       	std	Y+1, r24	; 0x01
    4376:	ee 85       	ldd	r30, Y+14	; 0x0e
    4378:	ff 85       	ldd	r31, Y+15	; 0x0f
    437a:	89 81       	ldd	r24, Y+1	; 0x01
    437c:	9a 81       	ldd	r25, Y+2	; 0x02
    437e:	95 83       	std	Z+5, r25	; 0x05
    4380:	84 83       	std	Z+4, r24	; 0x04
    4382:	e9 81       	ldd	r30, Y+1	; 0x01
    4384:	fa 81       	ldd	r31, Y+2	; 0x02
    4386:	84 81       	ldd	r24, Z+4	; 0x04
    4388:	95 81       	ldd	r25, Z+5	; 0x05
    438a:	ee 85       	ldd	r30, Y+14	; 0x0e
    438c:	ff 85       	ldd	r31, Y+15	; 0x0f
    438e:	97 83       	std	Z+7, r25	; 0x07
    4390:	86 83       	std	Z+6, r24	; 0x06
    4392:	e9 81       	ldd	r30, Y+1	; 0x01
    4394:	fa 81       	ldd	r31, Y+2	; 0x02
    4396:	04 80       	ldd	r0, Z+4	; 0x04
    4398:	f5 81       	ldd	r31, Z+5	; 0x05
    439a:	e0 2d       	mov	r30, r0
    439c:	8e 85       	ldd	r24, Y+14	; 0x0e
    439e:	9f 85       	ldd	r25, Y+15	; 0x0f
    43a0:	02 96       	adiw	r24, 0x02	; 2
    43a2:	93 83       	std	Z+3, r25	; 0x03
    43a4:	82 83       	std	Z+2, r24	; 0x02
    43a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    43a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    43aa:	02 96       	adiw	r24, 0x02	; 2
    43ac:	e9 81       	ldd	r30, Y+1	; 0x01
    43ae:	fa 81       	ldd	r31, Y+2	; 0x02
    43b0:	95 83       	std	Z+5, r25	; 0x05
    43b2:	84 83       	std	Z+4, r24	; 0x04
    43b4:	ee 85       	ldd	r30, Y+14	; 0x0e
    43b6:	ff 85       	ldd	r31, Y+15	; 0x0f
    43b8:	86 89       	ldd	r24, Z+22	; 0x16
    43ba:	28 2f       	mov	r18, r24
    43bc:	30 e0       	ldi	r19, 0x00	; 0
    43be:	c9 01       	movw	r24, r18
    43c0:	88 0f       	add	r24, r24
    43c2:	99 1f       	adc	r25, r25
    43c4:	88 0f       	add	r24, r24
    43c6:	99 1f       	adc	r25, r25
    43c8:	88 0f       	add	r24, r24
    43ca:	99 1f       	adc	r25, r25
    43cc:	82 0f       	add	r24, r18
    43ce:	93 1f       	adc	r25, r19
    43d0:	80 5b       	subi	r24, 0xB0	; 176
    43d2:	9b 4f       	sbci	r25, 0xFB	; 251
    43d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    43d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    43d8:	93 87       	std	Z+11, r25	; 0x0b
    43da:	82 87       	std	Z+10, r24	; 0x0a
    43dc:	ee 85       	ldd	r30, Y+14	; 0x0e
    43de:	ff 85       	ldd	r31, Y+15	; 0x0f
    43e0:	86 89       	ldd	r24, Z+22	; 0x16
    43e2:	28 2f       	mov	r18, r24
    43e4:	30 e0       	ldi	r19, 0x00	; 0
    43e6:	c9 01       	movw	r24, r18
    43e8:	88 0f       	add	r24, r24
    43ea:	99 1f       	adc	r25, r25
    43ec:	88 0f       	add	r24, r24
    43ee:	99 1f       	adc	r25, r25
    43f0:	88 0f       	add	r24, r24
    43f2:	99 1f       	adc	r25, r25
    43f4:	82 0f       	add	r24, r18
    43f6:	93 1f       	adc	r25, r19
    43f8:	fc 01       	movw	r30, r24
    43fa:	e0 5b       	subi	r30, 0xB0	; 176
    43fc:	fb 4f       	sbci	r31, 0xFB	; 251
    43fe:	80 81       	ld	r24, Z
    4400:	8f 5f       	subi	r24, 0xFF	; 255
    4402:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4404:	ee 85       	ldd	r30, Y+14	; 0x0e
    4406:	ff 85       	ldd	r31, Y+15	; 0x0f
    4408:	96 89       	ldd	r25, Z+22	; 0x16
    440a:	e0 91 3f 04 	lds	r30, 0x043F
    440e:	f0 91 40 04 	lds	r31, 0x0440
    4412:	86 89       	ldd	r24, Z+22	; 0x16
    4414:	98 17       	cp	r25, r24
    4416:	08 f4       	brcc	.+2      	; 0x441a <xTaskIncrementTick+0x2c4>
    4418:	e4 ce       	rjmp	.-568    	; 0x41e2 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    441a:	81 e0       	ldi	r24, 0x01	; 1
    441c:	8b 87       	std	Y+11, r24	; 0x0b
    441e:	e1 ce       	rjmp	.-574    	; 0x41e2 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4420:	e0 91 3f 04 	lds	r30, 0x043F
    4424:	f0 91 40 04 	lds	r31, 0x0440
    4428:	86 89       	ldd	r24, Z+22	; 0x16
    442a:	28 2f       	mov	r18, r24
    442c:	30 e0       	ldi	r19, 0x00	; 0
    442e:	c9 01       	movw	r24, r18
    4430:	88 0f       	add	r24, r24
    4432:	99 1f       	adc	r25, r25
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	88 0f       	add	r24, r24
    443a:	99 1f       	adc	r25, r25
    443c:	82 0f       	add	r24, r18
    443e:	93 1f       	adc	r25, r19
    4440:	fc 01       	movw	r30, r24
    4442:	e0 5b       	subi	r30, 0xB0	; 176
    4444:	fb 4f       	sbci	r31, 0xFB	; 251
    4446:	80 81       	ld	r24, Z
    4448:	82 30       	cpi	r24, 0x02	; 2
    444a:	10 f0       	brcs	.+4      	; 0x4450 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    444c:	81 e0       	ldi	r24, 0x01	; 1
    444e:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    4450:	80 91 48 04 	lds	r24, 0x0448
    4454:	88 23       	and	r24, r24
    4456:	61 f0       	breq	.+24     	; 0x4470 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    4458:	81 e0       	ldi	r24, 0x01	; 1
    445a:	8b 87       	std	Y+11, r24	; 0x0b
    445c:	09 c0       	rjmp	.+18     	; 0x4470 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    445e:	80 91 46 04 	lds	r24, 0x0446
    4462:	90 91 47 04 	lds	r25, 0x0447
    4466:	01 96       	adiw	r24, 0x01	; 1
    4468:	90 93 47 04 	sts	0x0447, r25
    446c:	80 93 46 04 	sts	0x0446, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    4470:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    4472:	2f 96       	adiw	r28, 0x0f	; 15
    4474:	0f b6       	in	r0, 0x3f	; 63
    4476:	f8 94       	cli
    4478:	de bf       	out	0x3e, r29	; 62
    447a:	0f be       	out	0x3f, r0	; 63
    447c:	cd bf       	out	0x3d, r28	; 61
    447e:	cf 91       	pop	r28
    4480:	df 91       	pop	r29
    4482:	08 95       	ret

00004484 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4484:	df 93       	push	r29
    4486:	cf 93       	push	r28
    4488:	00 d0       	rcall	.+0      	; 0x448a <vTaskSwitchContext+0x6>
    448a:	0f 92       	push	r0
    448c:	cd b7       	in	r28, 0x3d	; 61
    448e:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4490:	80 91 4f 04 	lds	r24, 0x044F
    4494:	88 23       	and	r24, r24
    4496:	21 f0       	breq	.+8      	; 0x44a0 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4498:	81 e0       	ldi	r24, 0x01	; 1
    449a:	80 93 48 04 	sts	0x0448, r24
    449e:	59 c0       	rjmp	.+178    	; 0x4552 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    44a0:	10 92 48 04 	sts	0x0448, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44a4:	80 91 44 04 	lds	r24, 0x0444
    44a8:	8b 83       	std	Y+3, r24	; 0x03
    44aa:	03 c0       	rjmp	.+6      	; 0x44b2 <vTaskSwitchContext+0x2e>
    44ac:	8b 81       	ldd	r24, Y+3	; 0x03
    44ae:	81 50       	subi	r24, 0x01	; 1
    44b0:	8b 83       	std	Y+3, r24	; 0x03
    44b2:	8b 81       	ldd	r24, Y+3	; 0x03
    44b4:	28 2f       	mov	r18, r24
    44b6:	30 e0       	ldi	r19, 0x00	; 0
    44b8:	c9 01       	movw	r24, r18
    44ba:	88 0f       	add	r24, r24
    44bc:	99 1f       	adc	r25, r25
    44be:	88 0f       	add	r24, r24
    44c0:	99 1f       	adc	r25, r25
    44c2:	88 0f       	add	r24, r24
    44c4:	99 1f       	adc	r25, r25
    44c6:	82 0f       	add	r24, r18
    44c8:	93 1f       	adc	r25, r19
    44ca:	fc 01       	movw	r30, r24
    44cc:	e0 5b       	subi	r30, 0xB0	; 176
    44ce:	fb 4f       	sbci	r31, 0xFB	; 251
    44d0:	80 81       	ld	r24, Z
    44d2:	88 23       	and	r24, r24
    44d4:	59 f3       	breq	.-42     	; 0x44ac <vTaskSwitchContext+0x28>
    44d6:	8b 81       	ldd	r24, Y+3	; 0x03
    44d8:	28 2f       	mov	r18, r24
    44da:	30 e0       	ldi	r19, 0x00	; 0
    44dc:	c9 01       	movw	r24, r18
    44de:	88 0f       	add	r24, r24
    44e0:	99 1f       	adc	r25, r25
    44e2:	88 0f       	add	r24, r24
    44e4:	99 1f       	adc	r25, r25
    44e6:	88 0f       	add	r24, r24
    44e8:	99 1f       	adc	r25, r25
    44ea:	82 0f       	add	r24, r18
    44ec:	93 1f       	adc	r25, r19
    44ee:	80 5b       	subi	r24, 0xB0	; 176
    44f0:	9b 4f       	sbci	r25, 0xFB	; 251
    44f2:	9a 83       	std	Y+2, r25	; 0x02
    44f4:	89 83       	std	Y+1, r24	; 0x01
    44f6:	e9 81       	ldd	r30, Y+1	; 0x01
    44f8:	fa 81       	ldd	r31, Y+2	; 0x02
    44fa:	01 80       	ldd	r0, Z+1	; 0x01
    44fc:	f2 81       	ldd	r31, Z+2	; 0x02
    44fe:	e0 2d       	mov	r30, r0
    4500:	82 81       	ldd	r24, Z+2	; 0x02
    4502:	93 81       	ldd	r25, Z+3	; 0x03
    4504:	e9 81       	ldd	r30, Y+1	; 0x01
    4506:	fa 81       	ldd	r31, Y+2	; 0x02
    4508:	92 83       	std	Z+2, r25	; 0x02
    450a:	81 83       	std	Z+1, r24	; 0x01
    450c:	e9 81       	ldd	r30, Y+1	; 0x01
    450e:	fa 81       	ldd	r31, Y+2	; 0x02
    4510:	21 81       	ldd	r18, Z+1	; 0x01
    4512:	32 81       	ldd	r19, Z+2	; 0x02
    4514:	89 81       	ldd	r24, Y+1	; 0x01
    4516:	9a 81       	ldd	r25, Y+2	; 0x02
    4518:	03 96       	adiw	r24, 0x03	; 3
    451a:	28 17       	cp	r18, r24
    451c:	39 07       	cpc	r19, r25
    451e:	59 f4       	brne	.+22     	; 0x4536 <vTaskSwitchContext+0xb2>
    4520:	e9 81       	ldd	r30, Y+1	; 0x01
    4522:	fa 81       	ldd	r31, Y+2	; 0x02
    4524:	01 80       	ldd	r0, Z+1	; 0x01
    4526:	f2 81       	ldd	r31, Z+2	; 0x02
    4528:	e0 2d       	mov	r30, r0
    452a:	82 81       	ldd	r24, Z+2	; 0x02
    452c:	93 81       	ldd	r25, Z+3	; 0x03
    452e:	e9 81       	ldd	r30, Y+1	; 0x01
    4530:	fa 81       	ldd	r31, Y+2	; 0x02
    4532:	92 83       	std	Z+2, r25	; 0x02
    4534:	81 83       	std	Z+1, r24	; 0x01
    4536:	e9 81       	ldd	r30, Y+1	; 0x01
    4538:	fa 81       	ldd	r31, Y+2	; 0x02
    453a:	01 80       	ldd	r0, Z+1	; 0x01
    453c:	f2 81       	ldd	r31, Z+2	; 0x02
    453e:	e0 2d       	mov	r30, r0
    4540:	86 81       	ldd	r24, Z+6	; 0x06
    4542:	97 81       	ldd	r25, Z+7	; 0x07
    4544:	90 93 40 04 	sts	0x0440, r25
    4548:	80 93 3f 04 	sts	0x043F, r24
    454c:	8b 81       	ldd	r24, Y+3	; 0x03
    454e:	80 93 44 04 	sts	0x0444, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    4552:	0f 90       	pop	r0
    4554:	0f 90       	pop	r0
    4556:	0f 90       	pop	r0
    4558:	cf 91       	pop	r28
    455a:	df 91       	pop	r29
    455c:	08 95       	ret

0000455e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    455e:	df 93       	push	r29
    4560:	cf 93       	push	r28
    4562:	00 d0       	rcall	.+0      	; 0x4564 <vTaskPlaceOnEventList+0x6>
    4564:	00 d0       	rcall	.+0      	; 0x4566 <vTaskPlaceOnEventList+0x8>
    4566:	cd b7       	in	r28, 0x3d	; 61
    4568:	de b7       	in	r29, 0x3e	; 62
    456a:	9a 83       	std	Y+2, r25	; 0x02
    456c:	89 83       	std	Y+1, r24	; 0x01
    456e:	7c 83       	std	Y+4, r23	; 0x04
    4570:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4572:	80 91 3f 04 	lds	r24, 0x043F
    4576:	90 91 40 04 	lds	r25, 0x0440
    457a:	9c 01       	movw	r18, r24
    457c:	24 5f       	subi	r18, 0xF4	; 244
    457e:	3f 4f       	sbci	r19, 0xFF	; 255
    4580:	89 81       	ldd	r24, Y+1	; 0x01
    4582:	9a 81       	ldd	r25, Y+2	; 0x02
    4584:	b9 01       	movw	r22, r18
    4586:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    458a:	8b 81       	ldd	r24, Y+3	; 0x03
    458c:	9c 81       	ldd	r25, Y+4	; 0x04
    458e:	61 e0       	ldi	r22, 0x01	; 1
    4590:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvAddCurrentTaskToDelayedList>
}
    4594:	0f 90       	pop	r0
    4596:	0f 90       	pop	r0
    4598:	0f 90       	pop	r0
    459a:	0f 90       	pop	r0
    459c:	cf 91       	pop	r28
    459e:	df 91       	pop	r29
    45a0:	08 95       	ret

000045a2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    45a2:	df 93       	push	r29
    45a4:	cf 93       	push	r28
    45a6:	cd b7       	in	r28, 0x3d	; 61
    45a8:	de b7       	in	r29, 0x3e	; 62
    45aa:	28 97       	sbiw	r28, 0x08	; 8
    45ac:	0f b6       	in	r0, 0x3f	; 63
    45ae:	f8 94       	cli
    45b0:	de bf       	out	0x3e, r29	; 62
    45b2:	0f be       	out	0x3f, r0	; 63
    45b4:	cd bf       	out	0x3d, r28	; 61
    45b6:	9c 83       	std	Y+4, r25	; 0x04
    45b8:	8b 83       	std	Y+3, r24	; 0x03
    45ba:	7e 83       	std	Y+6, r23	; 0x06
    45bc:	6d 83       	std	Y+5, r22	; 0x05
    45be:	58 87       	std	Y+8, r21	; 0x08
    45c0:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    45c2:	e0 91 3f 04 	lds	r30, 0x043F
    45c6:	f0 91 40 04 	lds	r31, 0x0440
    45ca:	8d 81       	ldd	r24, Y+5	; 0x05
    45cc:	9e 81       	ldd	r25, Y+6	; 0x06
    45ce:	90 68       	ori	r25, 0x80	; 128
    45d0:	95 87       	std	Z+13, r25	; 0x0d
    45d2:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45d4:	eb 81       	ldd	r30, Y+3	; 0x03
    45d6:	fc 81       	ldd	r31, Y+4	; 0x04
    45d8:	81 81       	ldd	r24, Z+1	; 0x01
    45da:	92 81       	ldd	r25, Z+2	; 0x02
    45dc:	9a 83       	std	Y+2, r25	; 0x02
    45de:	89 83       	std	Y+1, r24	; 0x01
    45e0:	e0 91 3f 04 	lds	r30, 0x043F
    45e4:	f0 91 40 04 	lds	r31, 0x0440
    45e8:	89 81       	ldd	r24, Y+1	; 0x01
    45ea:	9a 81       	ldd	r25, Y+2	; 0x02
    45ec:	97 87       	std	Z+15, r25	; 0x0f
    45ee:	86 87       	std	Z+14, r24	; 0x0e
    45f0:	a0 91 3f 04 	lds	r26, 0x043F
    45f4:	b0 91 40 04 	lds	r27, 0x0440
    45f8:	e9 81       	ldd	r30, Y+1	; 0x01
    45fa:	fa 81       	ldd	r31, Y+2	; 0x02
    45fc:	84 81       	ldd	r24, Z+4	; 0x04
    45fe:	95 81       	ldd	r25, Z+5	; 0x05
    4600:	51 96       	adiw	r26, 0x11	; 17
    4602:	9c 93       	st	X, r25
    4604:	8e 93       	st	-X, r24
    4606:	50 97       	sbiw	r26, 0x10	; 16
    4608:	e9 81       	ldd	r30, Y+1	; 0x01
    460a:	fa 81       	ldd	r31, Y+2	; 0x02
    460c:	04 80       	ldd	r0, Z+4	; 0x04
    460e:	f5 81       	ldd	r31, Z+5	; 0x05
    4610:	e0 2d       	mov	r30, r0
    4612:	80 91 3f 04 	lds	r24, 0x043F
    4616:	90 91 40 04 	lds	r25, 0x0440
    461a:	0c 96       	adiw	r24, 0x0c	; 12
    461c:	93 83       	std	Z+3, r25	; 0x03
    461e:	82 83       	std	Z+2, r24	; 0x02
    4620:	80 91 3f 04 	lds	r24, 0x043F
    4624:	90 91 40 04 	lds	r25, 0x0440
    4628:	0c 96       	adiw	r24, 0x0c	; 12
    462a:	e9 81       	ldd	r30, Y+1	; 0x01
    462c:	fa 81       	ldd	r31, Y+2	; 0x02
    462e:	95 83       	std	Z+5, r25	; 0x05
    4630:	84 83       	std	Z+4, r24	; 0x04
    4632:	e0 91 3f 04 	lds	r30, 0x043F
    4636:	f0 91 40 04 	lds	r31, 0x0440
    463a:	8b 81       	ldd	r24, Y+3	; 0x03
    463c:	9c 81       	ldd	r25, Y+4	; 0x04
    463e:	95 8b       	std	Z+21, r25	; 0x15
    4640:	84 8b       	std	Z+20, r24	; 0x14
    4642:	eb 81       	ldd	r30, Y+3	; 0x03
    4644:	fc 81       	ldd	r31, Y+4	; 0x04
    4646:	80 81       	ld	r24, Z
    4648:	8f 5f       	subi	r24, 0xFF	; 255
    464a:	eb 81       	ldd	r30, Y+3	; 0x03
    464c:	fc 81       	ldd	r31, Y+4	; 0x04
    464e:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4650:	8f 81       	ldd	r24, Y+7	; 0x07
    4652:	98 85       	ldd	r25, Y+8	; 0x08
    4654:	61 e0       	ldi	r22, 0x01	; 1
    4656:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvAddCurrentTaskToDelayedList>
}
    465a:	28 96       	adiw	r28, 0x08	; 8
    465c:	0f b6       	in	r0, 0x3f	; 63
    465e:	f8 94       	cli
    4660:	de bf       	out	0x3e, r29	; 62
    4662:	0f be       	out	0x3f, r0	; 63
    4664:	cd bf       	out	0x3d, r28	; 61
    4666:	cf 91       	pop	r28
    4668:	df 91       	pop	r29
    466a:	08 95       	ret

0000466c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    466c:	df 93       	push	r29
    466e:	cf 93       	push	r28
    4670:	cd b7       	in	r28, 0x3d	; 61
    4672:	de b7       	in	r29, 0x3e	; 62
    4674:	2d 97       	sbiw	r28, 0x0d	; 13
    4676:	0f b6       	in	r0, 0x3f	; 63
    4678:	f8 94       	cli
    467a:	de bf       	out	0x3e, r29	; 62
    467c:	0f be       	out	0x3f, r0	; 63
    467e:	cd bf       	out	0x3d, r28	; 61
    4680:	9d 87       	std	Y+13, r25	; 0x0d
    4682:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4684:	ec 85       	ldd	r30, Y+12	; 0x0c
    4686:	fd 85       	ldd	r31, Y+13	; 0x0d
    4688:	05 80       	ldd	r0, Z+5	; 0x05
    468a:	f6 81       	ldd	r31, Z+6	; 0x06
    468c:	e0 2d       	mov	r30, r0
    468e:	86 81       	ldd	r24, Z+6	; 0x06
    4690:	97 81       	ldd	r25, Z+7	; 0x07
    4692:	9b 87       	std	Y+11, r25	; 0x0b
    4694:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4696:	ea 85       	ldd	r30, Y+10	; 0x0a
    4698:	fb 85       	ldd	r31, Y+11	; 0x0b
    469a:	84 89       	ldd	r24, Z+20	; 0x14
    469c:	95 89       	ldd	r25, Z+21	; 0x15
    469e:	98 87       	std	Y+8, r25	; 0x08
    46a0:	8f 83       	std	Y+7, r24	; 0x07
    46a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46a6:	a6 85       	ldd	r26, Z+14	; 0x0e
    46a8:	b7 85       	ldd	r27, Z+15	; 0x0f
    46aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    46ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ae:	80 89       	ldd	r24, Z+16	; 0x10
    46b0:	91 89       	ldd	r25, Z+17	; 0x11
    46b2:	15 96       	adiw	r26, 0x05	; 5
    46b4:	9c 93       	st	X, r25
    46b6:	8e 93       	st	-X, r24
    46b8:	14 97       	sbiw	r26, 0x04	; 4
    46ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    46bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    46be:	a0 89       	ldd	r26, Z+16	; 0x10
    46c0:	b1 89       	ldd	r27, Z+17	; 0x11
    46c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46c6:	86 85       	ldd	r24, Z+14	; 0x0e
    46c8:	97 85       	ldd	r25, Z+15	; 0x0f
    46ca:	13 96       	adiw	r26, 0x03	; 3
    46cc:	9c 93       	st	X, r25
    46ce:	8e 93       	st	-X, r24
    46d0:	12 97       	sbiw	r26, 0x02	; 2
    46d2:	ef 81       	ldd	r30, Y+7	; 0x07
    46d4:	f8 85       	ldd	r31, Y+8	; 0x08
    46d6:	21 81       	ldd	r18, Z+1	; 0x01
    46d8:	32 81       	ldd	r19, Z+2	; 0x02
    46da:	8a 85       	ldd	r24, Y+10	; 0x0a
    46dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    46de:	0c 96       	adiw	r24, 0x0c	; 12
    46e0:	28 17       	cp	r18, r24
    46e2:	39 07       	cpc	r19, r25
    46e4:	41 f4       	brne	.+16     	; 0x46f6 <xTaskRemoveFromEventList+0x8a>
    46e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ea:	80 89       	ldd	r24, Z+16	; 0x10
    46ec:	91 89       	ldd	r25, Z+17	; 0x11
    46ee:	ef 81       	ldd	r30, Y+7	; 0x07
    46f0:	f8 85       	ldd	r31, Y+8	; 0x08
    46f2:	92 83       	std	Z+2, r25	; 0x02
    46f4:	81 83       	std	Z+1, r24	; 0x01
    46f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46fa:	15 8a       	std	Z+21, r1	; 0x15
    46fc:	14 8a       	std	Z+20, r1	; 0x14
    46fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4700:	f8 85       	ldd	r31, Y+8	; 0x08
    4702:	80 81       	ld	r24, Z
    4704:	81 50       	subi	r24, 0x01	; 1
    4706:	ef 81       	ldd	r30, Y+7	; 0x07
    4708:	f8 85       	ldd	r31, Y+8	; 0x08
    470a:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    470c:	80 91 4f 04 	lds	r24, 0x044F
    4710:	88 23       	and	r24, r24
    4712:	09 f0       	breq	.+2      	; 0x4716 <xTaskRemoveFromEventList+0xaa>
    4714:	a4 c0       	rjmp	.+328    	; 0x485e <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4716:	ea 85       	ldd	r30, Y+10	; 0x0a
    4718:	fb 85       	ldd	r31, Y+11	; 0x0b
    471a:	82 85       	ldd	r24, Z+10	; 0x0a
    471c:	93 85       	ldd	r25, Z+11	; 0x0b
    471e:	9e 83       	std	Y+6, r25	; 0x06
    4720:	8d 83       	std	Y+5, r24	; 0x05
    4722:	ea 85       	ldd	r30, Y+10	; 0x0a
    4724:	fb 85       	ldd	r31, Y+11	; 0x0b
    4726:	a4 81       	ldd	r26, Z+4	; 0x04
    4728:	b5 81       	ldd	r27, Z+5	; 0x05
    472a:	ea 85       	ldd	r30, Y+10	; 0x0a
    472c:	fb 85       	ldd	r31, Y+11	; 0x0b
    472e:	86 81       	ldd	r24, Z+6	; 0x06
    4730:	97 81       	ldd	r25, Z+7	; 0x07
    4732:	15 96       	adiw	r26, 0x05	; 5
    4734:	9c 93       	st	X, r25
    4736:	8e 93       	st	-X, r24
    4738:	14 97       	sbiw	r26, 0x04	; 4
    473a:	ea 85       	ldd	r30, Y+10	; 0x0a
    473c:	fb 85       	ldd	r31, Y+11	; 0x0b
    473e:	a6 81       	ldd	r26, Z+6	; 0x06
    4740:	b7 81       	ldd	r27, Z+7	; 0x07
    4742:	ea 85       	ldd	r30, Y+10	; 0x0a
    4744:	fb 85       	ldd	r31, Y+11	; 0x0b
    4746:	84 81       	ldd	r24, Z+4	; 0x04
    4748:	95 81       	ldd	r25, Z+5	; 0x05
    474a:	13 96       	adiw	r26, 0x03	; 3
    474c:	9c 93       	st	X, r25
    474e:	8e 93       	st	-X, r24
    4750:	12 97       	sbiw	r26, 0x02	; 2
    4752:	ed 81       	ldd	r30, Y+5	; 0x05
    4754:	fe 81       	ldd	r31, Y+6	; 0x06
    4756:	21 81       	ldd	r18, Z+1	; 0x01
    4758:	32 81       	ldd	r19, Z+2	; 0x02
    475a:	8a 85       	ldd	r24, Y+10	; 0x0a
    475c:	9b 85       	ldd	r25, Y+11	; 0x0b
    475e:	02 96       	adiw	r24, 0x02	; 2
    4760:	28 17       	cp	r18, r24
    4762:	39 07       	cpc	r19, r25
    4764:	41 f4       	brne	.+16     	; 0x4776 <xTaskRemoveFromEventList+0x10a>
    4766:	ea 85       	ldd	r30, Y+10	; 0x0a
    4768:	fb 85       	ldd	r31, Y+11	; 0x0b
    476a:	86 81       	ldd	r24, Z+6	; 0x06
    476c:	97 81       	ldd	r25, Z+7	; 0x07
    476e:	ed 81       	ldd	r30, Y+5	; 0x05
    4770:	fe 81       	ldd	r31, Y+6	; 0x06
    4772:	92 83       	std	Z+2, r25	; 0x02
    4774:	81 83       	std	Z+1, r24	; 0x01
    4776:	ea 85       	ldd	r30, Y+10	; 0x0a
    4778:	fb 85       	ldd	r31, Y+11	; 0x0b
    477a:	13 86       	std	Z+11, r1	; 0x0b
    477c:	12 86       	std	Z+10, r1	; 0x0a
    477e:	ed 81       	ldd	r30, Y+5	; 0x05
    4780:	fe 81       	ldd	r31, Y+6	; 0x06
    4782:	80 81       	ld	r24, Z
    4784:	81 50       	subi	r24, 0x01	; 1
    4786:	ed 81       	ldd	r30, Y+5	; 0x05
    4788:	fe 81       	ldd	r31, Y+6	; 0x06
    478a:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    478c:	ea 85       	ldd	r30, Y+10	; 0x0a
    478e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4790:	96 89       	ldd	r25, Z+22	; 0x16
    4792:	80 91 44 04 	lds	r24, 0x0444
    4796:	89 17       	cp	r24, r25
    4798:	28 f4       	brcc	.+10     	; 0x47a4 <xTaskRemoveFromEventList+0x138>
    479a:	ea 85       	ldd	r30, Y+10	; 0x0a
    479c:	fb 85       	ldd	r31, Y+11	; 0x0b
    479e:	86 89       	ldd	r24, Z+22	; 0x16
    47a0:	80 93 44 04 	sts	0x0444, r24
    47a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    47a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    47a8:	86 89       	ldd	r24, Z+22	; 0x16
    47aa:	28 2f       	mov	r18, r24
    47ac:	30 e0       	ldi	r19, 0x00	; 0
    47ae:	c9 01       	movw	r24, r18
    47b0:	88 0f       	add	r24, r24
    47b2:	99 1f       	adc	r25, r25
    47b4:	88 0f       	add	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	88 0f       	add	r24, r24
    47ba:	99 1f       	adc	r25, r25
    47bc:	82 0f       	add	r24, r18
    47be:	93 1f       	adc	r25, r19
    47c0:	fc 01       	movw	r30, r24
    47c2:	e0 5b       	subi	r30, 0xB0	; 176
    47c4:	fb 4f       	sbci	r31, 0xFB	; 251
    47c6:	81 81       	ldd	r24, Z+1	; 0x01
    47c8:	92 81       	ldd	r25, Z+2	; 0x02
    47ca:	9c 83       	std	Y+4, r25	; 0x04
    47cc:	8b 83       	std	Y+3, r24	; 0x03
    47ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    47d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    47d2:	8b 81       	ldd	r24, Y+3	; 0x03
    47d4:	9c 81       	ldd	r25, Y+4	; 0x04
    47d6:	95 83       	std	Z+5, r25	; 0x05
    47d8:	84 83       	std	Z+4, r24	; 0x04
    47da:	eb 81       	ldd	r30, Y+3	; 0x03
    47dc:	fc 81       	ldd	r31, Y+4	; 0x04
    47de:	84 81       	ldd	r24, Z+4	; 0x04
    47e0:	95 81       	ldd	r25, Z+5	; 0x05
    47e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    47e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    47e6:	97 83       	std	Z+7, r25	; 0x07
    47e8:	86 83       	std	Z+6, r24	; 0x06
    47ea:	eb 81       	ldd	r30, Y+3	; 0x03
    47ec:	fc 81       	ldd	r31, Y+4	; 0x04
    47ee:	04 80       	ldd	r0, Z+4	; 0x04
    47f0:	f5 81       	ldd	r31, Z+5	; 0x05
    47f2:	e0 2d       	mov	r30, r0
    47f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    47f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    47f8:	02 96       	adiw	r24, 0x02	; 2
    47fa:	93 83       	std	Z+3, r25	; 0x03
    47fc:	82 83       	std	Z+2, r24	; 0x02
    47fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    4800:	9b 85       	ldd	r25, Y+11	; 0x0b
    4802:	02 96       	adiw	r24, 0x02	; 2
    4804:	eb 81       	ldd	r30, Y+3	; 0x03
    4806:	fc 81       	ldd	r31, Y+4	; 0x04
    4808:	95 83       	std	Z+5, r25	; 0x05
    480a:	84 83       	std	Z+4, r24	; 0x04
    480c:	ea 85       	ldd	r30, Y+10	; 0x0a
    480e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4810:	86 89       	ldd	r24, Z+22	; 0x16
    4812:	28 2f       	mov	r18, r24
    4814:	30 e0       	ldi	r19, 0x00	; 0
    4816:	c9 01       	movw	r24, r18
    4818:	88 0f       	add	r24, r24
    481a:	99 1f       	adc	r25, r25
    481c:	88 0f       	add	r24, r24
    481e:	99 1f       	adc	r25, r25
    4820:	88 0f       	add	r24, r24
    4822:	99 1f       	adc	r25, r25
    4824:	82 0f       	add	r24, r18
    4826:	93 1f       	adc	r25, r19
    4828:	80 5b       	subi	r24, 0xB0	; 176
    482a:	9b 4f       	sbci	r25, 0xFB	; 251
    482c:	ea 85       	ldd	r30, Y+10	; 0x0a
    482e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4830:	93 87       	std	Z+11, r25	; 0x0b
    4832:	82 87       	std	Z+10, r24	; 0x0a
    4834:	ea 85       	ldd	r30, Y+10	; 0x0a
    4836:	fb 85       	ldd	r31, Y+11	; 0x0b
    4838:	86 89       	ldd	r24, Z+22	; 0x16
    483a:	28 2f       	mov	r18, r24
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	c9 01       	movw	r24, r18
    4840:	88 0f       	add	r24, r24
    4842:	99 1f       	adc	r25, r25
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	82 0f       	add	r24, r18
    484e:	93 1f       	adc	r25, r19
    4850:	fc 01       	movw	r30, r24
    4852:	e0 5b       	subi	r30, 0xB0	; 176
    4854:	fb 4f       	sbci	r31, 0xFB	; 251
    4856:	80 81       	ld	r24, Z
    4858:	8f 5f       	subi	r24, 0xFF	; 255
    485a:	80 83       	st	Z, r24
    485c:	30 c0       	rjmp	.+96     	; 0x48be <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    485e:	80 91 8b 04 	lds	r24, 0x048B
    4862:	90 91 8c 04 	lds	r25, 0x048C
    4866:	9a 83       	std	Y+2, r25	; 0x02
    4868:	89 83       	std	Y+1, r24	; 0x01
    486a:	ea 85       	ldd	r30, Y+10	; 0x0a
    486c:	fb 85       	ldd	r31, Y+11	; 0x0b
    486e:	89 81       	ldd	r24, Y+1	; 0x01
    4870:	9a 81       	ldd	r25, Y+2	; 0x02
    4872:	97 87       	std	Z+15, r25	; 0x0f
    4874:	86 87       	std	Z+14, r24	; 0x0e
    4876:	e9 81       	ldd	r30, Y+1	; 0x01
    4878:	fa 81       	ldd	r31, Y+2	; 0x02
    487a:	84 81       	ldd	r24, Z+4	; 0x04
    487c:	95 81       	ldd	r25, Z+5	; 0x05
    487e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4880:	fb 85       	ldd	r31, Y+11	; 0x0b
    4882:	91 8b       	std	Z+17, r25	; 0x11
    4884:	80 8b       	std	Z+16, r24	; 0x10
    4886:	e9 81       	ldd	r30, Y+1	; 0x01
    4888:	fa 81       	ldd	r31, Y+2	; 0x02
    488a:	04 80       	ldd	r0, Z+4	; 0x04
    488c:	f5 81       	ldd	r31, Z+5	; 0x05
    488e:	e0 2d       	mov	r30, r0
    4890:	8a 85       	ldd	r24, Y+10	; 0x0a
    4892:	9b 85       	ldd	r25, Y+11	; 0x0b
    4894:	0c 96       	adiw	r24, 0x0c	; 12
    4896:	93 83       	std	Z+3, r25	; 0x03
    4898:	82 83       	std	Z+2, r24	; 0x02
    489a:	8a 85       	ldd	r24, Y+10	; 0x0a
    489c:	9b 85       	ldd	r25, Y+11	; 0x0b
    489e:	0c 96       	adiw	r24, 0x0c	; 12
    48a0:	e9 81       	ldd	r30, Y+1	; 0x01
    48a2:	fa 81       	ldd	r31, Y+2	; 0x02
    48a4:	95 83       	std	Z+5, r25	; 0x05
    48a6:	84 83       	std	Z+4, r24	; 0x04
    48a8:	ea 85       	ldd	r30, Y+10	; 0x0a
    48aa:	fb 85       	ldd	r31, Y+11	; 0x0b
    48ac:	8a e8       	ldi	r24, 0x8A	; 138
    48ae:	94 e0       	ldi	r25, 0x04	; 4
    48b0:	95 8b       	std	Z+21, r25	; 0x15
    48b2:	84 8b       	std	Z+20, r24	; 0x14
    48b4:	80 91 8a 04 	lds	r24, 0x048A
    48b8:	8f 5f       	subi	r24, 0xFF	; 255
    48ba:	80 93 8a 04 	sts	0x048A, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    48be:	ea 85       	ldd	r30, Y+10	; 0x0a
    48c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48c2:	96 89       	ldd	r25, Z+22	; 0x16
    48c4:	e0 91 3f 04 	lds	r30, 0x043F
    48c8:	f0 91 40 04 	lds	r31, 0x0440
    48cc:	86 89       	ldd	r24, Z+22	; 0x16
    48ce:	89 17       	cp	r24, r25
    48d0:	30 f4       	brcc	.+12     	; 0x48de <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    48d2:	81 e0       	ldi	r24, 0x01	; 1
    48d4:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    48d6:	81 e0       	ldi	r24, 0x01	; 1
    48d8:	80 93 48 04 	sts	0x0448, r24
    48dc:	01 c0       	rjmp	.+2      	; 0x48e0 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    48de:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    48e0:	89 85       	ldd	r24, Y+9	; 0x09
}
    48e2:	2d 96       	adiw	r28, 0x0d	; 13
    48e4:	0f b6       	in	r0, 0x3f	; 63
    48e6:	f8 94       	cli
    48e8:	de bf       	out	0x3e, r29	; 62
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	cd bf       	out	0x3d, r28	; 61
    48ee:	cf 91       	pop	r28
    48f0:	df 91       	pop	r29
    48f2:	08 95       	ret

000048f4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    48f4:	df 93       	push	r29
    48f6:	cf 93       	push	r28
    48f8:	cd b7       	in	r28, 0x3d	; 61
    48fa:	de b7       	in	r29, 0x3e	; 62
    48fc:	2c 97       	sbiw	r28, 0x0c	; 12
    48fe:	0f b6       	in	r0, 0x3f	; 63
    4900:	f8 94       	cli
    4902:	de bf       	out	0x3e, r29	; 62
    4904:	0f be       	out	0x3f, r0	; 63
    4906:	cd bf       	out	0x3d, r28	; 61
    4908:	9a 87       	std	Y+10, r25	; 0x0a
    490a:	89 87       	std	Y+9, r24	; 0x09
    490c:	7c 87       	std	Y+12, r23	; 0x0c
    490e:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4910:	8b 85       	ldd	r24, Y+11	; 0x0b
    4912:	9c 85       	ldd	r25, Y+12	; 0x0c
    4914:	90 68       	ori	r25, 0x80	; 128
    4916:	e9 85       	ldd	r30, Y+9	; 0x09
    4918:	fa 85       	ldd	r31, Y+10	; 0x0a
    491a:	91 83       	std	Z+1, r25	; 0x01
    491c:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    491e:	e9 85       	ldd	r30, Y+9	; 0x09
    4920:	fa 85       	ldd	r31, Y+10	; 0x0a
    4922:	86 81       	ldd	r24, Z+6	; 0x06
    4924:	97 81       	ldd	r25, Z+7	; 0x07
    4926:	98 87       	std	Y+8, r25	; 0x08
    4928:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    492a:	e9 85       	ldd	r30, Y+9	; 0x09
    492c:	fa 85       	ldd	r31, Y+10	; 0x0a
    492e:	80 85       	ldd	r24, Z+8	; 0x08
    4930:	91 85       	ldd	r25, Z+9	; 0x09
    4932:	9e 83       	std	Y+6, r25	; 0x06
    4934:	8d 83       	std	Y+5, r24	; 0x05
    4936:	e9 85       	ldd	r30, Y+9	; 0x09
    4938:	fa 85       	ldd	r31, Y+10	; 0x0a
    493a:	a2 81       	ldd	r26, Z+2	; 0x02
    493c:	b3 81       	ldd	r27, Z+3	; 0x03
    493e:	e9 85       	ldd	r30, Y+9	; 0x09
    4940:	fa 85       	ldd	r31, Y+10	; 0x0a
    4942:	84 81       	ldd	r24, Z+4	; 0x04
    4944:	95 81       	ldd	r25, Z+5	; 0x05
    4946:	15 96       	adiw	r26, 0x05	; 5
    4948:	9c 93       	st	X, r25
    494a:	8e 93       	st	-X, r24
    494c:	14 97       	sbiw	r26, 0x04	; 4
    494e:	e9 85       	ldd	r30, Y+9	; 0x09
    4950:	fa 85       	ldd	r31, Y+10	; 0x0a
    4952:	a4 81       	ldd	r26, Z+4	; 0x04
    4954:	b5 81       	ldd	r27, Z+5	; 0x05
    4956:	e9 85       	ldd	r30, Y+9	; 0x09
    4958:	fa 85       	ldd	r31, Y+10	; 0x0a
    495a:	82 81       	ldd	r24, Z+2	; 0x02
    495c:	93 81       	ldd	r25, Z+3	; 0x03
    495e:	13 96       	adiw	r26, 0x03	; 3
    4960:	9c 93       	st	X, r25
    4962:	8e 93       	st	-X, r24
    4964:	12 97       	sbiw	r26, 0x02	; 2
    4966:	ed 81       	ldd	r30, Y+5	; 0x05
    4968:	fe 81       	ldd	r31, Y+6	; 0x06
    496a:	21 81       	ldd	r18, Z+1	; 0x01
    496c:	32 81       	ldd	r19, Z+2	; 0x02
    496e:	89 85       	ldd	r24, Y+9	; 0x09
    4970:	9a 85       	ldd	r25, Y+10	; 0x0a
    4972:	28 17       	cp	r18, r24
    4974:	39 07       	cpc	r19, r25
    4976:	41 f4       	brne	.+16     	; 0x4988 <vTaskRemoveFromUnorderedEventList+0x94>
    4978:	e9 85       	ldd	r30, Y+9	; 0x09
    497a:	fa 85       	ldd	r31, Y+10	; 0x0a
    497c:	84 81       	ldd	r24, Z+4	; 0x04
    497e:	95 81       	ldd	r25, Z+5	; 0x05
    4980:	ed 81       	ldd	r30, Y+5	; 0x05
    4982:	fe 81       	ldd	r31, Y+6	; 0x06
    4984:	92 83       	std	Z+2, r25	; 0x02
    4986:	81 83       	std	Z+1, r24	; 0x01
    4988:	e9 85       	ldd	r30, Y+9	; 0x09
    498a:	fa 85       	ldd	r31, Y+10	; 0x0a
    498c:	11 86       	std	Z+9, r1	; 0x09
    498e:	10 86       	std	Z+8, r1	; 0x08
    4990:	ed 81       	ldd	r30, Y+5	; 0x05
    4992:	fe 81       	ldd	r31, Y+6	; 0x06
    4994:	80 81       	ld	r24, Z
    4996:	81 50       	subi	r24, 0x01	; 1
    4998:	ed 81       	ldd	r30, Y+5	; 0x05
    499a:	fe 81       	ldd	r31, Y+6	; 0x06
    499c:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    499e:	ef 81       	ldd	r30, Y+7	; 0x07
    49a0:	f8 85       	ldd	r31, Y+8	; 0x08
    49a2:	82 85       	ldd	r24, Z+10	; 0x0a
    49a4:	93 85       	ldd	r25, Z+11	; 0x0b
    49a6:	9c 83       	std	Y+4, r25	; 0x04
    49a8:	8b 83       	std	Y+3, r24	; 0x03
    49aa:	ef 81       	ldd	r30, Y+7	; 0x07
    49ac:	f8 85       	ldd	r31, Y+8	; 0x08
    49ae:	a4 81       	ldd	r26, Z+4	; 0x04
    49b0:	b5 81       	ldd	r27, Z+5	; 0x05
    49b2:	ef 81       	ldd	r30, Y+7	; 0x07
    49b4:	f8 85       	ldd	r31, Y+8	; 0x08
    49b6:	86 81       	ldd	r24, Z+6	; 0x06
    49b8:	97 81       	ldd	r25, Z+7	; 0x07
    49ba:	15 96       	adiw	r26, 0x05	; 5
    49bc:	9c 93       	st	X, r25
    49be:	8e 93       	st	-X, r24
    49c0:	14 97       	sbiw	r26, 0x04	; 4
    49c2:	ef 81       	ldd	r30, Y+7	; 0x07
    49c4:	f8 85       	ldd	r31, Y+8	; 0x08
    49c6:	a6 81       	ldd	r26, Z+6	; 0x06
    49c8:	b7 81       	ldd	r27, Z+7	; 0x07
    49ca:	ef 81       	ldd	r30, Y+7	; 0x07
    49cc:	f8 85       	ldd	r31, Y+8	; 0x08
    49ce:	84 81       	ldd	r24, Z+4	; 0x04
    49d0:	95 81       	ldd	r25, Z+5	; 0x05
    49d2:	13 96       	adiw	r26, 0x03	; 3
    49d4:	9c 93       	st	X, r25
    49d6:	8e 93       	st	-X, r24
    49d8:	12 97       	sbiw	r26, 0x02	; 2
    49da:	eb 81       	ldd	r30, Y+3	; 0x03
    49dc:	fc 81       	ldd	r31, Y+4	; 0x04
    49de:	21 81       	ldd	r18, Z+1	; 0x01
    49e0:	32 81       	ldd	r19, Z+2	; 0x02
    49e2:	8f 81       	ldd	r24, Y+7	; 0x07
    49e4:	98 85       	ldd	r25, Y+8	; 0x08
    49e6:	02 96       	adiw	r24, 0x02	; 2
    49e8:	28 17       	cp	r18, r24
    49ea:	39 07       	cpc	r19, r25
    49ec:	41 f4       	brne	.+16     	; 0x49fe <vTaskRemoveFromUnorderedEventList+0x10a>
    49ee:	ef 81       	ldd	r30, Y+7	; 0x07
    49f0:	f8 85       	ldd	r31, Y+8	; 0x08
    49f2:	86 81       	ldd	r24, Z+6	; 0x06
    49f4:	97 81       	ldd	r25, Z+7	; 0x07
    49f6:	eb 81       	ldd	r30, Y+3	; 0x03
    49f8:	fc 81       	ldd	r31, Y+4	; 0x04
    49fa:	92 83       	std	Z+2, r25	; 0x02
    49fc:	81 83       	std	Z+1, r24	; 0x01
    49fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4a00:	f8 85       	ldd	r31, Y+8	; 0x08
    4a02:	13 86       	std	Z+11, r1	; 0x0b
    4a04:	12 86       	std	Z+10, r1	; 0x0a
    4a06:	eb 81       	ldd	r30, Y+3	; 0x03
    4a08:	fc 81       	ldd	r31, Y+4	; 0x04
    4a0a:	80 81       	ld	r24, Z
    4a0c:	81 50       	subi	r24, 0x01	; 1
    4a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a10:	fc 81       	ldd	r31, Y+4	; 0x04
    4a12:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4a14:	ef 81       	ldd	r30, Y+7	; 0x07
    4a16:	f8 85       	ldd	r31, Y+8	; 0x08
    4a18:	96 89       	ldd	r25, Z+22	; 0x16
    4a1a:	80 91 44 04 	lds	r24, 0x0444
    4a1e:	89 17       	cp	r24, r25
    4a20:	28 f4       	brcc	.+10     	; 0x4a2c <vTaskRemoveFromUnorderedEventList+0x138>
    4a22:	ef 81       	ldd	r30, Y+7	; 0x07
    4a24:	f8 85       	ldd	r31, Y+8	; 0x08
    4a26:	86 89       	ldd	r24, Z+22	; 0x16
    4a28:	80 93 44 04 	sts	0x0444, r24
    4a2c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a2e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a30:	86 89       	ldd	r24, Z+22	; 0x16
    4a32:	28 2f       	mov	r18, r24
    4a34:	30 e0       	ldi	r19, 0x00	; 0
    4a36:	c9 01       	movw	r24, r18
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	88 0f       	add	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	88 0f       	add	r24, r24
    4a42:	99 1f       	adc	r25, r25
    4a44:	82 0f       	add	r24, r18
    4a46:	93 1f       	adc	r25, r19
    4a48:	fc 01       	movw	r30, r24
    4a4a:	e0 5b       	subi	r30, 0xB0	; 176
    4a4c:	fb 4f       	sbci	r31, 0xFB	; 251
    4a4e:	81 81       	ldd	r24, Z+1	; 0x01
    4a50:	92 81       	ldd	r25, Z+2	; 0x02
    4a52:	9a 83       	std	Y+2, r25	; 0x02
    4a54:	89 83       	std	Y+1, r24	; 0x01
    4a56:	ef 81       	ldd	r30, Y+7	; 0x07
    4a58:	f8 85       	ldd	r31, Y+8	; 0x08
    4a5a:	89 81       	ldd	r24, Y+1	; 0x01
    4a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a5e:	95 83       	std	Z+5, r25	; 0x05
    4a60:	84 83       	std	Z+4, r24	; 0x04
    4a62:	e9 81       	ldd	r30, Y+1	; 0x01
    4a64:	fa 81       	ldd	r31, Y+2	; 0x02
    4a66:	84 81       	ldd	r24, Z+4	; 0x04
    4a68:	95 81       	ldd	r25, Z+5	; 0x05
    4a6a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a6c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a6e:	97 83       	std	Z+7, r25	; 0x07
    4a70:	86 83       	std	Z+6, r24	; 0x06
    4a72:	e9 81       	ldd	r30, Y+1	; 0x01
    4a74:	fa 81       	ldd	r31, Y+2	; 0x02
    4a76:	04 80       	ldd	r0, Z+4	; 0x04
    4a78:	f5 81       	ldd	r31, Z+5	; 0x05
    4a7a:	e0 2d       	mov	r30, r0
    4a7c:	8f 81       	ldd	r24, Y+7	; 0x07
    4a7e:	98 85       	ldd	r25, Y+8	; 0x08
    4a80:	02 96       	adiw	r24, 0x02	; 2
    4a82:	93 83       	std	Z+3, r25	; 0x03
    4a84:	82 83       	std	Z+2, r24	; 0x02
    4a86:	8f 81       	ldd	r24, Y+7	; 0x07
    4a88:	98 85       	ldd	r25, Y+8	; 0x08
    4a8a:	02 96       	adiw	r24, 0x02	; 2
    4a8c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a8e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a90:	95 83       	std	Z+5, r25	; 0x05
    4a92:	84 83       	std	Z+4, r24	; 0x04
    4a94:	ef 81       	ldd	r30, Y+7	; 0x07
    4a96:	f8 85       	ldd	r31, Y+8	; 0x08
    4a98:	86 89       	ldd	r24, Z+22	; 0x16
    4a9a:	28 2f       	mov	r18, r24
    4a9c:	30 e0       	ldi	r19, 0x00	; 0
    4a9e:	c9 01       	movw	r24, r18
    4aa0:	88 0f       	add	r24, r24
    4aa2:	99 1f       	adc	r25, r25
    4aa4:	88 0f       	add	r24, r24
    4aa6:	99 1f       	adc	r25, r25
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	82 0f       	add	r24, r18
    4aae:	93 1f       	adc	r25, r19
    4ab0:	80 5b       	subi	r24, 0xB0	; 176
    4ab2:	9b 4f       	sbci	r25, 0xFB	; 251
    4ab4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ab6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ab8:	93 87       	std	Z+11, r25	; 0x0b
    4aba:	82 87       	std	Z+10, r24	; 0x0a
    4abc:	ef 81       	ldd	r30, Y+7	; 0x07
    4abe:	f8 85       	ldd	r31, Y+8	; 0x08
    4ac0:	86 89       	ldd	r24, Z+22	; 0x16
    4ac2:	28 2f       	mov	r18, r24
    4ac4:	30 e0       	ldi	r19, 0x00	; 0
    4ac6:	c9 01       	movw	r24, r18
    4ac8:	88 0f       	add	r24, r24
    4aca:	99 1f       	adc	r25, r25
    4acc:	88 0f       	add	r24, r24
    4ace:	99 1f       	adc	r25, r25
    4ad0:	88 0f       	add	r24, r24
    4ad2:	99 1f       	adc	r25, r25
    4ad4:	82 0f       	add	r24, r18
    4ad6:	93 1f       	adc	r25, r19
    4ad8:	fc 01       	movw	r30, r24
    4ada:	e0 5b       	subi	r30, 0xB0	; 176
    4adc:	fb 4f       	sbci	r31, 0xFB	; 251
    4ade:	80 81       	ld	r24, Z
    4ae0:	8f 5f       	subi	r24, 0xFF	; 255
    4ae2:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ae4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ae6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ae8:	96 89       	ldd	r25, Z+22	; 0x16
    4aea:	e0 91 3f 04 	lds	r30, 0x043F
    4aee:	f0 91 40 04 	lds	r31, 0x0440
    4af2:	86 89       	ldd	r24, Z+22	; 0x16
    4af4:	89 17       	cp	r24, r25
    4af6:	18 f4       	brcc	.+6      	; 0x4afe <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4af8:	81 e0       	ldi	r24, 0x01	; 1
    4afa:	80 93 48 04 	sts	0x0448, r24
    }
}
    4afe:	2c 96       	adiw	r28, 0x0c	; 12
    4b00:	0f b6       	in	r0, 0x3f	; 63
    4b02:	f8 94       	cli
    4b04:	de bf       	out	0x3e, r29	; 62
    4b06:	0f be       	out	0x3f, r0	; 63
    4b08:	cd bf       	out	0x3d, r28	; 61
    4b0a:	cf 91       	pop	r28
    4b0c:	df 91       	pop	r29
    4b0e:	08 95       	ret

00004b10 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b10:	df 93       	push	r29
    4b12:	cf 93       	push	r28
    4b14:	00 d0       	rcall	.+0      	; 0x4b16 <vTaskSetTimeOutState+0x6>
    4b16:	cd b7       	in	r28, 0x3d	; 61
    4b18:	de b7       	in	r29, 0x3e	; 62
    4b1a:	9a 83       	std	Y+2, r25	; 0x02
    4b1c:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4b1e:	0f b6       	in	r0, 0x3f	; 63
    4b20:	f8 94       	cli
    4b22:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b24:	80 91 49 04 	lds	r24, 0x0449
    4b28:	e9 81       	ldd	r30, Y+1	; 0x01
    4b2a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b2c:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4b2e:	80 91 42 04 	lds	r24, 0x0442
    4b32:	90 91 43 04 	lds	r25, 0x0443
    4b36:	e9 81       	ldd	r30, Y+1	; 0x01
    4b38:	fa 81       	ldd	r31, Y+2	; 0x02
    4b3a:	92 83       	std	Z+2, r25	; 0x02
    4b3c:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4b3e:	0f 90       	pop	r0
    4b40:	0f be       	out	0x3f, r0	; 63
}
    4b42:	0f 90       	pop	r0
    4b44:	0f 90       	pop	r0
    4b46:	cf 91       	pop	r28
    4b48:	df 91       	pop	r29
    4b4a:	08 95       	ret

00004b4c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b4c:	df 93       	push	r29
    4b4e:	cf 93       	push	r28
    4b50:	00 d0       	rcall	.+0      	; 0x4b52 <vTaskInternalSetTimeOutState+0x6>
    4b52:	cd b7       	in	r28, 0x3d	; 61
    4b54:	de b7       	in	r29, 0x3e	; 62
    4b56:	9a 83       	std	Y+2, r25	; 0x02
    4b58:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b5a:	80 91 49 04 	lds	r24, 0x0449
    4b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b60:	fa 81       	ldd	r31, Y+2	; 0x02
    4b62:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4b64:	80 91 42 04 	lds	r24, 0x0442
    4b68:	90 91 43 04 	lds	r25, 0x0443
    4b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b70:	92 83       	std	Z+2, r25	; 0x02
    4b72:	81 83       	std	Z+1, r24	; 0x01
}
    4b74:	0f 90       	pop	r0
    4b76:	0f 90       	pop	r0
    4b78:	cf 91       	pop	r28
    4b7a:	df 91       	pop	r29
    4b7c:	08 95       	ret

00004b7e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4b7e:	df 93       	push	r29
    4b80:	cf 93       	push	r28
    4b82:	cd b7       	in	r28, 0x3d	; 61
    4b84:	de b7       	in	r29, 0x3e	; 62
    4b86:	29 97       	sbiw	r28, 0x09	; 9
    4b88:	0f b6       	in	r0, 0x3f	; 63
    4b8a:	f8 94       	cli
    4b8c:	de bf       	out	0x3e, r29	; 62
    4b8e:	0f be       	out	0x3f, r0	; 63
    4b90:	cd bf       	out	0x3d, r28	; 61
    4b92:	9f 83       	std	Y+7, r25	; 0x07
    4b94:	8e 83       	std	Y+6, r24	; 0x06
    4b96:	79 87       	std	Y+9, r23	; 0x09
    4b98:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4b9a:	0f b6       	in	r0, 0x3f	; 63
    4b9c:	f8 94       	cli
    4b9e:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4ba0:	80 91 42 04 	lds	r24, 0x0442
    4ba4:	90 91 43 04 	lds	r25, 0x0443
    4ba8:	9c 83       	std	Y+4, r25	; 0x04
    4baa:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4bac:	ee 81       	ldd	r30, Y+6	; 0x06
    4bae:	ff 81       	ldd	r31, Y+7	; 0x07
    4bb0:	21 81       	ldd	r18, Z+1	; 0x01
    4bb2:	32 81       	ldd	r19, Z+2	; 0x02
    4bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb8:	82 1b       	sub	r24, r18
    4bba:	93 0b       	sbc	r25, r19
    4bbc:	9a 83       	std	Y+2, r25	; 0x02
    4bbe:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4bc0:	ee 81       	ldd	r30, Y+6	; 0x06
    4bc2:	ff 81       	ldd	r31, Y+7	; 0x07
    4bc4:	90 81       	ld	r25, Z
    4bc6:	80 91 49 04 	lds	r24, 0x0449
    4bca:	98 17       	cp	r25, r24
    4bcc:	81 f0       	breq	.+32     	; 0x4bee <xTaskCheckForTimeOut+0x70>
    4bce:	ee 81       	ldd	r30, Y+6	; 0x06
    4bd0:	ff 81       	ldd	r31, Y+7	; 0x07
    4bd2:	21 81       	ldd	r18, Z+1	; 0x01
    4bd4:	32 81       	ldd	r19, Z+2	; 0x02
    4bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    4bda:	82 17       	cp	r24, r18
    4bdc:	93 07       	cpc	r25, r19
    4bde:	38 f0       	brcs	.+14     	; 0x4bee <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4be0:	81 e0       	ldi	r24, 0x01	; 1
    4be2:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4be4:	e8 85       	ldd	r30, Y+8	; 0x08
    4be6:	f9 85       	ldd	r31, Y+9	; 0x09
    4be8:	11 82       	std	Z+1, r1	; 0x01
    4bea:	10 82       	st	Z, r1
    4bec:	23 c0       	rjmp	.+70     	; 0x4c34 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4bee:	e8 85       	ldd	r30, Y+8	; 0x08
    4bf0:	f9 85       	ldd	r31, Y+9	; 0x09
    4bf2:	20 81       	ld	r18, Z
    4bf4:	31 81       	ldd	r19, Z+1	; 0x01
    4bf6:	89 81       	ldd	r24, Y+1	; 0x01
    4bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bfa:	82 17       	cp	r24, r18
    4bfc:	93 07       	cpc	r25, r19
    4bfe:	a0 f4       	brcc	.+40     	; 0x4c28 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4c00:	e8 85       	ldd	r30, Y+8	; 0x08
    4c02:	f9 85       	ldd	r31, Y+9	; 0x09
    4c04:	20 81       	ld	r18, Z
    4c06:	31 81       	ldd	r19, Z+1	; 0x01
    4c08:	89 81       	ldd	r24, Y+1	; 0x01
    4c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0c:	a9 01       	movw	r20, r18
    4c0e:	48 1b       	sub	r20, r24
    4c10:	59 0b       	sbc	r21, r25
    4c12:	ca 01       	movw	r24, r20
    4c14:	e8 85       	ldd	r30, Y+8	; 0x08
    4c16:	f9 85       	ldd	r31, Y+9	; 0x09
    4c18:	91 83       	std	Z+1, r25	; 0x01
    4c1a:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4c1c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c1e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c20:	0e 94 a6 25 	call	0x4b4c	; 0x4b4c <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4c24:	1d 82       	std	Y+5, r1	; 0x05
    4c26:	06 c0       	rjmp	.+12     	; 0x4c34 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4c28:	e8 85       	ldd	r30, Y+8	; 0x08
    4c2a:	f9 85       	ldd	r31, Y+9	; 0x09
    4c2c:	11 82       	std	Z+1, r1	; 0x01
    4c2e:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4c30:	81 e0       	ldi	r24, 0x01	; 1
    4c32:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4c34:	0f 90       	pop	r0
    4c36:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4c38:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c3a:	29 96       	adiw	r28, 0x09	; 9
    4c3c:	0f b6       	in	r0, 0x3f	; 63
    4c3e:	f8 94       	cli
    4c40:	de bf       	out	0x3e, r29	; 62
    4c42:	0f be       	out	0x3f, r0	; 63
    4c44:	cd bf       	out	0x3d, r28	; 61
    4c46:	cf 91       	pop	r28
    4c48:	df 91       	pop	r29
    4c4a:	08 95       	ret

00004c4c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4c4c:	df 93       	push	r29
    4c4e:	cf 93       	push	r28
    4c50:	cd b7       	in	r28, 0x3d	; 61
    4c52:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4c54:	81 e0       	ldi	r24, 0x01	; 1
    4c56:	80 93 48 04 	sts	0x0448, r24
}
    4c5a:	cf 91       	pop	r28
    4c5c:	df 91       	pop	r29
    4c5e:	08 95       	ret

00004c60 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4c60:	df 93       	push	r29
    4c62:	cf 93       	push	r28
    4c64:	00 d0       	rcall	.+0      	; 0x4c66 <prvIdleTask+0x6>
    4c66:	cd b7       	in	r28, 0x3d	; 61
    4c68:	de b7       	in	r29, 0x3e	; 62
    4c6a:	9a 83       	std	Y+2, r25	; 0x02
    4c6c:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4c6e:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4c72:	80 91 50 04 	lds	r24, 0x0450
    4c76:	82 30       	cpi	r24, 0x02	; 2
    4c78:	d0 f3       	brcs	.-12     	; 0x4c6e <prvIdleTask+0xe>
                {
                    taskYIELD();
    4c7a:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
    4c7e:	f7 cf       	rjmp	.-18     	; 0x4c6e <prvIdleTask+0xe>

00004c80 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4c80:	df 93       	push	r29
    4c82:	cf 93       	push	r28
    4c84:	0f 92       	push	r0
    4c86:	cd b7       	in	r28, 0x3d	; 61
    4c88:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4c8a:	19 82       	std	Y+1, r1	; 0x01
    4c8c:	13 c0       	rjmp	.+38     	; 0x4cb4 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4c8e:	89 81       	ldd	r24, Y+1	; 0x01
    4c90:	28 2f       	mov	r18, r24
    4c92:	30 e0       	ldi	r19, 0x00	; 0
    4c94:	c9 01       	movw	r24, r18
    4c96:	88 0f       	add	r24, r24
    4c98:	99 1f       	adc	r25, r25
    4c9a:	88 0f       	add	r24, r24
    4c9c:	99 1f       	adc	r25, r25
    4c9e:	88 0f       	add	r24, r24
    4ca0:	99 1f       	adc	r25, r25
    4ca2:	82 0f       	add	r24, r18
    4ca4:	93 1f       	adc	r25, r19
    4ca6:	80 5b       	subi	r24, 0xB0	; 176
    4ca8:	9b 4f       	sbci	r25, 0xFB	; 251
    4caa:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cae:	89 81       	ldd	r24, Y+1	; 0x01
    4cb0:	8f 5f       	subi	r24, 0xFF	; 255
    4cb2:	89 83       	std	Y+1, r24	; 0x01
    4cb4:	89 81       	ldd	r24, Y+1	; 0x01
    4cb6:	84 30       	cpi	r24, 0x04	; 4
    4cb8:	50 f3       	brcs	.-44     	; 0x4c8e <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4cba:	84 e7       	ldi	r24, 0x74	; 116
    4cbc:	94 e0       	ldi	r25, 0x04	; 4
    4cbe:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4cc2:	8d e7       	ldi	r24, 0x7D	; 125
    4cc4:	94 e0       	ldi	r25, 0x04	; 4
    4cc6:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4cca:	8a e8       	ldi	r24, 0x8A	; 138
    4ccc:	94 e0       	ldi	r25, 0x04	; 4
    4cce:	0e 94 2c 12 	call	0x2458	; 0x2458 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4cd2:	84 e7       	ldi	r24, 0x74	; 116
    4cd4:	94 e0       	ldi	r25, 0x04	; 4
    4cd6:	90 93 87 04 	sts	0x0487, r25
    4cda:	80 93 86 04 	sts	0x0486, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4cde:	8d e7       	ldi	r24, 0x7D	; 125
    4ce0:	94 e0       	ldi	r25, 0x04	; 4
    4ce2:	90 93 89 04 	sts	0x0489, r25
    4ce6:	80 93 88 04 	sts	0x0488, r24
}
    4cea:	0f 90       	pop	r0
    4cec:	cf 91       	pop	r28
    4cee:	df 91       	pop	r29
    4cf0:	08 95       	ret

00004cf2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4cf2:	df 93       	push	r29
    4cf4:	cf 93       	push	r28
    4cf6:	cd b7       	in	r28, 0x3d	; 61
    4cf8:	de b7       	in	r29, 0x3e	; 62

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4cfa:	cf 91       	pop	r28
    4cfc:	df 91       	pop	r29
    4cfe:	08 95       	ret

00004d00 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4d00:	df 93       	push	r29
    4d02:	cf 93       	push	r28
    4d04:	cd b7       	in	r28, 0x3d	; 61
    4d06:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4d08:	e0 91 86 04 	lds	r30, 0x0486
    4d0c:	f0 91 87 04 	lds	r31, 0x0487
    4d10:	80 81       	ld	r24, Z
    4d12:	88 23       	and	r24, r24
    4d14:	39 f4       	brne	.+14     	; 0x4d24 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4d16:	8f ef       	ldi	r24, 0xFF	; 255
    4d18:	9f ef       	ldi	r25, 0xFF	; 255
    4d1a:	90 93 4c 04 	sts	0x044C, r25
    4d1e:	80 93 4b 04 	sts	0x044B, r24
    4d22:	0d c0       	rjmp	.+26     	; 0x4d3e <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4d24:	e0 91 86 04 	lds	r30, 0x0486
    4d28:	f0 91 87 04 	lds	r31, 0x0487
    4d2c:	05 80       	ldd	r0, Z+5	; 0x05
    4d2e:	f6 81       	ldd	r31, Z+6	; 0x06
    4d30:	e0 2d       	mov	r30, r0
    4d32:	80 81       	ld	r24, Z
    4d34:	91 81       	ldd	r25, Z+1	; 0x01
    4d36:	90 93 4c 04 	sts	0x044C, r25
    4d3a:	80 93 4b 04 	sts	0x044B, r24
    }
}
    4d3e:	cf 91       	pop	r28
    4d40:	df 91       	pop	r29
    4d42:	08 95       	ret

00004d44 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4d44:	df 93       	push	r29
    4d46:	cf 93       	push	r28
    4d48:	00 d0       	rcall	.+0      	; 0x4d4a <uxTaskResetEventItemValue+0x6>
    4d4a:	cd b7       	in	r28, 0x3d	; 61
    4d4c:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4d4e:	e0 91 3f 04 	lds	r30, 0x043F
    4d52:	f0 91 40 04 	lds	r31, 0x0440
    4d56:	84 85       	ldd	r24, Z+12	; 0x0c
    4d58:	95 85       	ldd	r25, Z+13	; 0x0d
    4d5a:	9a 83       	std	Y+2, r25	; 0x02
    4d5c:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d5e:	a0 91 3f 04 	lds	r26, 0x043F
    4d62:	b0 91 40 04 	lds	r27, 0x0440
    4d66:	e0 91 3f 04 	lds	r30, 0x043F
    4d6a:	f0 91 40 04 	lds	r31, 0x0440
    4d6e:	86 89       	ldd	r24, Z+22	; 0x16
    4d70:	28 2f       	mov	r18, r24
    4d72:	30 e0       	ldi	r19, 0x00	; 0
    4d74:	84 e0       	ldi	r24, 0x04	; 4
    4d76:	90 e0       	ldi	r25, 0x00	; 0
    4d78:	82 1b       	sub	r24, r18
    4d7a:	93 0b       	sbc	r25, r19
    4d7c:	1d 96       	adiw	r26, 0x0d	; 13
    4d7e:	9c 93       	st	X, r25
    4d80:	8e 93       	st	-X, r24
    4d82:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4d84:	89 81       	ldd	r24, Y+1	; 0x01
    4d86:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4d88:	0f 90       	pop	r0
    4d8a:	0f 90       	pop	r0
    4d8c:	cf 91       	pop	r28
    4d8e:	df 91       	pop	r29
    4d90:	08 95       	ret

00004d92 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4d92:	df 93       	push	r29
    4d94:	cf 93       	push	r28
    4d96:	cd b7       	in	r28, 0x3d	; 61
    4d98:	de b7       	in	r29, 0x3e	; 62
    4d9a:	28 97       	sbiw	r28, 0x08	; 8
    4d9c:	0f b6       	in	r0, 0x3f	; 63
    4d9e:	f8 94       	cli
    4da0:	de bf       	out	0x3e, r29	; 62
    4da2:	0f be       	out	0x3f, r0	; 63
    4da4:	cd bf       	out	0x3d, r28	; 61
    4da6:	8d 83       	std	Y+5, r24	; 0x05
    4da8:	6e 83       	std	Y+6, r22	; 0x06
    4daa:	58 87       	std	Y+8, r21	; 0x08
    4dac:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4dae:	0f b6       	in	r0, 0x3f	; 63
    4db0:	f8 94       	cli
    4db2:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4db4:	20 91 3f 04 	lds	r18, 0x043F
    4db8:	30 91 40 04 	lds	r19, 0x0440
    4dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbe:	88 2f       	mov	r24, r24
    4dc0:	90 e0       	ldi	r25, 0x00	; 0
    4dc2:	88 0f       	add	r24, r24
    4dc4:	99 1f       	adc	r25, r25
    4dc6:	88 0f       	add	r24, r24
    4dc8:	99 1f       	adc	r25, r25
    4dca:	82 0f       	add	r24, r18
    4dcc:	93 1f       	adc	r25, r19
    4dce:	fc 01       	movw	r30, r24
    4dd0:	b1 96       	adiw	r30, 0x21	; 33
    4dd2:	80 81       	ld	r24, Z
    4dd4:	91 81       	ldd	r25, Z+1	; 0x01
    4dd6:	a2 81       	ldd	r26, Z+2	; 0x02
    4dd8:	b3 81       	ldd	r27, Z+3	; 0x03
    4dda:	00 97       	sbiw	r24, 0x00	; 0
    4ddc:	a1 05       	cpc	r26, r1
    4dde:	b1 05       	cpc	r27, r1
    4de0:	c1 f4       	brne	.+48     	; 0x4e12 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4de2:	20 91 3f 04 	lds	r18, 0x043F
    4de6:	30 91 40 04 	lds	r19, 0x0440
    4dea:	8d 81       	ldd	r24, Y+5	; 0x05
    4dec:	88 2f       	mov	r24, r24
    4dee:	90 e0       	ldi	r25, 0x00	; 0
    4df0:	82 0f       	add	r24, r18
    4df2:	93 1f       	adc	r25, r19
    4df4:	fc 01       	movw	r30, r24
    4df6:	b5 96       	adiw	r30, 0x25	; 37
    4df8:	81 e0       	ldi	r24, 0x01	; 1
    4dfa:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4dfc:	8f 81       	ldd	r24, Y+7	; 0x07
    4dfe:	98 85       	ldd	r25, Y+8	; 0x08
    4e00:	00 97       	sbiw	r24, 0x00	; 0
    4e02:	39 f0       	breq	.+14     	; 0x4e12 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e04:	8f 81       	ldd	r24, Y+7	; 0x07
    4e06:	98 85       	ldd	r25, Y+8	; 0x08
    4e08:	61 e0       	ldi	r22, 0x01	; 1
    4e0a:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4e0e:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4e12:	0f 90       	pop	r0
    4e14:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4e16:	0f b6       	in	r0, 0x3f	; 63
    4e18:	f8 94       	cli
    4e1a:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4e1c:	20 91 3f 04 	lds	r18, 0x043F
    4e20:	30 91 40 04 	lds	r19, 0x0440
    4e24:	8d 81       	ldd	r24, Y+5	; 0x05
    4e26:	88 2f       	mov	r24, r24
    4e28:	90 e0       	ldi	r25, 0x00	; 0
    4e2a:	88 0f       	add	r24, r24
    4e2c:	99 1f       	adc	r25, r25
    4e2e:	88 0f       	add	r24, r24
    4e30:	99 1f       	adc	r25, r25
    4e32:	82 0f       	add	r24, r18
    4e34:	93 1f       	adc	r25, r19
    4e36:	fc 01       	movw	r30, r24
    4e38:	b1 96       	adiw	r30, 0x21	; 33
    4e3a:	80 81       	ld	r24, Z
    4e3c:	91 81       	ldd	r25, Z+1	; 0x01
    4e3e:	a2 81       	ldd	r26, Z+2	; 0x02
    4e40:	b3 81       	ldd	r27, Z+3	; 0x03
    4e42:	89 83       	std	Y+1, r24	; 0x01
    4e44:	9a 83       	std	Y+2, r25	; 0x02
    4e46:	ab 83       	std	Y+3, r26	; 0x03
    4e48:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4e4a:	89 81       	ldd	r24, Y+1	; 0x01
    4e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e4e:	ab 81       	ldd	r26, Y+3	; 0x03
    4e50:	bc 81       	ldd	r27, Y+4	; 0x04
    4e52:	00 97       	sbiw	r24, 0x00	; 0
    4e54:	a1 05       	cpc	r26, r1
    4e56:	b1 05       	cpc	r27, r1
    4e58:	a9 f1       	breq	.+106    	; 0x4ec4 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4e5a:	8e 81       	ldd	r24, Y+6	; 0x06
    4e5c:	88 23       	and	r24, r24
    4e5e:	a1 f0       	breq	.+40     	; 0x4e88 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4e60:	20 91 3f 04 	lds	r18, 0x043F
    4e64:	30 91 40 04 	lds	r19, 0x0440
    4e68:	8d 81       	ldd	r24, Y+5	; 0x05
    4e6a:	88 2f       	mov	r24, r24
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	88 0f       	add	r24, r24
    4e70:	99 1f       	adc	r25, r25
    4e72:	88 0f       	add	r24, r24
    4e74:	99 1f       	adc	r25, r25
    4e76:	82 0f       	add	r24, r18
    4e78:	93 1f       	adc	r25, r19
    4e7a:	fc 01       	movw	r30, r24
    4e7c:	b1 96       	adiw	r30, 0x21	; 33
    4e7e:	10 82       	st	Z, r1
    4e80:	11 82       	std	Z+1, r1	; 0x01
    4e82:	12 82       	std	Z+2, r1	; 0x02
    4e84:	13 82       	std	Z+3, r1	; 0x03
    4e86:	1e c0       	rjmp	.+60     	; 0x4ec4 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4e88:	e0 91 3f 04 	lds	r30, 0x043F
    4e8c:	f0 91 40 04 	lds	r31, 0x0440
    4e90:	8d 81       	ldd	r24, Y+5	; 0x05
    4e92:	68 2f       	mov	r22, r24
    4e94:	70 e0       	ldi	r23, 0x00	; 0
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	9a 81       	ldd	r25, Y+2	; 0x02
    4e9a:	ab 81       	ldd	r26, Y+3	; 0x03
    4e9c:	bc 81       	ldd	r27, Y+4	; 0x04
    4e9e:	9c 01       	movw	r18, r24
    4ea0:	ad 01       	movw	r20, r26
    4ea2:	21 50       	subi	r18, 0x01	; 1
    4ea4:	30 40       	sbci	r19, 0x00	; 0
    4ea6:	40 40       	sbci	r20, 0x00	; 0
    4ea8:	50 40       	sbci	r21, 0x00	; 0
    4eaa:	cb 01       	movw	r24, r22
    4eac:	88 0f       	add	r24, r24
    4eae:	99 1f       	adc	r25, r25
    4eb0:	88 0f       	add	r24, r24
    4eb2:	99 1f       	adc	r25, r25
    4eb4:	8e 0f       	add	r24, r30
    4eb6:	9f 1f       	adc	r25, r31
    4eb8:	fc 01       	movw	r30, r24
    4eba:	b1 96       	adiw	r30, 0x21	; 33
    4ebc:	20 83       	st	Z, r18
    4ebe:	31 83       	std	Z+1, r19	; 0x01
    4ec0:	42 83       	std	Z+2, r20	; 0x02
    4ec2:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4ec4:	20 91 3f 04 	lds	r18, 0x043F
    4ec8:	30 91 40 04 	lds	r19, 0x0440
    4ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    4ece:	88 2f       	mov	r24, r24
    4ed0:	90 e0       	ldi	r25, 0x00	; 0
    4ed2:	82 0f       	add	r24, r18
    4ed4:	93 1f       	adc	r25, r19
    4ed6:	fc 01       	movw	r30, r24
    4ed8:	b5 96       	adiw	r30, 0x25	; 37
    4eda:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4edc:	0f 90       	pop	r0
    4ede:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4ee0:	89 81       	ldd	r24, Y+1	; 0x01
    4ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee4:	ab 81       	ldd	r26, Y+3	; 0x03
    4ee6:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4ee8:	bc 01       	movw	r22, r24
    4eea:	cd 01       	movw	r24, r26
    4eec:	28 96       	adiw	r28, 0x08	; 8
    4eee:	0f b6       	in	r0, 0x3f	; 63
    4ef0:	f8 94       	cli
    4ef2:	de bf       	out	0x3e, r29	; 62
    4ef4:	0f be       	out	0x3f, r0	; 63
    4ef6:	cd bf       	out	0x3d, r28	; 61
    4ef8:	cf 91       	pop	r28
    4efa:	df 91       	pop	r29
    4efc:	08 95       	ret

00004efe <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4efe:	cf 92       	push	r12
    4f00:	df 92       	push	r13
    4f02:	ef 92       	push	r14
    4f04:	ff 92       	push	r15
    4f06:	0f 93       	push	r16
    4f08:	1f 93       	push	r17
    4f0a:	df 93       	push	r29
    4f0c:	cf 93       	push	r28
    4f0e:	cd b7       	in	r28, 0x3d	; 61
    4f10:	de b7       	in	r29, 0x3e	; 62
    4f12:	2e 97       	sbiw	r28, 0x0e	; 14
    4f14:	0f b6       	in	r0, 0x3f	; 63
    4f16:	f8 94       	cli
    4f18:	de bf       	out	0x3e, r29	; 62
    4f1a:	0f be       	out	0x3f, r0	; 63
    4f1c:	cd bf       	out	0x3d, r28	; 61
    4f1e:	8a 83       	std	Y+2, r24	; 0x02
    4f20:	4b 83       	std	Y+3, r20	; 0x03
    4f22:	5c 83       	std	Y+4, r21	; 0x04
    4f24:	6d 83       	std	Y+5, r22	; 0x05
    4f26:	7e 83       	std	Y+6, r23	; 0x06
    4f28:	0f 83       	std	Y+7, r16	; 0x07
    4f2a:	18 87       	std	Y+8, r17	; 0x08
    4f2c:	29 87       	std	Y+9, r18	; 0x09
    4f2e:	3a 87       	std	Y+10, r19	; 0x0a
    4f30:	fc 86       	std	Y+12, r15	; 0x0c
    4f32:	eb 86       	std	Y+11, r14	; 0x0b
    4f34:	de 86       	std	Y+14, r13	; 0x0e
    4f36:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4f38:	0f b6       	in	r0, 0x3f	; 63
    4f3a:	f8 94       	cli
    4f3c:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4f3e:	20 91 3f 04 	lds	r18, 0x043F
    4f42:	30 91 40 04 	lds	r19, 0x0440
    4f46:	8a 81       	ldd	r24, Y+2	; 0x02
    4f48:	88 2f       	mov	r24, r24
    4f4a:	90 e0       	ldi	r25, 0x00	; 0
    4f4c:	82 0f       	add	r24, r18
    4f4e:	93 1f       	adc	r25, r19
    4f50:	fc 01       	movw	r30, r24
    4f52:	b5 96       	adiw	r30, 0x25	; 37
    4f54:	80 81       	ld	r24, Z
    4f56:	82 30       	cpi	r24, 0x02	; 2
    4f58:	09 f4       	brne	.+2      	; 0x4f5c <xTaskGenericNotifyWait+0x5e>
    4f5a:	47 c0       	rjmp	.+142    	; 0x4fea <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4f5c:	60 91 3f 04 	lds	r22, 0x043F
    4f60:	70 91 40 04 	lds	r23, 0x0440
    4f64:	8a 81       	ldd	r24, Y+2	; 0x02
    4f66:	08 2f       	mov	r16, r24
    4f68:	10 e0       	ldi	r17, 0x00	; 0
    4f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6c:	88 2f       	mov	r24, r24
    4f6e:	90 e0       	ldi	r25, 0x00	; 0
    4f70:	88 0f       	add	r24, r24
    4f72:	99 1f       	adc	r25, r25
    4f74:	88 0f       	add	r24, r24
    4f76:	99 1f       	adc	r25, r25
    4f78:	86 0f       	add	r24, r22
    4f7a:	97 1f       	adc	r25, r23
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	b1 96       	adiw	r30, 0x21	; 33
    4f80:	20 81       	ld	r18, Z
    4f82:	31 81       	ldd	r19, Z+1	; 0x01
    4f84:	42 81       	ldd	r20, Z+2	; 0x02
    4f86:	53 81       	ldd	r21, Z+3	; 0x03
    4f88:	8b 81       	ldd	r24, Y+3	; 0x03
    4f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f8c:	ad 81       	ldd	r26, Y+5	; 0x05
    4f8e:	be 81       	ldd	r27, Y+6	; 0x06
    4f90:	80 95       	com	r24
    4f92:	90 95       	com	r25
    4f94:	a0 95       	com	r26
    4f96:	b0 95       	com	r27
    4f98:	28 23       	and	r18, r24
    4f9a:	39 23       	and	r19, r25
    4f9c:	4a 23       	and	r20, r26
    4f9e:	5b 23       	and	r21, r27
    4fa0:	c8 01       	movw	r24, r16
    4fa2:	88 0f       	add	r24, r24
    4fa4:	99 1f       	adc	r25, r25
    4fa6:	88 0f       	add	r24, r24
    4fa8:	99 1f       	adc	r25, r25
    4faa:	86 0f       	add	r24, r22
    4fac:	97 1f       	adc	r25, r23
    4fae:	fc 01       	movw	r30, r24
    4fb0:	b1 96       	adiw	r30, 0x21	; 33
    4fb2:	20 83       	st	Z, r18
    4fb4:	31 83       	std	Z+1, r19	; 0x01
    4fb6:	42 83       	std	Z+2, r20	; 0x02
    4fb8:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4fba:	20 91 3f 04 	lds	r18, 0x043F
    4fbe:	30 91 40 04 	lds	r19, 0x0440
    4fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    4fc4:	88 2f       	mov	r24, r24
    4fc6:	90 e0       	ldi	r25, 0x00	; 0
    4fc8:	82 0f       	add	r24, r18
    4fca:	93 1f       	adc	r25, r19
    4fcc:	fc 01       	movw	r30, r24
    4fce:	b5 96       	adiw	r30, 0x25	; 37
    4fd0:	81 e0       	ldi	r24, 0x01	; 1
    4fd2:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4fd4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fd6:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fd8:	00 97       	sbiw	r24, 0x00	; 0
    4fda:	39 f0       	breq	.+14     	; 0x4fea <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4fdc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fde:	9e 85       	ldd	r25, Y+14	; 0x0e
    4fe0:	61 e0       	ldi	r22, 0x01	; 1
    4fe2:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4fe6:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4fea:	0f 90       	pop	r0
    4fec:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4fee:	0f b6       	in	r0, 0x3f	; 63
    4ff0:	f8 94       	cli
    4ff2:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4ff4:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ff6:	9c 85       	ldd	r25, Y+12	; 0x0c
    4ff8:	00 97       	sbiw	r24, 0x00	; 0
    4ffa:	c9 f0       	breq	.+50     	; 0x502e <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4ffc:	20 91 3f 04 	lds	r18, 0x043F
    5000:	30 91 40 04 	lds	r19, 0x0440
    5004:	8a 81       	ldd	r24, Y+2	; 0x02
    5006:	88 2f       	mov	r24, r24
    5008:	90 e0       	ldi	r25, 0x00	; 0
    500a:	88 0f       	add	r24, r24
    500c:	99 1f       	adc	r25, r25
    500e:	88 0f       	add	r24, r24
    5010:	99 1f       	adc	r25, r25
    5012:	82 0f       	add	r24, r18
    5014:	93 1f       	adc	r25, r19
    5016:	fc 01       	movw	r30, r24
    5018:	b1 96       	adiw	r30, 0x21	; 33
    501a:	80 81       	ld	r24, Z
    501c:	91 81       	ldd	r25, Z+1	; 0x01
    501e:	a2 81       	ldd	r26, Z+2	; 0x02
    5020:	b3 81       	ldd	r27, Z+3	; 0x03
    5022:	eb 85       	ldd	r30, Y+11	; 0x0b
    5024:	fc 85       	ldd	r31, Y+12	; 0x0c
    5026:	80 83       	st	Z, r24
    5028:	91 83       	std	Z+1, r25	; 0x01
    502a:	a2 83       	std	Z+2, r26	; 0x02
    502c:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    502e:	20 91 3f 04 	lds	r18, 0x043F
    5032:	30 91 40 04 	lds	r19, 0x0440
    5036:	8a 81       	ldd	r24, Y+2	; 0x02
    5038:	88 2f       	mov	r24, r24
    503a:	90 e0       	ldi	r25, 0x00	; 0
    503c:	82 0f       	add	r24, r18
    503e:	93 1f       	adc	r25, r19
    5040:	fc 01       	movw	r30, r24
    5042:	b5 96       	adiw	r30, 0x25	; 37
    5044:	80 81       	ld	r24, Z
    5046:	82 30       	cpi	r24, 0x02	; 2
    5048:	11 f0       	breq	.+4      	; 0x504e <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    504a:	19 82       	std	Y+1, r1	; 0x01
    504c:	31 c0       	rjmp	.+98     	; 0x50b0 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    504e:	60 91 3f 04 	lds	r22, 0x043F
    5052:	70 91 40 04 	lds	r23, 0x0440
    5056:	8a 81       	ldd	r24, Y+2	; 0x02
    5058:	08 2f       	mov	r16, r24
    505a:	10 e0       	ldi	r17, 0x00	; 0
    505c:	8a 81       	ldd	r24, Y+2	; 0x02
    505e:	88 2f       	mov	r24, r24
    5060:	90 e0       	ldi	r25, 0x00	; 0
    5062:	88 0f       	add	r24, r24
    5064:	99 1f       	adc	r25, r25
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	86 0f       	add	r24, r22
    506c:	97 1f       	adc	r25, r23
    506e:	fc 01       	movw	r30, r24
    5070:	b1 96       	adiw	r30, 0x21	; 33
    5072:	20 81       	ld	r18, Z
    5074:	31 81       	ldd	r19, Z+1	; 0x01
    5076:	42 81       	ldd	r20, Z+2	; 0x02
    5078:	53 81       	ldd	r21, Z+3	; 0x03
    507a:	8f 81       	ldd	r24, Y+7	; 0x07
    507c:	98 85       	ldd	r25, Y+8	; 0x08
    507e:	a9 85       	ldd	r26, Y+9	; 0x09
    5080:	ba 85       	ldd	r27, Y+10	; 0x0a
    5082:	80 95       	com	r24
    5084:	90 95       	com	r25
    5086:	a0 95       	com	r26
    5088:	b0 95       	com	r27
    508a:	28 23       	and	r18, r24
    508c:	39 23       	and	r19, r25
    508e:	4a 23       	and	r20, r26
    5090:	5b 23       	and	r21, r27
    5092:	c8 01       	movw	r24, r16
    5094:	88 0f       	add	r24, r24
    5096:	99 1f       	adc	r25, r25
    5098:	88 0f       	add	r24, r24
    509a:	99 1f       	adc	r25, r25
    509c:	86 0f       	add	r24, r22
    509e:	97 1f       	adc	r25, r23
    50a0:	fc 01       	movw	r30, r24
    50a2:	b1 96       	adiw	r30, 0x21	; 33
    50a4:	20 83       	st	Z, r18
    50a6:	31 83       	std	Z+1, r19	; 0x01
    50a8:	42 83       	std	Z+2, r20	; 0x02
    50aa:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    50ac:	81 e0       	ldi	r24, 0x01	; 1
    50ae:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    50b0:	20 91 3f 04 	lds	r18, 0x043F
    50b4:	30 91 40 04 	lds	r19, 0x0440
    50b8:	8a 81       	ldd	r24, Y+2	; 0x02
    50ba:	88 2f       	mov	r24, r24
    50bc:	90 e0       	ldi	r25, 0x00	; 0
    50be:	82 0f       	add	r24, r18
    50c0:	93 1f       	adc	r25, r19
    50c2:	fc 01       	movw	r30, r24
    50c4:	b5 96       	adiw	r30, 0x25	; 37
    50c6:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    50c8:	0f 90       	pop	r0
    50ca:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    50cc:	89 81       	ldd	r24, Y+1	; 0x01
    }
    50ce:	2e 96       	adiw	r28, 0x0e	; 14
    50d0:	0f b6       	in	r0, 0x3f	; 63
    50d2:	f8 94       	cli
    50d4:	de bf       	out	0x3e, r29	; 62
    50d6:	0f be       	out	0x3f, r0	; 63
    50d8:	cd bf       	out	0x3d, r28	; 61
    50da:	cf 91       	pop	r28
    50dc:	df 91       	pop	r29
    50de:	1f 91       	pop	r17
    50e0:	0f 91       	pop	r16
    50e2:	ff 90       	pop	r15
    50e4:	ef 90       	pop	r14
    50e6:	df 90       	pop	r13
    50e8:	cf 90       	pop	r12
    50ea:	08 95       	ret

000050ec <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    50ec:	ef 92       	push	r14
    50ee:	ff 92       	push	r15
    50f0:	0f 93       	push	r16
    50f2:	1f 93       	push	r17
    50f4:	df 93       	push	r29
    50f6:	cf 93       	push	r28
    50f8:	cd b7       	in	r28, 0x3d	; 61
    50fa:	de b7       	in	r29, 0x3e	; 62
    50fc:	64 97       	sbiw	r28, 0x14	; 20
    50fe:	0f b6       	in	r0, 0x3f	; 63
    5100:	f8 94       	cli
    5102:	de bf       	out	0x3e, r29	; 62
    5104:	0f be       	out	0x3f, r0	; 63
    5106:	cd bf       	out	0x3d, r28	; 61
    5108:	9a 87       	std	Y+10, r25	; 0x0a
    510a:	89 87       	std	Y+9, r24	; 0x09
    510c:	6b 87       	std	Y+11, r22	; 0x0b
    510e:	2c 87       	std	Y+12, r18	; 0x0c
    5110:	3d 87       	std	Y+13, r19	; 0x0d
    5112:	4e 87       	std	Y+14, r20	; 0x0e
    5114:	5f 87       	std	Y+15, r21	; 0x0f
    5116:	08 8b       	std	Y+16, r16	; 0x10
    5118:	fa 8a       	std	Y+18, r15	; 0x12
    511a:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    511c:	81 e0       	ldi	r24, 0x01	; 1
    511e:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    5120:	89 85       	ldd	r24, Y+9	; 0x09
    5122:	9a 85       	ldd	r25, Y+10	; 0x0a
    5124:	98 87       	std	Y+8, r25	; 0x08
    5126:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    5128:	0f b6       	in	r0, 0x3f	; 63
    512a:	f8 94       	cli
    512c:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    512e:	89 89       	ldd	r24, Y+17	; 0x11
    5130:	9a 89       	ldd	r25, Y+18	; 0x12
    5132:	00 97       	sbiw	r24, 0x00	; 0
    5134:	b9 f0       	breq	.+46     	; 0x5164 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5136:	8b 85       	ldd	r24, Y+11	; 0x0b
    5138:	88 2f       	mov	r24, r24
    513a:	90 e0       	ldi	r25, 0x00	; 0
    513c:	2f 81       	ldd	r18, Y+7	; 0x07
    513e:	38 85       	ldd	r19, Y+8	; 0x08
    5140:	88 0f       	add	r24, r24
    5142:	99 1f       	adc	r25, r25
    5144:	88 0f       	add	r24, r24
    5146:	99 1f       	adc	r25, r25
    5148:	82 0f       	add	r24, r18
    514a:	93 1f       	adc	r25, r19
    514c:	fc 01       	movw	r30, r24
    514e:	b1 96       	adiw	r30, 0x21	; 33
    5150:	80 81       	ld	r24, Z
    5152:	91 81       	ldd	r25, Z+1	; 0x01
    5154:	a2 81       	ldd	r26, Z+2	; 0x02
    5156:	b3 81       	ldd	r27, Z+3	; 0x03
    5158:	e9 89       	ldd	r30, Y+17	; 0x11
    515a:	fa 89       	ldd	r31, Y+18	; 0x12
    515c:	80 83       	st	Z, r24
    515e:	91 83       	std	Z+1, r25	; 0x01
    5160:	a2 83       	std	Z+2, r26	; 0x02
    5162:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5164:	8b 85       	ldd	r24, Y+11	; 0x0b
    5166:	28 2f       	mov	r18, r24
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	8f 81       	ldd	r24, Y+7	; 0x07
    516c:	98 85       	ldd	r25, Y+8	; 0x08
    516e:	82 0f       	add	r24, r18
    5170:	93 1f       	adc	r25, r19
    5172:	fc 01       	movw	r30, r24
    5174:	b5 96       	adiw	r30, 0x25	; 37
    5176:	80 81       	ld	r24, Z
    5178:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    517a:	8b 85       	ldd	r24, Y+11	; 0x0b
    517c:	28 2f       	mov	r18, r24
    517e:	30 e0       	ldi	r19, 0x00	; 0
    5180:	8f 81       	ldd	r24, Y+7	; 0x07
    5182:	98 85       	ldd	r25, Y+8	; 0x08
    5184:	82 0f       	add	r24, r18
    5186:	93 1f       	adc	r25, r19
    5188:	fc 01       	movw	r30, r24
    518a:	b5 96       	adiw	r30, 0x25	; 37
    518c:	82 e0       	ldi	r24, 0x02	; 2
    518e:	80 83       	st	Z, r24

            switch( eAction )
    5190:	88 89       	ldd	r24, Y+16	; 0x10
    5192:	28 2f       	mov	r18, r24
    5194:	30 e0       	ldi	r19, 0x00	; 0
    5196:	3c 8b       	std	Y+20, r19	; 0x14
    5198:	2b 8b       	std	Y+19, r18	; 0x13
    519a:	8b 89       	ldd	r24, Y+19	; 0x13
    519c:	9c 89       	ldd	r25, Y+20	; 0x14
    519e:	82 30       	cpi	r24, 0x02	; 2
    51a0:	91 05       	cpc	r25, r1
    51a2:	09 f4       	brne	.+2      	; 0x51a6 <xTaskGenericNotify+0xba>
    51a4:	46 c0       	rjmp	.+140    	; 0x5232 <xTaskGenericNotify+0x146>
    51a6:	2b 89       	ldd	r18, Y+19	; 0x13
    51a8:	3c 89       	ldd	r19, Y+20	; 0x14
    51aa:	23 30       	cpi	r18, 0x03	; 3
    51ac:	31 05       	cpc	r19, r1
    51ae:	34 f4       	brge	.+12     	; 0x51bc <xTaskGenericNotify+0xd0>
    51b0:	8b 89       	ldd	r24, Y+19	; 0x13
    51b2:	9c 89       	ldd	r25, Y+20	; 0x14
    51b4:	81 30       	cpi	r24, 0x01	; 1
    51b6:	91 05       	cpc	r25, r1
    51b8:	71 f0       	breq	.+28     	; 0x51d6 <xTaskGenericNotify+0xea>
    51ba:	93 c0       	rjmp	.+294    	; 0x52e2 <xTaskGenericNotify+0x1f6>
    51bc:	2b 89       	ldd	r18, Y+19	; 0x13
    51be:	3c 89       	ldd	r19, Y+20	; 0x14
    51c0:	23 30       	cpi	r18, 0x03	; 3
    51c2:	31 05       	cpc	r19, r1
    51c4:	09 f4       	brne	.+2      	; 0x51c8 <xTaskGenericNotify+0xdc>
    51c6:	5d c0       	rjmp	.+186    	; 0x5282 <xTaskGenericNotify+0x196>
    51c8:	8b 89       	ldd	r24, Y+19	; 0x13
    51ca:	9c 89       	ldd	r25, Y+20	; 0x14
    51cc:	84 30       	cpi	r24, 0x04	; 4
    51ce:	91 05       	cpc	r25, r1
    51d0:	09 f4       	brne	.+2      	; 0x51d4 <xTaskGenericNotify+0xe8>
    51d2:	6d c0       	rjmp	.+218    	; 0x52ae <xTaskGenericNotify+0x1c2>
    51d4:	86 c0       	rjmp	.+268    	; 0x52e2 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    51d6:	8b 85       	ldd	r24, Y+11	; 0x0b
    51d8:	08 2f       	mov	r16, r24
    51da:	10 e0       	ldi	r17, 0x00	; 0
    51dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    51de:	88 2f       	mov	r24, r24
    51e0:	90 e0       	ldi	r25, 0x00	; 0
    51e2:	2f 81       	ldd	r18, Y+7	; 0x07
    51e4:	38 85       	ldd	r19, Y+8	; 0x08
    51e6:	88 0f       	add	r24, r24
    51e8:	99 1f       	adc	r25, r25
    51ea:	88 0f       	add	r24, r24
    51ec:	99 1f       	adc	r25, r25
    51ee:	82 0f       	add	r24, r18
    51f0:	93 1f       	adc	r25, r19
    51f2:	fc 01       	movw	r30, r24
    51f4:	b1 96       	adiw	r30, 0x21	; 33
    51f6:	20 81       	ld	r18, Z
    51f8:	31 81       	ldd	r19, Z+1	; 0x01
    51fa:	42 81       	ldd	r20, Z+2	; 0x02
    51fc:	53 81       	ldd	r21, Z+3	; 0x03
    51fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    5200:	9d 85       	ldd	r25, Y+13	; 0x0d
    5202:	ae 85       	ldd	r26, Y+14	; 0x0e
    5204:	bf 85       	ldd	r27, Y+15	; 0x0f
    5206:	ba 01       	movw	r22, r20
    5208:	a9 01       	movw	r20, r18
    520a:	48 2b       	or	r20, r24
    520c:	59 2b       	or	r21, r25
    520e:	6a 2b       	or	r22, r26
    5210:	7b 2b       	or	r23, r27
    5212:	2f 81       	ldd	r18, Y+7	; 0x07
    5214:	38 85       	ldd	r19, Y+8	; 0x08
    5216:	c8 01       	movw	r24, r16
    5218:	88 0f       	add	r24, r24
    521a:	99 1f       	adc	r25, r25
    521c:	88 0f       	add	r24, r24
    521e:	99 1f       	adc	r25, r25
    5220:	82 0f       	add	r24, r18
    5222:	93 1f       	adc	r25, r19
    5224:	fc 01       	movw	r30, r24
    5226:	b1 96       	adiw	r30, 0x21	; 33
    5228:	40 83       	st	Z, r20
    522a:	51 83       	std	Z+1, r21	; 0x01
    522c:	62 83       	std	Z+2, r22	; 0x02
    522e:	73 83       	std	Z+3, r23	; 0x03
    5230:	58 c0       	rjmp	.+176    	; 0x52e2 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5232:	8b 85       	ldd	r24, Y+11	; 0x0b
    5234:	08 2f       	mov	r16, r24
    5236:	10 e0       	ldi	r17, 0x00	; 0
    5238:	2f 81       	ldd	r18, Y+7	; 0x07
    523a:	38 85       	ldd	r19, Y+8	; 0x08
    523c:	c8 01       	movw	r24, r16
    523e:	88 0f       	add	r24, r24
    5240:	99 1f       	adc	r25, r25
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	82 0f       	add	r24, r18
    5248:	93 1f       	adc	r25, r19
    524a:	fc 01       	movw	r30, r24
    524c:	b1 96       	adiw	r30, 0x21	; 33
    524e:	80 81       	ld	r24, Z
    5250:	91 81       	ldd	r25, Z+1	; 0x01
    5252:	a2 81       	ldd	r26, Z+2	; 0x02
    5254:	b3 81       	ldd	r27, Z+3	; 0x03
    5256:	ac 01       	movw	r20, r24
    5258:	bd 01       	movw	r22, r26
    525a:	4f 5f       	subi	r20, 0xFF	; 255
    525c:	5f 4f       	sbci	r21, 0xFF	; 255
    525e:	6f 4f       	sbci	r22, 0xFF	; 255
    5260:	7f 4f       	sbci	r23, 0xFF	; 255
    5262:	2f 81       	ldd	r18, Y+7	; 0x07
    5264:	38 85       	ldd	r19, Y+8	; 0x08
    5266:	c8 01       	movw	r24, r16
    5268:	88 0f       	add	r24, r24
    526a:	99 1f       	adc	r25, r25
    526c:	88 0f       	add	r24, r24
    526e:	99 1f       	adc	r25, r25
    5270:	82 0f       	add	r24, r18
    5272:	93 1f       	adc	r25, r19
    5274:	fc 01       	movw	r30, r24
    5276:	b1 96       	adiw	r30, 0x21	; 33
    5278:	40 83       	st	Z, r20
    527a:	51 83       	std	Z+1, r21	; 0x01
    527c:	62 83       	std	Z+2, r22	; 0x02
    527e:	73 83       	std	Z+3, r23	; 0x03
    5280:	30 c0       	rjmp	.+96     	; 0x52e2 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5282:	8b 85       	ldd	r24, Y+11	; 0x0b
    5284:	88 2f       	mov	r24, r24
    5286:	90 e0       	ldi	r25, 0x00	; 0
    5288:	2f 81       	ldd	r18, Y+7	; 0x07
    528a:	38 85       	ldd	r19, Y+8	; 0x08
    528c:	88 0f       	add	r24, r24
    528e:	99 1f       	adc	r25, r25
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	82 0f       	add	r24, r18
    5296:	93 1f       	adc	r25, r19
    5298:	fc 01       	movw	r30, r24
    529a:	b1 96       	adiw	r30, 0x21	; 33
    529c:	8c 85       	ldd	r24, Y+12	; 0x0c
    529e:	9d 85       	ldd	r25, Y+13	; 0x0d
    52a0:	ae 85       	ldd	r26, Y+14	; 0x0e
    52a2:	bf 85       	ldd	r27, Y+15	; 0x0f
    52a4:	80 83       	st	Z, r24
    52a6:	91 83       	std	Z+1, r25	; 0x01
    52a8:	a2 83       	std	Z+2, r26	; 0x02
    52aa:	b3 83       	std	Z+3, r27	; 0x03
    52ac:	1a c0       	rjmp	.+52     	; 0x52e2 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    52ae:	8d 81       	ldd	r24, Y+5	; 0x05
    52b0:	82 30       	cpi	r24, 0x02	; 2
    52b2:	b1 f0       	breq	.+44     	; 0x52e0 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    52b4:	8b 85       	ldd	r24, Y+11	; 0x0b
    52b6:	88 2f       	mov	r24, r24
    52b8:	90 e0       	ldi	r25, 0x00	; 0
    52ba:	2f 81       	ldd	r18, Y+7	; 0x07
    52bc:	38 85       	ldd	r19, Y+8	; 0x08
    52be:	88 0f       	add	r24, r24
    52c0:	99 1f       	adc	r25, r25
    52c2:	88 0f       	add	r24, r24
    52c4:	99 1f       	adc	r25, r25
    52c6:	82 0f       	add	r24, r18
    52c8:	93 1f       	adc	r25, r19
    52ca:	fc 01       	movw	r30, r24
    52cc:	b1 96       	adiw	r30, 0x21	; 33
    52ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    52d0:	9d 85       	ldd	r25, Y+13	; 0x0d
    52d2:	ae 85       	ldd	r26, Y+14	; 0x0e
    52d4:	bf 85       	ldd	r27, Y+15	; 0x0f
    52d6:	80 83       	st	Z, r24
    52d8:	91 83       	std	Z+1, r25	; 0x01
    52da:	a2 83       	std	Z+2, r26	; 0x02
    52dc:	b3 83       	std	Z+3, r27	; 0x03
    52de:	01 c0       	rjmp	.+2      	; 0x52e2 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    52e0:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    52e2:	8d 81       	ldd	r24, Y+5	; 0x05
    52e4:	81 30       	cpi	r24, 0x01	; 1
    52e6:	09 f0       	breq	.+2      	; 0x52ea <xTaskGenericNotify+0x1fe>
    52e8:	af c0       	rjmp	.+350    	; 0x5448 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    52ea:	ef 81       	ldd	r30, Y+7	; 0x07
    52ec:	f8 85       	ldd	r31, Y+8	; 0x08
    52ee:	82 85       	ldd	r24, Z+10	; 0x0a
    52f0:	93 85       	ldd	r25, Z+11	; 0x0b
    52f2:	9c 83       	std	Y+4, r25	; 0x04
    52f4:	8b 83       	std	Y+3, r24	; 0x03
    52f6:	ef 81       	ldd	r30, Y+7	; 0x07
    52f8:	f8 85       	ldd	r31, Y+8	; 0x08
    52fa:	a4 81       	ldd	r26, Z+4	; 0x04
    52fc:	b5 81       	ldd	r27, Z+5	; 0x05
    52fe:	ef 81       	ldd	r30, Y+7	; 0x07
    5300:	f8 85       	ldd	r31, Y+8	; 0x08
    5302:	86 81       	ldd	r24, Z+6	; 0x06
    5304:	97 81       	ldd	r25, Z+7	; 0x07
    5306:	15 96       	adiw	r26, 0x05	; 5
    5308:	9c 93       	st	X, r25
    530a:	8e 93       	st	-X, r24
    530c:	14 97       	sbiw	r26, 0x04	; 4
    530e:	ef 81       	ldd	r30, Y+7	; 0x07
    5310:	f8 85       	ldd	r31, Y+8	; 0x08
    5312:	a6 81       	ldd	r26, Z+6	; 0x06
    5314:	b7 81       	ldd	r27, Z+7	; 0x07
    5316:	ef 81       	ldd	r30, Y+7	; 0x07
    5318:	f8 85       	ldd	r31, Y+8	; 0x08
    531a:	84 81       	ldd	r24, Z+4	; 0x04
    531c:	95 81       	ldd	r25, Z+5	; 0x05
    531e:	13 96       	adiw	r26, 0x03	; 3
    5320:	9c 93       	st	X, r25
    5322:	8e 93       	st	-X, r24
    5324:	12 97       	sbiw	r26, 0x02	; 2
    5326:	eb 81       	ldd	r30, Y+3	; 0x03
    5328:	fc 81       	ldd	r31, Y+4	; 0x04
    532a:	21 81       	ldd	r18, Z+1	; 0x01
    532c:	32 81       	ldd	r19, Z+2	; 0x02
    532e:	8f 81       	ldd	r24, Y+7	; 0x07
    5330:	98 85       	ldd	r25, Y+8	; 0x08
    5332:	02 96       	adiw	r24, 0x02	; 2
    5334:	28 17       	cp	r18, r24
    5336:	39 07       	cpc	r19, r25
    5338:	41 f4       	brne	.+16     	; 0x534a <xTaskGenericNotify+0x25e>
    533a:	ef 81       	ldd	r30, Y+7	; 0x07
    533c:	f8 85       	ldd	r31, Y+8	; 0x08
    533e:	86 81       	ldd	r24, Z+6	; 0x06
    5340:	97 81       	ldd	r25, Z+7	; 0x07
    5342:	eb 81       	ldd	r30, Y+3	; 0x03
    5344:	fc 81       	ldd	r31, Y+4	; 0x04
    5346:	92 83       	std	Z+2, r25	; 0x02
    5348:	81 83       	std	Z+1, r24	; 0x01
    534a:	ef 81       	ldd	r30, Y+7	; 0x07
    534c:	f8 85       	ldd	r31, Y+8	; 0x08
    534e:	13 86       	std	Z+11, r1	; 0x0b
    5350:	12 86       	std	Z+10, r1	; 0x0a
    5352:	eb 81       	ldd	r30, Y+3	; 0x03
    5354:	fc 81       	ldd	r31, Y+4	; 0x04
    5356:	80 81       	ld	r24, Z
    5358:	81 50       	subi	r24, 0x01	; 1
    535a:	eb 81       	ldd	r30, Y+3	; 0x03
    535c:	fc 81       	ldd	r31, Y+4	; 0x04
    535e:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    5360:	ef 81       	ldd	r30, Y+7	; 0x07
    5362:	f8 85       	ldd	r31, Y+8	; 0x08
    5364:	96 89       	ldd	r25, Z+22	; 0x16
    5366:	80 91 44 04 	lds	r24, 0x0444
    536a:	89 17       	cp	r24, r25
    536c:	28 f4       	brcc	.+10     	; 0x5378 <xTaskGenericNotify+0x28c>
    536e:	ef 81       	ldd	r30, Y+7	; 0x07
    5370:	f8 85       	ldd	r31, Y+8	; 0x08
    5372:	86 89       	ldd	r24, Z+22	; 0x16
    5374:	80 93 44 04 	sts	0x0444, r24
    5378:	ef 81       	ldd	r30, Y+7	; 0x07
    537a:	f8 85       	ldd	r31, Y+8	; 0x08
    537c:	86 89       	ldd	r24, Z+22	; 0x16
    537e:	28 2f       	mov	r18, r24
    5380:	30 e0       	ldi	r19, 0x00	; 0
    5382:	c9 01       	movw	r24, r18
    5384:	88 0f       	add	r24, r24
    5386:	99 1f       	adc	r25, r25
    5388:	88 0f       	add	r24, r24
    538a:	99 1f       	adc	r25, r25
    538c:	88 0f       	add	r24, r24
    538e:	99 1f       	adc	r25, r25
    5390:	82 0f       	add	r24, r18
    5392:	93 1f       	adc	r25, r19
    5394:	fc 01       	movw	r30, r24
    5396:	e0 5b       	subi	r30, 0xB0	; 176
    5398:	fb 4f       	sbci	r31, 0xFB	; 251
    539a:	81 81       	ldd	r24, Z+1	; 0x01
    539c:	92 81       	ldd	r25, Z+2	; 0x02
    539e:	9a 83       	std	Y+2, r25	; 0x02
    53a0:	89 83       	std	Y+1, r24	; 0x01
    53a2:	ef 81       	ldd	r30, Y+7	; 0x07
    53a4:	f8 85       	ldd	r31, Y+8	; 0x08
    53a6:	89 81       	ldd	r24, Y+1	; 0x01
    53a8:	9a 81       	ldd	r25, Y+2	; 0x02
    53aa:	95 83       	std	Z+5, r25	; 0x05
    53ac:	84 83       	std	Z+4, r24	; 0x04
    53ae:	e9 81       	ldd	r30, Y+1	; 0x01
    53b0:	fa 81       	ldd	r31, Y+2	; 0x02
    53b2:	84 81       	ldd	r24, Z+4	; 0x04
    53b4:	95 81       	ldd	r25, Z+5	; 0x05
    53b6:	ef 81       	ldd	r30, Y+7	; 0x07
    53b8:	f8 85       	ldd	r31, Y+8	; 0x08
    53ba:	97 83       	std	Z+7, r25	; 0x07
    53bc:	86 83       	std	Z+6, r24	; 0x06
    53be:	e9 81       	ldd	r30, Y+1	; 0x01
    53c0:	fa 81       	ldd	r31, Y+2	; 0x02
    53c2:	04 80       	ldd	r0, Z+4	; 0x04
    53c4:	f5 81       	ldd	r31, Z+5	; 0x05
    53c6:	e0 2d       	mov	r30, r0
    53c8:	8f 81       	ldd	r24, Y+7	; 0x07
    53ca:	98 85       	ldd	r25, Y+8	; 0x08
    53cc:	02 96       	adiw	r24, 0x02	; 2
    53ce:	93 83       	std	Z+3, r25	; 0x03
    53d0:	82 83       	std	Z+2, r24	; 0x02
    53d2:	8f 81       	ldd	r24, Y+7	; 0x07
    53d4:	98 85       	ldd	r25, Y+8	; 0x08
    53d6:	02 96       	adiw	r24, 0x02	; 2
    53d8:	e9 81       	ldd	r30, Y+1	; 0x01
    53da:	fa 81       	ldd	r31, Y+2	; 0x02
    53dc:	95 83       	std	Z+5, r25	; 0x05
    53de:	84 83       	std	Z+4, r24	; 0x04
    53e0:	ef 81       	ldd	r30, Y+7	; 0x07
    53e2:	f8 85       	ldd	r31, Y+8	; 0x08
    53e4:	86 89       	ldd	r24, Z+22	; 0x16
    53e6:	28 2f       	mov	r18, r24
    53e8:	30 e0       	ldi	r19, 0x00	; 0
    53ea:	c9 01       	movw	r24, r18
    53ec:	88 0f       	add	r24, r24
    53ee:	99 1f       	adc	r25, r25
    53f0:	88 0f       	add	r24, r24
    53f2:	99 1f       	adc	r25, r25
    53f4:	88 0f       	add	r24, r24
    53f6:	99 1f       	adc	r25, r25
    53f8:	82 0f       	add	r24, r18
    53fa:	93 1f       	adc	r25, r19
    53fc:	80 5b       	subi	r24, 0xB0	; 176
    53fe:	9b 4f       	sbci	r25, 0xFB	; 251
    5400:	ef 81       	ldd	r30, Y+7	; 0x07
    5402:	f8 85       	ldd	r31, Y+8	; 0x08
    5404:	93 87       	std	Z+11, r25	; 0x0b
    5406:	82 87       	std	Z+10, r24	; 0x0a
    5408:	ef 81       	ldd	r30, Y+7	; 0x07
    540a:	f8 85       	ldd	r31, Y+8	; 0x08
    540c:	86 89       	ldd	r24, Z+22	; 0x16
    540e:	28 2f       	mov	r18, r24
    5410:	30 e0       	ldi	r19, 0x00	; 0
    5412:	c9 01       	movw	r24, r18
    5414:	88 0f       	add	r24, r24
    5416:	99 1f       	adc	r25, r25
    5418:	88 0f       	add	r24, r24
    541a:	99 1f       	adc	r25, r25
    541c:	88 0f       	add	r24, r24
    541e:	99 1f       	adc	r25, r25
    5420:	82 0f       	add	r24, r18
    5422:	93 1f       	adc	r25, r19
    5424:	fc 01       	movw	r30, r24
    5426:	e0 5b       	subi	r30, 0xB0	; 176
    5428:	fb 4f       	sbci	r31, 0xFB	; 251
    542a:	80 81       	ld	r24, Z
    542c:	8f 5f       	subi	r24, 0xFF	; 255
    542e:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5430:	ef 81       	ldd	r30, Y+7	; 0x07
    5432:	f8 85       	ldd	r31, Y+8	; 0x08
    5434:	96 89       	ldd	r25, Z+22	; 0x16
    5436:	e0 91 3f 04 	lds	r30, 0x043F
    543a:	f0 91 40 04 	lds	r31, 0x0440
    543e:	86 89       	ldd	r24, Z+22	; 0x16
    5440:	89 17       	cp	r24, r25
    5442:	10 f4       	brcc	.+4      	; 0x5448 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    5444:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5448:	0f 90       	pop	r0
    544a:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    544c:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    544e:	64 96       	adiw	r28, 0x14	; 20
    5450:	0f b6       	in	r0, 0x3f	; 63
    5452:	f8 94       	cli
    5454:	de bf       	out	0x3e, r29	; 62
    5456:	0f be       	out	0x3f, r0	; 63
    5458:	cd bf       	out	0x3d, r28	; 61
    545a:	cf 91       	pop	r28
    545c:	df 91       	pop	r29
    545e:	1f 91       	pop	r17
    5460:	0f 91       	pop	r16
    5462:	ff 90       	pop	r15
    5464:	ef 90       	pop	r14
    5466:	08 95       	ret

00005468 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    5468:	cf 92       	push	r12
    546a:	df 92       	push	r13
    546c:	ef 92       	push	r14
    546e:	ff 92       	push	r15
    5470:	0f 93       	push	r16
    5472:	1f 93       	push	r17
    5474:	df 93       	push	r29
    5476:	cf 93       	push	r28
    5478:	cd b7       	in	r28, 0x3d	; 61
    547a:	de b7       	in	r29, 0x3e	; 62
    547c:	69 97       	sbiw	r28, 0x19	; 25
    547e:	0f b6       	in	r0, 0x3f	; 63
    5480:	f8 94       	cli
    5482:	de bf       	out	0x3e, r29	; 62
    5484:	0f be       	out	0x3f, r0	; 63
    5486:	cd bf       	out	0x3d, r28	; 61
    5488:	9d 87       	std	Y+13, r25	; 0x0d
    548a:	8c 87       	std	Y+12, r24	; 0x0c
    548c:	6e 87       	std	Y+14, r22	; 0x0e
    548e:	2f 87       	std	Y+15, r18	; 0x0f
    5490:	38 8b       	std	Y+16, r19	; 0x10
    5492:	49 8b       	std	Y+17, r20	; 0x11
    5494:	5a 8b       	std	Y+18, r21	; 0x12
    5496:	0b 8b       	std	Y+19, r16	; 0x13
    5498:	fd 8a       	std	Y+21, r15	; 0x15
    549a:	ec 8a       	std	Y+20, r14	; 0x14
    549c:	df 8a       	std	Y+23, r13	; 0x17
    549e:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    54a0:	81 e0       	ldi	r24, 0x01	; 1
    54a2:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    54a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    54a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    54a8:	9b 87       	std	Y+11, r25	; 0x0b
    54aa:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    54ac:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    54ae:	8c 89       	ldd	r24, Y+20	; 0x14
    54b0:	9d 89       	ldd	r25, Y+21	; 0x15
    54b2:	00 97       	sbiw	r24, 0x00	; 0
    54b4:	b9 f0       	breq	.+46     	; 0x54e4 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    54b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    54b8:	88 2f       	mov	r24, r24
    54ba:	90 e0       	ldi	r25, 0x00	; 0
    54bc:	2a 85       	ldd	r18, Y+10	; 0x0a
    54be:	3b 85       	ldd	r19, Y+11	; 0x0b
    54c0:	88 0f       	add	r24, r24
    54c2:	99 1f       	adc	r25, r25
    54c4:	88 0f       	add	r24, r24
    54c6:	99 1f       	adc	r25, r25
    54c8:	82 0f       	add	r24, r18
    54ca:	93 1f       	adc	r25, r19
    54cc:	fc 01       	movw	r30, r24
    54ce:	b1 96       	adiw	r30, 0x21	; 33
    54d0:	80 81       	ld	r24, Z
    54d2:	91 81       	ldd	r25, Z+1	; 0x01
    54d4:	a2 81       	ldd	r26, Z+2	; 0x02
    54d6:	b3 81       	ldd	r27, Z+3	; 0x03
    54d8:	ec 89       	ldd	r30, Y+20	; 0x14
    54da:	fd 89       	ldd	r31, Y+21	; 0x15
    54dc:	80 83       	st	Z, r24
    54de:	91 83       	std	Z+1, r25	; 0x01
    54e0:	a2 83       	std	Z+2, r26	; 0x02
    54e2:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    54e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    54e6:	28 2f       	mov	r18, r24
    54e8:	30 e0       	ldi	r19, 0x00	; 0
    54ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    54ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    54ee:	82 0f       	add	r24, r18
    54f0:	93 1f       	adc	r25, r19
    54f2:	fc 01       	movw	r30, r24
    54f4:	b5 96       	adiw	r30, 0x25	; 37
    54f6:	80 81       	ld	r24, Z
    54f8:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    54fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    54fc:	28 2f       	mov	r18, r24
    54fe:	30 e0       	ldi	r19, 0x00	; 0
    5500:	8a 85       	ldd	r24, Y+10	; 0x0a
    5502:	9b 85       	ldd	r25, Y+11	; 0x0b
    5504:	82 0f       	add	r24, r18
    5506:	93 1f       	adc	r25, r19
    5508:	fc 01       	movw	r30, r24
    550a:	b5 96       	adiw	r30, 0x25	; 37
    550c:	82 e0       	ldi	r24, 0x02	; 2
    550e:	80 83       	st	Z, r24

            switch( eAction )
    5510:	8b 89       	ldd	r24, Y+19	; 0x13
    5512:	28 2f       	mov	r18, r24
    5514:	30 e0       	ldi	r19, 0x00	; 0
    5516:	39 8f       	std	Y+25, r19	; 0x19
    5518:	28 8f       	std	Y+24, r18	; 0x18
    551a:	88 8d       	ldd	r24, Y+24	; 0x18
    551c:	99 8d       	ldd	r25, Y+25	; 0x19
    551e:	82 30       	cpi	r24, 0x02	; 2
    5520:	91 05       	cpc	r25, r1
    5522:	09 f4       	brne	.+2      	; 0x5526 <xTaskGenericNotifyFromISR+0xbe>
    5524:	46 c0       	rjmp	.+140    	; 0x55b2 <xTaskGenericNotifyFromISR+0x14a>
    5526:	28 8d       	ldd	r18, Y+24	; 0x18
    5528:	39 8d       	ldd	r19, Y+25	; 0x19
    552a:	23 30       	cpi	r18, 0x03	; 3
    552c:	31 05       	cpc	r19, r1
    552e:	34 f4       	brge	.+12     	; 0x553c <xTaskGenericNotifyFromISR+0xd4>
    5530:	88 8d       	ldd	r24, Y+24	; 0x18
    5532:	99 8d       	ldd	r25, Y+25	; 0x19
    5534:	81 30       	cpi	r24, 0x01	; 1
    5536:	91 05       	cpc	r25, r1
    5538:	71 f0       	breq	.+28     	; 0x5556 <xTaskGenericNotifyFromISR+0xee>
    553a:	93 c0       	rjmp	.+294    	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
    553c:	28 8d       	ldd	r18, Y+24	; 0x18
    553e:	39 8d       	ldd	r19, Y+25	; 0x19
    5540:	23 30       	cpi	r18, 0x03	; 3
    5542:	31 05       	cpc	r19, r1
    5544:	09 f4       	brne	.+2      	; 0x5548 <xTaskGenericNotifyFromISR+0xe0>
    5546:	5d c0       	rjmp	.+186    	; 0x5602 <xTaskGenericNotifyFromISR+0x19a>
    5548:	88 8d       	ldd	r24, Y+24	; 0x18
    554a:	99 8d       	ldd	r25, Y+25	; 0x19
    554c:	84 30       	cpi	r24, 0x04	; 4
    554e:	91 05       	cpc	r25, r1
    5550:	09 f4       	brne	.+2      	; 0x5554 <xTaskGenericNotifyFromISR+0xec>
    5552:	6d c0       	rjmp	.+218    	; 0x562e <xTaskGenericNotifyFromISR+0x1c6>
    5554:	86 c0       	rjmp	.+268    	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5556:	8e 85       	ldd	r24, Y+14	; 0x0e
    5558:	08 2f       	mov	r16, r24
    555a:	10 e0       	ldi	r17, 0x00	; 0
    555c:	8e 85       	ldd	r24, Y+14	; 0x0e
    555e:	88 2f       	mov	r24, r24
    5560:	90 e0       	ldi	r25, 0x00	; 0
    5562:	2a 85       	ldd	r18, Y+10	; 0x0a
    5564:	3b 85       	ldd	r19, Y+11	; 0x0b
    5566:	88 0f       	add	r24, r24
    5568:	99 1f       	adc	r25, r25
    556a:	88 0f       	add	r24, r24
    556c:	99 1f       	adc	r25, r25
    556e:	82 0f       	add	r24, r18
    5570:	93 1f       	adc	r25, r19
    5572:	fc 01       	movw	r30, r24
    5574:	b1 96       	adiw	r30, 0x21	; 33
    5576:	20 81       	ld	r18, Z
    5578:	31 81       	ldd	r19, Z+1	; 0x01
    557a:	42 81       	ldd	r20, Z+2	; 0x02
    557c:	53 81       	ldd	r21, Z+3	; 0x03
    557e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5580:	98 89       	ldd	r25, Y+16	; 0x10
    5582:	a9 89       	ldd	r26, Y+17	; 0x11
    5584:	ba 89       	ldd	r27, Y+18	; 0x12
    5586:	ba 01       	movw	r22, r20
    5588:	a9 01       	movw	r20, r18
    558a:	48 2b       	or	r20, r24
    558c:	59 2b       	or	r21, r25
    558e:	6a 2b       	or	r22, r26
    5590:	7b 2b       	or	r23, r27
    5592:	2a 85       	ldd	r18, Y+10	; 0x0a
    5594:	3b 85       	ldd	r19, Y+11	; 0x0b
    5596:	c8 01       	movw	r24, r16
    5598:	88 0f       	add	r24, r24
    559a:	99 1f       	adc	r25, r25
    559c:	88 0f       	add	r24, r24
    559e:	99 1f       	adc	r25, r25
    55a0:	82 0f       	add	r24, r18
    55a2:	93 1f       	adc	r25, r19
    55a4:	fc 01       	movw	r30, r24
    55a6:	b1 96       	adiw	r30, 0x21	; 33
    55a8:	40 83       	st	Z, r20
    55aa:	51 83       	std	Z+1, r21	; 0x01
    55ac:	62 83       	std	Z+2, r22	; 0x02
    55ae:	73 83       	std	Z+3, r23	; 0x03
    55b0:	58 c0       	rjmp	.+176    	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    55b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    55b4:	08 2f       	mov	r16, r24
    55b6:	10 e0       	ldi	r17, 0x00	; 0
    55b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    55ba:	3b 85       	ldd	r19, Y+11	; 0x0b
    55bc:	c8 01       	movw	r24, r16
    55be:	88 0f       	add	r24, r24
    55c0:	99 1f       	adc	r25, r25
    55c2:	88 0f       	add	r24, r24
    55c4:	99 1f       	adc	r25, r25
    55c6:	82 0f       	add	r24, r18
    55c8:	93 1f       	adc	r25, r19
    55ca:	fc 01       	movw	r30, r24
    55cc:	b1 96       	adiw	r30, 0x21	; 33
    55ce:	80 81       	ld	r24, Z
    55d0:	91 81       	ldd	r25, Z+1	; 0x01
    55d2:	a2 81       	ldd	r26, Z+2	; 0x02
    55d4:	b3 81       	ldd	r27, Z+3	; 0x03
    55d6:	ac 01       	movw	r20, r24
    55d8:	bd 01       	movw	r22, r26
    55da:	4f 5f       	subi	r20, 0xFF	; 255
    55dc:	5f 4f       	sbci	r21, 0xFF	; 255
    55de:	6f 4f       	sbci	r22, 0xFF	; 255
    55e0:	7f 4f       	sbci	r23, 0xFF	; 255
    55e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    55e4:	3b 85       	ldd	r19, Y+11	; 0x0b
    55e6:	c8 01       	movw	r24, r16
    55e8:	88 0f       	add	r24, r24
    55ea:	99 1f       	adc	r25, r25
    55ec:	88 0f       	add	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	82 0f       	add	r24, r18
    55f2:	93 1f       	adc	r25, r19
    55f4:	fc 01       	movw	r30, r24
    55f6:	b1 96       	adiw	r30, 0x21	; 33
    55f8:	40 83       	st	Z, r20
    55fa:	51 83       	std	Z+1, r21	; 0x01
    55fc:	62 83       	std	Z+2, r22	; 0x02
    55fe:	73 83       	std	Z+3, r23	; 0x03
    5600:	30 c0       	rjmp	.+96     	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5602:	8e 85       	ldd	r24, Y+14	; 0x0e
    5604:	88 2f       	mov	r24, r24
    5606:	90 e0       	ldi	r25, 0x00	; 0
    5608:	2a 85       	ldd	r18, Y+10	; 0x0a
    560a:	3b 85       	ldd	r19, Y+11	; 0x0b
    560c:	88 0f       	add	r24, r24
    560e:	99 1f       	adc	r25, r25
    5610:	88 0f       	add	r24, r24
    5612:	99 1f       	adc	r25, r25
    5614:	82 0f       	add	r24, r18
    5616:	93 1f       	adc	r25, r19
    5618:	fc 01       	movw	r30, r24
    561a:	b1 96       	adiw	r30, 0x21	; 33
    561c:	8f 85       	ldd	r24, Y+15	; 0x0f
    561e:	98 89       	ldd	r25, Y+16	; 0x10
    5620:	a9 89       	ldd	r26, Y+17	; 0x11
    5622:	ba 89       	ldd	r27, Y+18	; 0x12
    5624:	80 83       	st	Z, r24
    5626:	91 83       	std	Z+1, r25	; 0x01
    5628:	a2 83       	std	Z+2, r26	; 0x02
    562a:	b3 83       	std	Z+3, r27	; 0x03
    562c:	1a c0       	rjmp	.+52     	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    562e:	89 85       	ldd	r24, Y+9	; 0x09
    5630:	82 30       	cpi	r24, 0x02	; 2
    5632:	b1 f0       	breq	.+44     	; 0x5660 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5634:	8e 85       	ldd	r24, Y+14	; 0x0e
    5636:	88 2f       	mov	r24, r24
    5638:	90 e0       	ldi	r25, 0x00	; 0
    563a:	2a 85       	ldd	r18, Y+10	; 0x0a
    563c:	3b 85       	ldd	r19, Y+11	; 0x0b
    563e:	88 0f       	add	r24, r24
    5640:	99 1f       	adc	r25, r25
    5642:	88 0f       	add	r24, r24
    5644:	99 1f       	adc	r25, r25
    5646:	82 0f       	add	r24, r18
    5648:	93 1f       	adc	r25, r19
    564a:	fc 01       	movw	r30, r24
    564c:	b1 96       	adiw	r30, 0x21	; 33
    564e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5650:	98 89       	ldd	r25, Y+16	; 0x10
    5652:	a9 89       	ldd	r26, Y+17	; 0x11
    5654:	ba 89       	ldd	r27, Y+18	; 0x12
    5656:	80 83       	st	Z, r24
    5658:	91 83       	std	Z+1, r25	; 0x01
    565a:	a2 83       	std	Z+2, r26	; 0x02
    565c:	b3 83       	std	Z+3, r27	; 0x03
    565e:	01 c0       	rjmp	.+2      	; 0x5662 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5660:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5662:	89 85       	ldd	r24, Y+9	; 0x09
    5664:	81 30       	cpi	r24, 0x01	; 1
    5666:	09 f0       	breq	.+2      	; 0x566a <xTaskGenericNotifyFromISR+0x202>
    5668:	ee c0       	rjmp	.+476    	; 0x5846 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    566a:	80 91 4f 04 	lds	r24, 0x044F
    566e:	88 23       	and	r24, r24
    5670:	09 f0       	breq	.+2      	; 0x5674 <xTaskGenericNotifyFromISR+0x20c>
    5672:	a4 c0       	rjmp	.+328    	; 0x57bc <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5674:	ea 85       	ldd	r30, Y+10	; 0x0a
    5676:	fb 85       	ldd	r31, Y+11	; 0x0b
    5678:	82 85       	ldd	r24, Z+10	; 0x0a
    567a:	93 85       	ldd	r25, Z+11	; 0x0b
    567c:	9e 83       	std	Y+6, r25	; 0x06
    567e:	8d 83       	std	Y+5, r24	; 0x05
    5680:	ea 85       	ldd	r30, Y+10	; 0x0a
    5682:	fb 85       	ldd	r31, Y+11	; 0x0b
    5684:	a4 81       	ldd	r26, Z+4	; 0x04
    5686:	b5 81       	ldd	r27, Z+5	; 0x05
    5688:	ea 85       	ldd	r30, Y+10	; 0x0a
    568a:	fb 85       	ldd	r31, Y+11	; 0x0b
    568c:	86 81       	ldd	r24, Z+6	; 0x06
    568e:	97 81       	ldd	r25, Z+7	; 0x07
    5690:	15 96       	adiw	r26, 0x05	; 5
    5692:	9c 93       	st	X, r25
    5694:	8e 93       	st	-X, r24
    5696:	14 97       	sbiw	r26, 0x04	; 4
    5698:	ea 85       	ldd	r30, Y+10	; 0x0a
    569a:	fb 85       	ldd	r31, Y+11	; 0x0b
    569c:	a6 81       	ldd	r26, Z+6	; 0x06
    569e:	b7 81       	ldd	r27, Z+7	; 0x07
    56a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    56a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    56a4:	84 81       	ldd	r24, Z+4	; 0x04
    56a6:	95 81       	ldd	r25, Z+5	; 0x05
    56a8:	13 96       	adiw	r26, 0x03	; 3
    56aa:	9c 93       	st	X, r25
    56ac:	8e 93       	st	-X, r24
    56ae:	12 97       	sbiw	r26, 0x02	; 2
    56b0:	ed 81       	ldd	r30, Y+5	; 0x05
    56b2:	fe 81       	ldd	r31, Y+6	; 0x06
    56b4:	21 81       	ldd	r18, Z+1	; 0x01
    56b6:	32 81       	ldd	r19, Z+2	; 0x02
    56b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    56ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    56bc:	02 96       	adiw	r24, 0x02	; 2
    56be:	28 17       	cp	r18, r24
    56c0:	39 07       	cpc	r19, r25
    56c2:	41 f4       	brne	.+16     	; 0x56d4 <xTaskGenericNotifyFromISR+0x26c>
    56c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    56c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    56c8:	86 81       	ldd	r24, Z+6	; 0x06
    56ca:	97 81       	ldd	r25, Z+7	; 0x07
    56cc:	ed 81       	ldd	r30, Y+5	; 0x05
    56ce:	fe 81       	ldd	r31, Y+6	; 0x06
    56d0:	92 83       	std	Z+2, r25	; 0x02
    56d2:	81 83       	std	Z+1, r24	; 0x01
    56d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    56d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    56d8:	13 86       	std	Z+11, r1	; 0x0b
    56da:	12 86       	std	Z+10, r1	; 0x0a
    56dc:	ed 81       	ldd	r30, Y+5	; 0x05
    56de:	fe 81       	ldd	r31, Y+6	; 0x06
    56e0:	80 81       	ld	r24, Z
    56e2:	81 50       	subi	r24, 0x01	; 1
    56e4:	ed 81       	ldd	r30, Y+5	; 0x05
    56e6:	fe 81       	ldd	r31, Y+6	; 0x06
    56e8:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    56ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    56ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    56ee:	96 89       	ldd	r25, Z+22	; 0x16
    56f0:	80 91 44 04 	lds	r24, 0x0444
    56f4:	89 17       	cp	r24, r25
    56f6:	28 f4       	brcc	.+10     	; 0x5702 <xTaskGenericNotifyFromISR+0x29a>
    56f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    56fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    56fc:	86 89       	ldd	r24, Z+22	; 0x16
    56fe:	80 93 44 04 	sts	0x0444, r24
    5702:	ea 85       	ldd	r30, Y+10	; 0x0a
    5704:	fb 85       	ldd	r31, Y+11	; 0x0b
    5706:	86 89       	ldd	r24, Z+22	; 0x16
    5708:	28 2f       	mov	r18, r24
    570a:	30 e0       	ldi	r19, 0x00	; 0
    570c:	c9 01       	movw	r24, r18
    570e:	88 0f       	add	r24, r24
    5710:	99 1f       	adc	r25, r25
    5712:	88 0f       	add	r24, r24
    5714:	99 1f       	adc	r25, r25
    5716:	88 0f       	add	r24, r24
    5718:	99 1f       	adc	r25, r25
    571a:	82 0f       	add	r24, r18
    571c:	93 1f       	adc	r25, r19
    571e:	fc 01       	movw	r30, r24
    5720:	e0 5b       	subi	r30, 0xB0	; 176
    5722:	fb 4f       	sbci	r31, 0xFB	; 251
    5724:	81 81       	ldd	r24, Z+1	; 0x01
    5726:	92 81       	ldd	r25, Z+2	; 0x02
    5728:	9c 83       	std	Y+4, r25	; 0x04
    572a:	8b 83       	std	Y+3, r24	; 0x03
    572c:	ea 85       	ldd	r30, Y+10	; 0x0a
    572e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5730:	8b 81       	ldd	r24, Y+3	; 0x03
    5732:	9c 81       	ldd	r25, Y+4	; 0x04
    5734:	95 83       	std	Z+5, r25	; 0x05
    5736:	84 83       	std	Z+4, r24	; 0x04
    5738:	eb 81       	ldd	r30, Y+3	; 0x03
    573a:	fc 81       	ldd	r31, Y+4	; 0x04
    573c:	84 81       	ldd	r24, Z+4	; 0x04
    573e:	95 81       	ldd	r25, Z+5	; 0x05
    5740:	ea 85       	ldd	r30, Y+10	; 0x0a
    5742:	fb 85       	ldd	r31, Y+11	; 0x0b
    5744:	97 83       	std	Z+7, r25	; 0x07
    5746:	86 83       	std	Z+6, r24	; 0x06
    5748:	eb 81       	ldd	r30, Y+3	; 0x03
    574a:	fc 81       	ldd	r31, Y+4	; 0x04
    574c:	04 80       	ldd	r0, Z+4	; 0x04
    574e:	f5 81       	ldd	r31, Z+5	; 0x05
    5750:	e0 2d       	mov	r30, r0
    5752:	8a 85       	ldd	r24, Y+10	; 0x0a
    5754:	9b 85       	ldd	r25, Y+11	; 0x0b
    5756:	02 96       	adiw	r24, 0x02	; 2
    5758:	93 83       	std	Z+3, r25	; 0x03
    575a:	82 83       	std	Z+2, r24	; 0x02
    575c:	8a 85       	ldd	r24, Y+10	; 0x0a
    575e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5760:	02 96       	adiw	r24, 0x02	; 2
    5762:	eb 81       	ldd	r30, Y+3	; 0x03
    5764:	fc 81       	ldd	r31, Y+4	; 0x04
    5766:	95 83       	std	Z+5, r25	; 0x05
    5768:	84 83       	std	Z+4, r24	; 0x04
    576a:	ea 85       	ldd	r30, Y+10	; 0x0a
    576c:	fb 85       	ldd	r31, Y+11	; 0x0b
    576e:	86 89       	ldd	r24, Z+22	; 0x16
    5770:	28 2f       	mov	r18, r24
    5772:	30 e0       	ldi	r19, 0x00	; 0
    5774:	c9 01       	movw	r24, r18
    5776:	88 0f       	add	r24, r24
    5778:	99 1f       	adc	r25, r25
    577a:	88 0f       	add	r24, r24
    577c:	99 1f       	adc	r25, r25
    577e:	88 0f       	add	r24, r24
    5780:	99 1f       	adc	r25, r25
    5782:	82 0f       	add	r24, r18
    5784:	93 1f       	adc	r25, r19
    5786:	80 5b       	subi	r24, 0xB0	; 176
    5788:	9b 4f       	sbci	r25, 0xFB	; 251
    578a:	ea 85       	ldd	r30, Y+10	; 0x0a
    578c:	fb 85       	ldd	r31, Y+11	; 0x0b
    578e:	93 87       	std	Z+11, r25	; 0x0b
    5790:	82 87       	std	Z+10, r24	; 0x0a
    5792:	ea 85       	ldd	r30, Y+10	; 0x0a
    5794:	fb 85       	ldd	r31, Y+11	; 0x0b
    5796:	86 89       	ldd	r24, Z+22	; 0x16
    5798:	28 2f       	mov	r18, r24
    579a:	30 e0       	ldi	r19, 0x00	; 0
    579c:	c9 01       	movw	r24, r18
    579e:	88 0f       	add	r24, r24
    57a0:	99 1f       	adc	r25, r25
    57a2:	88 0f       	add	r24, r24
    57a4:	99 1f       	adc	r25, r25
    57a6:	88 0f       	add	r24, r24
    57a8:	99 1f       	adc	r25, r25
    57aa:	82 0f       	add	r24, r18
    57ac:	93 1f       	adc	r25, r19
    57ae:	fc 01       	movw	r30, r24
    57b0:	e0 5b       	subi	r30, 0xB0	; 176
    57b2:	fb 4f       	sbci	r31, 0xFB	; 251
    57b4:	80 81       	ld	r24, Z
    57b6:	8f 5f       	subi	r24, 0xFF	; 255
    57b8:	80 83       	st	Z, r24
    57ba:	30 c0       	rjmp	.+96     	; 0x581c <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    57bc:	80 91 8b 04 	lds	r24, 0x048B
    57c0:	90 91 8c 04 	lds	r25, 0x048C
    57c4:	9a 83       	std	Y+2, r25	; 0x02
    57c6:	89 83       	std	Y+1, r24	; 0x01
    57c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    57cc:	89 81       	ldd	r24, Y+1	; 0x01
    57ce:	9a 81       	ldd	r25, Y+2	; 0x02
    57d0:	97 87       	std	Z+15, r25	; 0x0f
    57d2:	86 87       	std	Z+14, r24	; 0x0e
    57d4:	e9 81       	ldd	r30, Y+1	; 0x01
    57d6:	fa 81       	ldd	r31, Y+2	; 0x02
    57d8:	84 81       	ldd	r24, Z+4	; 0x04
    57da:	95 81       	ldd	r25, Z+5	; 0x05
    57dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    57de:	fb 85       	ldd	r31, Y+11	; 0x0b
    57e0:	91 8b       	std	Z+17, r25	; 0x11
    57e2:	80 8b       	std	Z+16, r24	; 0x10
    57e4:	e9 81       	ldd	r30, Y+1	; 0x01
    57e6:	fa 81       	ldd	r31, Y+2	; 0x02
    57e8:	04 80       	ldd	r0, Z+4	; 0x04
    57ea:	f5 81       	ldd	r31, Z+5	; 0x05
    57ec:	e0 2d       	mov	r30, r0
    57ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    57f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    57f2:	0c 96       	adiw	r24, 0x0c	; 12
    57f4:	93 83       	std	Z+3, r25	; 0x03
    57f6:	82 83       	std	Z+2, r24	; 0x02
    57f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    57fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    57fc:	0c 96       	adiw	r24, 0x0c	; 12
    57fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5800:	fa 81       	ldd	r31, Y+2	; 0x02
    5802:	95 83       	std	Z+5, r25	; 0x05
    5804:	84 83       	std	Z+4, r24	; 0x04
    5806:	ea 85       	ldd	r30, Y+10	; 0x0a
    5808:	fb 85       	ldd	r31, Y+11	; 0x0b
    580a:	8a e8       	ldi	r24, 0x8A	; 138
    580c:	94 e0       	ldi	r25, 0x04	; 4
    580e:	95 8b       	std	Z+21, r25	; 0x15
    5810:	84 8b       	std	Z+20, r24	; 0x14
    5812:	80 91 8a 04 	lds	r24, 0x048A
    5816:	8f 5f       	subi	r24, 0xFF	; 255
    5818:	80 93 8a 04 	sts	0x048A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    581c:	ea 85       	ldd	r30, Y+10	; 0x0a
    581e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5820:	96 89       	ldd	r25, Z+22	; 0x16
    5822:	e0 91 3f 04 	lds	r30, 0x043F
    5826:	f0 91 40 04 	lds	r31, 0x0440
    582a:	86 89       	ldd	r24, Z+22	; 0x16
    582c:	89 17       	cp	r24, r25
    582e:	58 f4       	brcc	.+22     	; 0x5846 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5830:	8e 89       	ldd	r24, Y+22	; 0x16
    5832:	9f 89       	ldd	r25, Y+23	; 0x17
    5834:	00 97       	sbiw	r24, 0x00	; 0
    5836:	21 f0       	breq	.+8      	; 0x5840 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5838:	ee 89       	ldd	r30, Y+22	; 0x16
    583a:	ff 89       	ldd	r31, Y+23	; 0x17
    583c:	81 e0       	ldi	r24, 0x01	; 1
    583e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5840:	81 e0       	ldi	r24, 0x01	; 1
    5842:	80 93 48 04 	sts	0x0448, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5846:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5848:	69 96       	adiw	r28, 0x19	; 25
    584a:	0f b6       	in	r0, 0x3f	; 63
    584c:	f8 94       	cli
    584e:	de bf       	out	0x3e, r29	; 62
    5850:	0f be       	out	0x3f, r0	; 63
    5852:	cd bf       	out	0x3d, r28	; 61
    5854:	cf 91       	pop	r28
    5856:	df 91       	pop	r29
    5858:	1f 91       	pop	r17
    585a:	0f 91       	pop	r16
    585c:	ff 90       	pop	r15
    585e:	ef 90       	pop	r14
    5860:	df 90       	pop	r13
    5862:	cf 90       	pop	r12
    5864:	08 95       	ret

00005866 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5866:	0f 93       	push	r16
    5868:	1f 93       	push	r17
    586a:	df 93       	push	r29
    586c:	cf 93       	push	r28
    586e:	cd b7       	in	r28, 0x3d	; 61
    5870:	de b7       	in	r29, 0x3e	; 62
    5872:	2f 97       	sbiw	r28, 0x0f	; 15
    5874:	0f b6       	in	r0, 0x3f	; 63
    5876:	f8 94       	cli
    5878:	de bf       	out	0x3e, r29	; 62
    587a:	0f be       	out	0x3f, r0	; 63
    587c:	cd bf       	out	0x3d, r28	; 61
    587e:	9c 87       	std	Y+12, r25	; 0x0c
    5880:	8b 87       	std	Y+11, r24	; 0x0b
    5882:	6d 87       	std	Y+13, r22	; 0x0d
    5884:	5f 87       	std	Y+15, r21	; 0x0f
    5886:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5888:	8b 85       	ldd	r24, Y+11	; 0x0b
    588a:	9c 85       	ldd	r25, Y+12	; 0x0c
    588c:	9a 87       	std	Y+10, r25	; 0x0a
    588e:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5890:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5892:	8d 85       	ldd	r24, Y+13	; 0x0d
    5894:	28 2f       	mov	r18, r24
    5896:	30 e0       	ldi	r19, 0x00	; 0
    5898:	89 85       	ldd	r24, Y+9	; 0x09
    589a:	9a 85       	ldd	r25, Y+10	; 0x0a
    589c:	82 0f       	add	r24, r18
    589e:	93 1f       	adc	r25, r19
    58a0:	fc 01       	movw	r30, r24
    58a2:	b5 96       	adiw	r30, 0x25	; 37
    58a4:	80 81       	ld	r24, Z
    58a6:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    58a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    58aa:	28 2f       	mov	r18, r24
    58ac:	30 e0       	ldi	r19, 0x00	; 0
    58ae:	89 85       	ldd	r24, Y+9	; 0x09
    58b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    58b2:	82 0f       	add	r24, r18
    58b4:	93 1f       	adc	r25, r19
    58b6:	fc 01       	movw	r30, r24
    58b8:	b5 96       	adiw	r30, 0x25	; 37
    58ba:	82 e0       	ldi	r24, 0x02	; 2
    58bc:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    58be:	8d 85       	ldd	r24, Y+13	; 0x0d
    58c0:	08 2f       	mov	r16, r24
    58c2:	10 e0       	ldi	r17, 0x00	; 0
    58c4:	29 85       	ldd	r18, Y+9	; 0x09
    58c6:	3a 85       	ldd	r19, Y+10	; 0x0a
    58c8:	c8 01       	movw	r24, r16
    58ca:	88 0f       	add	r24, r24
    58cc:	99 1f       	adc	r25, r25
    58ce:	88 0f       	add	r24, r24
    58d0:	99 1f       	adc	r25, r25
    58d2:	82 0f       	add	r24, r18
    58d4:	93 1f       	adc	r25, r19
    58d6:	fc 01       	movw	r30, r24
    58d8:	b1 96       	adiw	r30, 0x21	; 33
    58da:	80 81       	ld	r24, Z
    58dc:	91 81       	ldd	r25, Z+1	; 0x01
    58de:	a2 81       	ldd	r26, Z+2	; 0x02
    58e0:	b3 81       	ldd	r27, Z+3	; 0x03
    58e2:	ac 01       	movw	r20, r24
    58e4:	bd 01       	movw	r22, r26
    58e6:	4f 5f       	subi	r20, 0xFF	; 255
    58e8:	5f 4f       	sbci	r21, 0xFF	; 255
    58ea:	6f 4f       	sbci	r22, 0xFF	; 255
    58ec:	7f 4f       	sbci	r23, 0xFF	; 255
    58ee:	29 85       	ldd	r18, Y+9	; 0x09
    58f0:	3a 85       	ldd	r19, Y+10	; 0x0a
    58f2:	c8 01       	movw	r24, r16
    58f4:	88 0f       	add	r24, r24
    58f6:	99 1f       	adc	r25, r25
    58f8:	88 0f       	add	r24, r24
    58fa:	99 1f       	adc	r25, r25
    58fc:	82 0f       	add	r24, r18
    58fe:	93 1f       	adc	r25, r19
    5900:	fc 01       	movw	r30, r24
    5902:	b1 96       	adiw	r30, 0x21	; 33
    5904:	40 83       	st	Z, r20
    5906:	51 83       	std	Z+1, r21	; 0x01
    5908:	62 83       	std	Z+2, r22	; 0x02
    590a:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    590c:	88 85       	ldd	r24, Y+8	; 0x08
    590e:	81 30       	cpi	r24, 0x01	; 1
    5910:	09 f0       	breq	.+2      	; 0x5914 <vTaskGenericNotifyGiveFromISR+0xae>
    5912:	ee c0       	rjmp	.+476    	; 0x5af0 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5914:	80 91 4f 04 	lds	r24, 0x044F
    5918:	88 23       	and	r24, r24
    591a:	09 f0       	breq	.+2      	; 0x591e <vTaskGenericNotifyGiveFromISR+0xb8>
    591c:	a4 c0       	rjmp	.+328    	; 0x5a66 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    591e:	e9 85       	ldd	r30, Y+9	; 0x09
    5920:	fa 85       	ldd	r31, Y+10	; 0x0a
    5922:	82 85       	ldd	r24, Z+10	; 0x0a
    5924:	93 85       	ldd	r25, Z+11	; 0x0b
    5926:	9e 83       	std	Y+6, r25	; 0x06
    5928:	8d 83       	std	Y+5, r24	; 0x05
    592a:	e9 85       	ldd	r30, Y+9	; 0x09
    592c:	fa 85       	ldd	r31, Y+10	; 0x0a
    592e:	a4 81       	ldd	r26, Z+4	; 0x04
    5930:	b5 81       	ldd	r27, Z+5	; 0x05
    5932:	e9 85       	ldd	r30, Y+9	; 0x09
    5934:	fa 85       	ldd	r31, Y+10	; 0x0a
    5936:	86 81       	ldd	r24, Z+6	; 0x06
    5938:	97 81       	ldd	r25, Z+7	; 0x07
    593a:	15 96       	adiw	r26, 0x05	; 5
    593c:	9c 93       	st	X, r25
    593e:	8e 93       	st	-X, r24
    5940:	14 97       	sbiw	r26, 0x04	; 4
    5942:	e9 85       	ldd	r30, Y+9	; 0x09
    5944:	fa 85       	ldd	r31, Y+10	; 0x0a
    5946:	a6 81       	ldd	r26, Z+6	; 0x06
    5948:	b7 81       	ldd	r27, Z+7	; 0x07
    594a:	e9 85       	ldd	r30, Y+9	; 0x09
    594c:	fa 85       	ldd	r31, Y+10	; 0x0a
    594e:	84 81       	ldd	r24, Z+4	; 0x04
    5950:	95 81       	ldd	r25, Z+5	; 0x05
    5952:	13 96       	adiw	r26, 0x03	; 3
    5954:	9c 93       	st	X, r25
    5956:	8e 93       	st	-X, r24
    5958:	12 97       	sbiw	r26, 0x02	; 2
    595a:	ed 81       	ldd	r30, Y+5	; 0x05
    595c:	fe 81       	ldd	r31, Y+6	; 0x06
    595e:	21 81       	ldd	r18, Z+1	; 0x01
    5960:	32 81       	ldd	r19, Z+2	; 0x02
    5962:	89 85       	ldd	r24, Y+9	; 0x09
    5964:	9a 85       	ldd	r25, Y+10	; 0x0a
    5966:	02 96       	adiw	r24, 0x02	; 2
    5968:	28 17       	cp	r18, r24
    596a:	39 07       	cpc	r19, r25
    596c:	41 f4       	brne	.+16     	; 0x597e <vTaskGenericNotifyGiveFromISR+0x118>
    596e:	e9 85       	ldd	r30, Y+9	; 0x09
    5970:	fa 85       	ldd	r31, Y+10	; 0x0a
    5972:	86 81       	ldd	r24, Z+6	; 0x06
    5974:	97 81       	ldd	r25, Z+7	; 0x07
    5976:	ed 81       	ldd	r30, Y+5	; 0x05
    5978:	fe 81       	ldd	r31, Y+6	; 0x06
    597a:	92 83       	std	Z+2, r25	; 0x02
    597c:	81 83       	std	Z+1, r24	; 0x01
    597e:	e9 85       	ldd	r30, Y+9	; 0x09
    5980:	fa 85       	ldd	r31, Y+10	; 0x0a
    5982:	13 86       	std	Z+11, r1	; 0x0b
    5984:	12 86       	std	Z+10, r1	; 0x0a
    5986:	ed 81       	ldd	r30, Y+5	; 0x05
    5988:	fe 81       	ldd	r31, Y+6	; 0x06
    598a:	80 81       	ld	r24, Z
    598c:	81 50       	subi	r24, 0x01	; 1
    598e:	ed 81       	ldd	r30, Y+5	; 0x05
    5990:	fe 81       	ldd	r31, Y+6	; 0x06
    5992:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5994:	e9 85       	ldd	r30, Y+9	; 0x09
    5996:	fa 85       	ldd	r31, Y+10	; 0x0a
    5998:	96 89       	ldd	r25, Z+22	; 0x16
    599a:	80 91 44 04 	lds	r24, 0x0444
    599e:	89 17       	cp	r24, r25
    59a0:	28 f4       	brcc	.+10     	; 0x59ac <vTaskGenericNotifyGiveFromISR+0x146>
    59a2:	e9 85       	ldd	r30, Y+9	; 0x09
    59a4:	fa 85       	ldd	r31, Y+10	; 0x0a
    59a6:	86 89       	ldd	r24, Z+22	; 0x16
    59a8:	80 93 44 04 	sts	0x0444, r24
    59ac:	e9 85       	ldd	r30, Y+9	; 0x09
    59ae:	fa 85       	ldd	r31, Y+10	; 0x0a
    59b0:	86 89       	ldd	r24, Z+22	; 0x16
    59b2:	28 2f       	mov	r18, r24
    59b4:	30 e0       	ldi	r19, 0x00	; 0
    59b6:	c9 01       	movw	r24, r18
    59b8:	88 0f       	add	r24, r24
    59ba:	99 1f       	adc	r25, r25
    59bc:	88 0f       	add	r24, r24
    59be:	99 1f       	adc	r25, r25
    59c0:	88 0f       	add	r24, r24
    59c2:	99 1f       	adc	r25, r25
    59c4:	82 0f       	add	r24, r18
    59c6:	93 1f       	adc	r25, r19
    59c8:	fc 01       	movw	r30, r24
    59ca:	e0 5b       	subi	r30, 0xB0	; 176
    59cc:	fb 4f       	sbci	r31, 0xFB	; 251
    59ce:	81 81       	ldd	r24, Z+1	; 0x01
    59d0:	92 81       	ldd	r25, Z+2	; 0x02
    59d2:	9c 83       	std	Y+4, r25	; 0x04
    59d4:	8b 83       	std	Y+3, r24	; 0x03
    59d6:	e9 85       	ldd	r30, Y+9	; 0x09
    59d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    59da:	8b 81       	ldd	r24, Y+3	; 0x03
    59dc:	9c 81       	ldd	r25, Y+4	; 0x04
    59de:	95 83       	std	Z+5, r25	; 0x05
    59e0:	84 83       	std	Z+4, r24	; 0x04
    59e2:	eb 81       	ldd	r30, Y+3	; 0x03
    59e4:	fc 81       	ldd	r31, Y+4	; 0x04
    59e6:	84 81       	ldd	r24, Z+4	; 0x04
    59e8:	95 81       	ldd	r25, Z+5	; 0x05
    59ea:	e9 85       	ldd	r30, Y+9	; 0x09
    59ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    59ee:	97 83       	std	Z+7, r25	; 0x07
    59f0:	86 83       	std	Z+6, r24	; 0x06
    59f2:	eb 81       	ldd	r30, Y+3	; 0x03
    59f4:	fc 81       	ldd	r31, Y+4	; 0x04
    59f6:	04 80       	ldd	r0, Z+4	; 0x04
    59f8:	f5 81       	ldd	r31, Z+5	; 0x05
    59fa:	e0 2d       	mov	r30, r0
    59fc:	89 85       	ldd	r24, Y+9	; 0x09
    59fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a00:	02 96       	adiw	r24, 0x02	; 2
    5a02:	93 83       	std	Z+3, r25	; 0x03
    5a04:	82 83       	std	Z+2, r24	; 0x02
    5a06:	89 85       	ldd	r24, Y+9	; 0x09
    5a08:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a0a:	02 96       	adiw	r24, 0x02	; 2
    5a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a10:	95 83       	std	Z+5, r25	; 0x05
    5a12:	84 83       	std	Z+4, r24	; 0x04
    5a14:	e9 85       	ldd	r30, Y+9	; 0x09
    5a16:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a18:	86 89       	ldd	r24, Z+22	; 0x16
    5a1a:	28 2f       	mov	r18, r24
    5a1c:	30 e0       	ldi	r19, 0x00	; 0
    5a1e:	c9 01       	movw	r24, r18
    5a20:	88 0f       	add	r24, r24
    5a22:	99 1f       	adc	r25, r25
    5a24:	88 0f       	add	r24, r24
    5a26:	99 1f       	adc	r25, r25
    5a28:	88 0f       	add	r24, r24
    5a2a:	99 1f       	adc	r25, r25
    5a2c:	82 0f       	add	r24, r18
    5a2e:	93 1f       	adc	r25, r19
    5a30:	80 5b       	subi	r24, 0xB0	; 176
    5a32:	9b 4f       	sbci	r25, 0xFB	; 251
    5a34:	e9 85       	ldd	r30, Y+9	; 0x09
    5a36:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a38:	93 87       	std	Z+11, r25	; 0x0b
    5a3a:	82 87       	std	Z+10, r24	; 0x0a
    5a3c:	e9 85       	ldd	r30, Y+9	; 0x09
    5a3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a40:	86 89       	ldd	r24, Z+22	; 0x16
    5a42:	28 2f       	mov	r18, r24
    5a44:	30 e0       	ldi	r19, 0x00	; 0
    5a46:	c9 01       	movw	r24, r18
    5a48:	88 0f       	add	r24, r24
    5a4a:	99 1f       	adc	r25, r25
    5a4c:	88 0f       	add	r24, r24
    5a4e:	99 1f       	adc	r25, r25
    5a50:	88 0f       	add	r24, r24
    5a52:	99 1f       	adc	r25, r25
    5a54:	82 0f       	add	r24, r18
    5a56:	93 1f       	adc	r25, r19
    5a58:	fc 01       	movw	r30, r24
    5a5a:	e0 5b       	subi	r30, 0xB0	; 176
    5a5c:	fb 4f       	sbci	r31, 0xFB	; 251
    5a5e:	80 81       	ld	r24, Z
    5a60:	8f 5f       	subi	r24, 0xFF	; 255
    5a62:	80 83       	st	Z, r24
    5a64:	30 c0       	rjmp	.+96     	; 0x5ac6 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5a66:	80 91 8b 04 	lds	r24, 0x048B
    5a6a:	90 91 8c 04 	lds	r25, 0x048C
    5a6e:	9a 83       	std	Y+2, r25	; 0x02
    5a70:	89 83       	std	Y+1, r24	; 0x01
    5a72:	e9 85       	ldd	r30, Y+9	; 0x09
    5a74:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a76:	89 81       	ldd	r24, Y+1	; 0x01
    5a78:	9a 81       	ldd	r25, Y+2	; 0x02
    5a7a:	97 87       	std	Z+15, r25	; 0x0f
    5a7c:	86 87       	std	Z+14, r24	; 0x0e
    5a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    5a80:	fa 81       	ldd	r31, Y+2	; 0x02
    5a82:	84 81       	ldd	r24, Z+4	; 0x04
    5a84:	95 81       	ldd	r25, Z+5	; 0x05
    5a86:	e9 85       	ldd	r30, Y+9	; 0x09
    5a88:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a8a:	91 8b       	std	Z+17, r25	; 0x11
    5a8c:	80 8b       	std	Z+16, r24	; 0x10
    5a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    5a90:	fa 81       	ldd	r31, Y+2	; 0x02
    5a92:	04 80       	ldd	r0, Z+4	; 0x04
    5a94:	f5 81       	ldd	r31, Z+5	; 0x05
    5a96:	e0 2d       	mov	r30, r0
    5a98:	89 85       	ldd	r24, Y+9	; 0x09
    5a9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a9c:	0c 96       	adiw	r24, 0x0c	; 12
    5a9e:	93 83       	std	Z+3, r25	; 0x03
    5aa0:	82 83       	std	Z+2, r24	; 0x02
    5aa2:	89 85       	ldd	r24, Y+9	; 0x09
    5aa4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5aa6:	0c 96       	adiw	r24, 0x0c	; 12
    5aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    5aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    5aac:	95 83       	std	Z+5, r25	; 0x05
    5aae:	84 83       	std	Z+4, r24	; 0x04
    5ab0:	e9 85       	ldd	r30, Y+9	; 0x09
    5ab2:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ab4:	8a e8       	ldi	r24, 0x8A	; 138
    5ab6:	94 e0       	ldi	r25, 0x04	; 4
    5ab8:	95 8b       	std	Z+21, r25	; 0x15
    5aba:	84 8b       	std	Z+20, r24	; 0x14
    5abc:	80 91 8a 04 	lds	r24, 0x048A
    5ac0:	8f 5f       	subi	r24, 0xFF	; 255
    5ac2:	80 93 8a 04 	sts	0x048A, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ac6:	e9 85       	ldd	r30, Y+9	; 0x09
    5ac8:	fa 85       	ldd	r31, Y+10	; 0x0a
    5aca:	96 89       	ldd	r25, Z+22	; 0x16
    5acc:	e0 91 3f 04 	lds	r30, 0x043F
    5ad0:	f0 91 40 04 	lds	r31, 0x0440
    5ad4:	86 89       	ldd	r24, Z+22	; 0x16
    5ad6:	89 17       	cp	r24, r25
    5ad8:	58 f4       	brcc	.+22     	; 0x5af0 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5ada:	8e 85       	ldd	r24, Y+14	; 0x0e
    5adc:	9f 85       	ldd	r25, Y+15	; 0x0f
    5ade:	00 97       	sbiw	r24, 0x00	; 0
    5ae0:	21 f0       	breq	.+8      	; 0x5aea <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5ae2:	ee 85       	ldd	r30, Y+14	; 0x0e
    5ae4:	ff 85       	ldd	r31, Y+15	; 0x0f
    5ae6:	81 e0       	ldi	r24, 0x01	; 1
    5ae8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5aea:	81 e0       	ldi	r24, 0x01	; 1
    5aec:	80 93 48 04 	sts	0x0448, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5af0:	2f 96       	adiw	r28, 0x0f	; 15
    5af2:	0f b6       	in	r0, 0x3f	; 63
    5af4:	f8 94       	cli
    5af6:	de bf       	out	0x3e, r29	; 62
    5af8:	0f be       	out	0x3f, r0	; 63
    5afa:	cd bf       	out	0x3d, r28	; 61
    5afc:	cf 91       	pop	r28
    5afe:	df 91       	pop	r29
    5b00:	1f 91       	pop	r17
    5b02:	0f 91       	pop	r16
    5b04:	08 95       	ret

00005b06 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5b06:	df 93       	push	r29
    5b08:	cf 93       	push	r28
    5b0a:	cd b7       	in	r28, 0x3d	; 61
    5b0c:	de b7       	in	r29, 0x3e	; 62
    5b0e:	28 97       	sbiw	r28, 0x08	; 8
    5b10:	0f b6       	in	r0, 0x3f	; 63
    5b12:	f8 94       	cli
    5b14:	de bf       	out	0x3e, r29	; 62
    5b16:	0f be       	out	0x3f, r0	; 63
    5b18:	cd bf       	out	0x3d, r28	; 61
    5b1a:	9d 83       	std	Y+5, r25	; 0x05
    5b1c:	8c 83       	std	Y+4, r24	; 0x04
    5b1e:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5b20:	8c 81       	ldd	r24, Y+4	; 0x04
    5b22:	9d 81       	ldd	r25, Y+5	; 0x05
    5b24:	00 97       	sbiw	r24, 0x00	; 0
    5b26:	39 f4       	brne	.+14     	; 0x5b36 <xTaskGenericNotifyStateClear+0x30>
    5b28:	80 91 3f 04 	lds	r24, 0x043F
    5b2c:	90 91 40 04 	lds	r25, 0x0440
    5b30:	98 87       	std	Y+8, r25	; 0x08
    5b32:	8f 83       	std	Y+7, r24	; 0x07
    5b34:	04 c0       	rjmp	.+8      	; 0x5b3e <xTaskGenericNotifyStateClear+0x38>
    5b36:	8c 81       	ldd	r24, Y+4	; 0x04
    5b38:	9d 81       	ldd	r25, Y+5	; 0x05
    5b3a:	98 87       	std	Y+8, r25	; 0x08
    5b3c:	8f 83       	std	Y+7, r24	; 0x07
    5b3e:	8f 81       	ldd	r24, Y+7	; 0x07
    5b40:	98 85       	ldd	r25, Y+8	; 0x08
    5b42:	9b 83       	std	Y+3, r25	; 0x03
    5b44:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5b46:	0f b6       	in	r0, 0x3f	; 63
    5b48:	f8 94       	cli
    5b4a:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5b4c:	8e 81       	ldd	r24, Y+6	; 0x06
    5b4e:	28 2f       	mov	r18, r24
    5b50:	30 e0       	ldi	r19, 0x00	; 0
    5b52:	8a 81       	ldd	r24, Y+2	; 0x02
    5b54:	9b 81       	ldd	r25, Y+3	; 0x03
    5b56:	82 0f       	add	r24, r18
    5b58:	93 1f       	adc	r25, r19
    5b5a:	fc 01       	movw	r30, r24
    5b5c:	b5 96       	adiw	r30, 0x25	; 37
    5b5e:	80 81       	ld	r24, Z
    5b60:	82 30       	cpi	r24, 0x02	; 2
    5b62:	69 f4       	brne	.+26     	; 0x5b7e <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5b64:	8e 81       	ldd	r24, Y+6	; 0x06
    5b66:	28 2f       	mov	r18, r24
    5b68:	30 e0       	ldi	r19, 0x00	; 0
    5b6a:	8a 81       	ldd	r24, Y+2	; 0x02
    5b6c:	9b 81       	ldd	r25, Y+3	; 0x03
    5b6e:	82 0f       	add	r24, r18
    5b70:	93 1f       	adc	r25, r19
    5b72:	fc 01       	movw	r30, r24
    5b74:	b5 96       	adiw	r30, 0x25	; 37
    5b76:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5b78:	81 e0       	ldi	r24, 0x01	; 1
    5b7a:	89 83       	std	Y+1, r24	; 0x01
    5b7c:	01 c0       	rjmp	.+2      	; 0x5b80 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5b7e:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5b80:	0f 90       	pop	r0
    5b82:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5b84:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5b86:	28 96       	adiw	r28, 0x08	; 8
    5b88:	0f b6       	in	r0, 0x3f	; 63
    5b8a:	f8 94       	cli
    5b8c:	de bf       	out	0x3e, r29	; 62
    5b8e:	0f be       	out	0x3f, r0	; 63
    5b90:	cd bf       	out	0x3d, r28	; 61
    5b92:	cf 91       	pop	r28
    5b94:	df 91       	pop	r29
    5b96:	08 95       	ret

00005b98 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5b98:	0f 93       	push	r16
    5b9a:	1f 93       	push	r17
    5b9c:	df 93       	push	r29
    5b9e:	cf 93       	push	r28
    5ba0:	cd b7       	in	r28, 0x3d	; 61
    5ba2:	de b7       	in	r29, 0x3e	; 62
    5ba4:	2f 97       	sbiw	r28, 0x0f	; 15
    5ba6:	0f b6       	in	r0, 0x3f	; 63
    5ba8:	f8 94       	cli
    5baa:	de bf       	out	0x3e, r29	; 62
    5bac:	0f be       	out	0x3f, r0	; 63
    5bae:	cd bf       	out	0x3d, r28	; 61
    5bb0:	98 87       	std	Y+8, r25	; 0x08
    5bb2:	8f 83       	std	Y+7, r24	; 0x07
    5bb4:	69 87       	std	Y+9, r22	; 0x09
    5bb6:	2a 87       	std	Y+10, r18	; 0x0a
    5bb8:	3b 87       	std	Y+11, r19	; 0x0b
    5bba:	4c 87       	std	Y+12, r20	; 0x0c
    5bbc:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5bbe:	8f 81       	ldd	r24, Y+7	; 0x07
    5bc0:	98 85       	ldd	r25, Y+8	; 0x08
    5bc2:	00 97       	sbiw	r24, 0x00	; 0
    5bc4:	39 f4       	brne	.+14     	; 0x5bd4 <ulTaskGenericNotifyValueClear+0x3c>
    5bc6:	80 91 3f 04 	lds	r24, 0x043F
    5bca:	90 91 40 04 	lds	r25, 0x0440
    5bce:	9f 87       	std	Y+15, r25	; 0x0f
    5bd0:	8e 87       	std	Y+14, r24	; 0x0e
    5bd2:	04 c0       	rjmp	.+8      	; 0x5bdc <ulTaskGenericNotifyValueClear+0x44>
    5bd4:	8f 81       	ldd	r24, Y+7	; 0x07
    5bd6:	98 85       	ldd	r25, Y+8	; 0x08
    5bd8:	9f 87       	std	Y+15, r25	; 0x0f
    5bda:	8e 87       	std	Y+14, r24	; 0x0e
    5bdc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5bde:	9f 85       	ldd	r25, Y+15	; 0x0f
    5be0:	9e 83       	std	Y+6, r25	; 0x06
    5be2:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5be4:	0f b6       	in	r0, 0x3f	; 63
    5be6:	f8 94       	cli
    5be8:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5bea:	89 85       	ldd	r24, Y+9	; 0x09
    5bec:	88 2f       	mov	r24, r24
    5bee:	90 e0       	ldi	r25, 0x00	; 0
    5bf0:	2d 81       	ldd	r18, Y+5	; 0x05
    5bf2:	3e 81       	ldd	r19, Y+6	; 0x06
    5bf4:	88 0f       	add	r24, r24
    5bf6:	99 1f       	adc	r25, r25
    5bf8:	88 0f       	add	r24, r24
    5bfa:	99 1f       	adc	r25, r25
    5bfc:	82 0f       	add	r24, r18
    5bfe:	93 1f       	adc	r25, r19
    5c00:	fc 01       	movw	r30, r24
    5c02:	b1 96       	adiw	r30, 0x21	; 33
    5c04:	80 81       	ld	r24, Z
    5c06:	91 81       	ldd	r25, Z+1	; 0x01
    5c08:	a2 81       	ldd	r26, Z+2	; 0x02
    5c0a:	b3 81       	ldd	r27, Z+3	; 0x03
    5c0c:	89 83       	std	Y+1, r24	; 0x01
    5c0e:	9a 83       	std	Y+2, r25	; 0x02
    5c10:	ab 83       	std	Y+3, r26	; 0x03
    5c12:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5c14:	89 85       	ldd	r24, Y+9	; 0x09
    5c16:	08 2f       	mov	r16, r24
    5c18:	10 e0       	ldi	r17, 0x00	; 0
    5c1a:	89 85       	ldd	r24, Y+9	; 0x09
    5c1c:	88 2f       	mov	r24, r24
    5c1e:	90 e0       	ldi	r25, 0x00	; 0
    5c20:	2d 81       	ldd	r18, Y+5	; 0x05
    5c22:	3e 81       	ldd	r19, Y+6	; 0x06
    5c24:	88 0f       	add	r24, r24
    5c26:	99 1f       	adc	r25, r25
    5c28:	88 0f       	add	r24, r24
    5c2a:	99 1f       	adc	r25, r25
    5c2c:	82 0f       	add	r24, r18
    5c2e:	93 1f       	adc	r25, r19
    5c30:	fc 01       	movw	r30, r24
    5c32:	b1 96       	adiw	r30, 0x21	; 33
    5c34:	20 81       	ld	r18, Z
    5c36:	31 81       	ldd	r19, Z+1	; 0x01
    5c38:	42 81       	ldd	r20, Z+2	; 0x02
    5c3a:	53 81       	ldd	r21, Z+3	; 0x03
    5c3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c40:	ac 85       	ldd	r26, Y+12	; 0x0c
    5c42:	bd 85       	ldd	r27, Y+13	; 0x0d
    5c44:	80 95       	com	r24
    5c46:	90 95       	com	r25
    5c48:	a0 95       	com	r26
    5c4a:	b0 95       	com	r27
    5c4c:	ba 01       	movw	r22, r20
    5c4e:	a9 01       	movw	r20, r18
    5c50:	48 23       	and	r20, r24
    5c52:	59 23       	and	r21, r25
    5c54:	6a 23       	and	r22, r26
    5c56:	7b 23       	and	r23, r27
    5c58:	2d 81       	ldd	r18, Y+5	; 0x05
    5c5a:	3e 81       	ldd	r19, Y+6	; 0x06
    5c5c:	c8 01       	movw	r24, r16
    5c5e:	88 0f       	add	r24, r24
    5c60:	99 1f       	adc	r25, r25
    5c62:	88 0f       	add	r24, r24
    5c64:	99 1f       	adc	r25, r25
    5c66:	82 0f       	add	r24, r18
    5c68:	93 1f       	adc	r25, r19
    5c6a:	fc 01       	movw	r30, r24
    5c6c:	b1 96       	adiw	r30, 0x21	; 33
    5c6e:	40 83       	st	Z, r20
    5c70:	51 83       	std	Z+1, r21	; 0x01
    5c72:	62 83       	std	Z+2, r22	; 0x02
    5c74:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5c76:	0f 90       	pop	r0
    5c78:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5c7a:	89 81       	ldd	r24, Y+1	; 0x01
    5c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5c7e:	ab 81       	ldd	r26, Y+3	; 0x03
    5c80:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5c82:	bc 01       	movw	r22, r24
    5c84:	cd 01       	movw	r24, r26
    5c86:	2f 96       	adiw	r28, 0x0f	; 15
    5c88:	0f b6       	in	r0, 0x3f	; 63
    5c8a:	f8 94       	cli
    5c8c:	de bf       	out	0x3e, r29	; 62
    5c8e:	0f be       	out	0x3f, r0	; 63
    5c90:	cd bf       	out	0x3d, r28	; 61
    5c92:	cf 91       	pop	r28
    5c94:	df 91       	pop	r29
    5c96:	1f 91       	pop	r17
    5c98:	0f 91       	pop	r16
    5c9a:	08 95       	ret

00005c9c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5c9c:	df 93       	push	r29
    5c9e:	cf 93       	push	r28
    5ca0:	cd b7       	in	r28, 0x3d	; 61
    5ca2:	de b7       	in	r29, 0x3e	; 62
    5ca4:	27 97       	sbiw	r28, 0x07	; 7
    5ca6:	0f b6       	in	r0, 0x3f	; 63
    5ca8:	f8 94       	cli
    5caa:	de bf       	out	0x3e, r29	; 62
    5cac:	0f be       	out	0x3f, r0	; 63
    5cae:	cd bf       	out	0x3d, r28	; 61
    5cb0:	9e 83       	std	Y+6, r25	; 0x06
    5cb2:	8d 83       	std	Y+5, r24	; 0x05
    5cb4:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5cb6:	80 91 42 04 	lds	r24, 0x0442
    5cba:	90 91 43 04 	lds	r25, 0x0443
    5cbe:	9a 83       	std	Y+2, r25	; 0x02
    5cc0:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5cc2:	80 91 3f 04 	lds	r24, 0x043F
    5cc6:	90 91 40 04 	lds	r25, 0x0440
    5cca:	02 96       	adiw	r24, 0x02	; 2
    5ccc:	0e 94 16 13 	call	0x262c	; 0x262c <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5cd0:	29 81       	ldd	r18, Y+1	; 0x01
    5cd2:	3a 81       	ldd	r19, Y+2	; 0x02
    5cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    5cd6:	9e 81       	ldd	r25, Y+6	; 0x06
    5cd8:	82 0f       	add	r24, r18
    5cda:	93 1f       	adc	r25, r19
    5cdc:	9c 83       	std	Y+4, r25	; 0x04
    5cde:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5ce0:	e0 91 3f 04 	lds	r30, 0x043F
    5ce4:	f0 91 40 04 	lds	r31, 0x0440
    5ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    5cea:	9c 81       	ldd	r25, Y+4	; 0x04
    5cec:	93 83       	std	Z+3, r25	; 0x03
    5cee:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5cf0:	2b 81       	ldd	r18, Y+3	; 0x03
    5cf2:	3c 81       	ldd	r19, Y+4	; 0x04
    5cf4:	89 81       	ldd	r24, Y+1	; 0x01
    5cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cf8:	28 17       	cp	r18, r24
    5cfa:	39 07       	cpc	r19, r25
    5cfc:	70 f4       	brcc	.+28     	; 0x5d1a <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5cfe:	80 91 88 04 	lds	r24, 0x0488
    5d02:	90 91 89 04 	lds	r25, 0x0489
    5d06:	20 91 3f 04 	lds	r18, 0x043F
    5d0a:	30 91 40 04 	lds	r19, 0x0440
    5d0e:	2e 5f       	subi	r18, 0xFE	; 254
    5d10:	3f 4f       	sbci	r19, 0xFF	; 255
    5d12:	b9 01       	movw	r22, r18
    5d14:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>
    5d18:	1e c0       	rjmp	.+60     	; 0x5d56 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5d1a:	40 91 86 04 	lds	r20, 0x0486
    5d1e:	50 91 87 04 	lds	r21, 0x0487
    5d22:	80 91 3f 04 	lds	r24, 0x043F
    5d26:	90 91 40 04 	lds	r25, 0x0440
    5d2a:	9c 01       	movw	r18, r24
    5d2c:	2e 5f       	subi	r18, 0xFE	; 254
    5d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    5d30:	ca 01       	movw	r24, r20
    5d32:	b9 01       	movw	r22, r18
    5d34:	0e 94 aa 12 	call	0x2554	; 0x2554 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5d38:	20 91 4b 04 	lds	r18, 0x044B
    5d3c:	30 91 4c 04 	lds	r19, 0x044C
    5d40:	8b 81       	ldd	r24, Y+3	; 0x03
    5d42:	9c 81       	ldd	r25, Y+4	; 0x04
    5d44:	82 17       	cp	r24, r18
    5d46:	93 07       	cpc	r25, r19
    5d48:	30 f4       	brcc	.+12     	; 0x5d56 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d4e:	90 93 4c 04 	sts	0x044C, r25
    5d52:	80 93 4b 04 	sts	0x044B, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5d56:	27 96       	adiw	r28, 0x07	; 7
    5d58:	0f b6       	in	r0, 0x3f	; 63
    5d5a:	f8 94       	cli
    5d5c:	de bf       	out	0x3e, r29	; 62
    5d5e:	0f be       	out	0x3f, r0	; 63
    5d60:	cd bf       	out	0x3d, r28	; 61
    5d62:	cf 91       	pop	r28
    5d64:	df 91       	pop	r29
    5d66:	08 95       	ret

00005d68 <__udivmodhi4>:
    5d68:	aa 1b       	sub	r26, r26
    5d6a:	bb 1b       	sub	r27, r27
    5d6c:	51 e1       	ldi	r21, 0x11	; 17
    5d6e:	07 c0       	rjmp	.+14     	; 0x5d7e <__udivmodhi4_ep>

00005d70 <__udivmodhi4_loop>:
    5d70:	aa 1f       	adc	r26, r26
    5d72:	bb 1f       	adc	r27, r27
    5d74:	a6 17       	cp	r26, r22
    5d76:	b7 07       	cpc	r27, r23
    5d78:	10 f0       	brcs	.+4      	; 0x5d7e <__udivmodhi4_ep>
    5d7a:	a6 1b       	sub	r26, r22
    5d7c:	b7 0b       	sbc	r27, r23

00005d7e <__udivmodhi4_ep>:
    5d7e:	88 1f       	adc	r24, r24
    5d80:	99 1f       	adc	r25, r25
    5d82:	5a 95       	dec	r21
    5d84:	a9 f7       	brne	.-22     	; 0x5d70 <__udivmodhi4_loop>
    5d86:	80 95       	com	r24
    5d88:	90 95       	com	r25
    5d8a:	bc 01       	movw	r22, r24
    5d8c:	cd 01       	movw	r24, r26
    5d8e:	08 95       	ret

00005d90 <memcpy>:
    5d90:	fb 01       	movw	r30, r22
    5d92:	dc 01       	movw	r26, r24
    5d94:	02 c0       	rjmp	.+4      	; 0x5d9a <memcpy+0xa>
    5d96:	01 90       	ld	r0, Z+
    5d98:	0d 92       	st	X+, r0
    5d9a:	41 50       	subi	r20, 0x01	; 1
    5d9c:	50 40       	sbci	r21, 0x00	; 0
    5d9e:	d8 f7       	brcc	.-10     	; 0x5d96 <memcpy+0x6>
    5da0:	08 95       	ret

00005da2 <memset>:
    5da2:	dc 01       	movw	r26, r24
    5da4:	01 c0       	rjmp	.+2      	; 0x5da8 <memset+0x6>
    5da6:	6d 93       	st	X+, r22
    5da8:	41 50       	subi	r20, 0x01	; 1
    5daa:	50 40       	sbci	r21, 0x00	; 0
    5dac:	e0 f7       	brcc	.-8      	; 0x5da6 <memset+0x4>
    5dae:	08 95       	ret

00005db0 <_exit>:
    5db0:	f8 94       	cli

00005db2 <__stop_program>:
    5db2:	ff cf       	rjmp	.-2      	; 0x5db2 <__stop_program>
